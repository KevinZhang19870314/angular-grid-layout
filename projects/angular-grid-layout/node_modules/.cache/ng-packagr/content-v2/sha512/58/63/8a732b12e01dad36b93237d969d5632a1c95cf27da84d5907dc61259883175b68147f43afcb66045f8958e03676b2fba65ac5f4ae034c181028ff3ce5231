{"hash":"bbd60f93d5d21a3cddb477bb4fb39d2558f60fee","fesm2020":{"code":"import { iif, fromEvent, merge, Observable, Subject, BehaviorSubject, NEVER, interval, animationFrameScheduler, combineLatest, of } from 'rxjs';\nimport { filter, switchMap, startWith, exhaustMap, takeUntil, take, map, tap, distinctUntilChanged } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Directive, Injectable, ElementRef, Component, ChangeDetectionStrategy, Inject, ContentChildren, ViewChild, Input, EventEmitter, ViewEncapsulation, Output, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n/**\r\n * IMPORTANT:\r\n * This utils are taken from the project: https://github.com/STRML/react-grid-layout.\r\n * The code should be as less modified as possible for easy maintenance.\r\n */\r\nconst DEBUG = false;\r\n/**\r\n * Return the bottom coordinate of the layout.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @return {Number}       Bottom coordinate.\r\n */\r\nfunction bottom(layout) {\r\n    let max = 0, bottomY;\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        bottomY = layout[i].y + layout[i].h;\r\n        if (bottomY > max) {\r\n            max = bottomY;\r\n        }\r\n    }\r\n    return max;\r\n}\r\nfunction cloneLayout(layout) {\r\n    const newLayout = Array(layout.length);\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        newLayout[i] = cloneLayoutItem(layout[i]);\r\n    }\r\n    return newLayout;\r\n}\r\n// Fast path to cloning, since this is monomorphic\r\n/** NOTE: This code has been modified from the original source */\r\nfunction cloneLayoutItem(layoutItem) {\r\n    const clonedLayoutItem = {\r\n        w: layoutItem.w,\r\n        h: layoutItem.h,\r\n        x: layoutItem.x,\r\n        y: layoutItem.y,\r\n        id: layoutItem.id,\r\n        moved: !!layoutItem.moved,\r\n        static: !!layoutItem.static,\r\n    };\r\n    if (layoutItem.minW !== undefined) {\r\n        clonedLayoutItem.minW = layoutItem.minW;\r\n    }\r\n    if (layoutItem.maxW !== undefined) {\r\n        clonedLayoutItem.maxW = layoutItem.maxW;\r\n    }\r\n    if (layoutItem.minH !== undefined) {\r\n        clonedLayoutItem.minH = layoutItem.minH;\r\n    }\r\n    if (layoutItem.maxH !== undefined) {\r\n        clonedLayoutItem.maxH = layoutItem.maxH;\r\n    }\r\n    // These can be null\r\n    if (layoutItem.isDraggable !== undefined) {\r\n        clonedLayoutItem.isDraggable = layoutItem.isDraggable;\r\n    }\r\n    if (layoutItem.isResizable !== undefined) {\r\n        clonedLayoutItem.isResizable = layoutItem.isResizable;\r\n    }\r\n    return clonedLayoutItem;\r\n}\r\n/**\r\n * Given two layoutitems, check if they collide.\r\n */\r\nfunction collides(l1, l2) {\r\n    if (l1.id === l2.id) {\r\n        return false;\r\n    } // same element\r\n    if (l1.x + l1.w <= l2.x) {\r\n        return false;\r\n    } // l1 is left of l2\r\n    if (l1.x >= l2.x + l2.w) {\r\n        return false;\r\n    } // l1 is right of l2\r\n    if (l1.y + l1.h <= l2.y) {\r\n        return false;\r\n    } // l1 is above l2\r\n    if (l1.y >= l2.y + l2.h) {\r\n        return false;\r\n    } // l1 is below l2\r\n    return true; // boxes overlap\r\n}\r\n/**\r\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\r\n * between items.\r\n *\r\n * @param  {Array} layout Layout.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\r\n *   vertically.\r\n * @return {Array}       Compacted Layout.\r\n */\r\nfunction compact(layout, compactType, cols) {\r\n    // Statics go in the compareWith array right away so items flow around them.\r\n    const compareWith = getStatics(layout);\r\n    // We go through the items by row and column.\r\n    const sorted = sortLayoutItems(layout, compactType);\r\n    // Holding for new items.\r\n    const out = Array(layout.length);\r\n    for (let i = 0, len = sorted.length; i < len; i++) {\r\n        let l = cloneLayoutItem(sorted[i]);\r\n        // Don't move static elements\r\n        if (!l.static) {\r\n            l = compactItem(compareWith, l, compactType, cols, sorted);\r\n            // Add to comparison array. We only collide with items before this one.\r\n            // Statics are already in this array.\r\n            compareWith.push(l);\r\n        }\r\n        // Add to output array to make sure they still come out in the right order.\r\n        out[layout.indexOf(sorted[i])] = l;\r\n        // Clear moved flag, if it exists.\r\n        l.moved = false;\r\n    }\r\n    return out;\r\n}\r\nconst heightWidth = { x: 'w', y: 'h' };\r\n/**\r\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\r\n */\r\nfunction resolveCompactionCollision(layout, item, moveToCoord, axis) {\r\n    const sizeProp = heightWidth[axis];\r\n    item[axis] += 1;\r\n    const itemIndex = layout\r\n        .map(layoutItem => {\r\n        return layoutItem.id;\r\n    })\r\n        .indexOf(item.id);\r\n    // Go through each item we collide with.\r\n    for (let i = itemIndex + 1; i < layout.length; i++) {\r\n        const otherItem = layout[i];\r\n        // Ignore static items\r\n        if (otherItem.static) {\r\n            continue;\r\n        }\r\n        // Optimization: we can break early if we know we're past this el\r\n        // We can do this b/c it's a sorted layout\r\n        if (otherItem.y > item.y + item.h) {\r\n            break;\r\n        }\r\n        if (collides(item, otherItem)) {\r\n            resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\r\n        }\r\n    }\r\n    item[axis] = moveToCoord;\r\n}\r\n/**\r\n * Compact an item in the layout.\r\n */\r\nfunction compactItem(compareWith, l, compactType, cols, fullLayout) {\r\n    const compactV = compactType === 'vertical';\r\n    const compactH = compactType === 'horizontal';\r\n    if (compactV) {\r\n        // Bottom 'y' possible is the bottom of the layout.\r\n        // This allows you to do nice stuff like specify {y: Infinity}\r\n        // This is here because the layout must be sorted in order to get the correct bottom `y`.\r\n        l.y = Math.min(bottom(compareWith), l.y);\r\n        // Move the element up as far as it can go without colliding.\r\n        while (l.y > 0 && !getFirstCollision(compareWith, l)) {\r\n            l.y--;\r\n        }\r\n    }\r\n    else if (compactH) {\r\n        l.y = Math.min(bottom(compareWith), l.y);\r\n        // Move the element left as far as it can go without colliding.\r\n        while (l.x > 0 && !getFirstCollision(compareWith, l)) {\r\n            l.x--;\r\n        }\r\n    }\r\n    // Move it down, and keep moving it down if it's colliding.\r\n    let collides;\r\n    while ((collides = getFirstCollision(compareWith, l))) {\r\n        if (compactH) {\r\n            resolveCompactionCollision(fullLayout, l, collides.x + collides.w, 'x');\r\n        }\r\n        else {\r\n            resolveCompactionCollision(fullLayout, l, collides.y + collides.h, 'y');\r\n        }\r\n        // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\r\n        if (compactH && l.x + l.w > cols) {\r\n            l.x = cols - l.w;\r\n            l.y++;\r\n        }\r\n    }\r\n    return l;\r\n}\r\n/**\r\n * Given a layout, make sure all elements fit within its bounds.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @param  {Number} bounds Number of columns.\r\n */\r\nfunction correctBounds(layout, bounds) {\r\n    const collidesWith = getStatics(layout);\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        const l = layout[i];\r\n        // Overflows right\r\n        if (l.x + l.w > bounds.cols) {\r\n            l.x = bounds.cols - l.w;\r\n        }\r\n        // Overflows left\r\n        if (l.x < 0) {\r\n            l.x = 0;\r\n            l.w = bounds.cols;\r\n        }\r\n        if (!l.static) {\r\n            collidesWith.push(l);\r\n        }\r\n        else {\r\n            // If this is static and collides with other statics, we must move it down.\r\n            // We have to do something nicer than just letting them overlap.\r\n            while (getFirstCollision(collidesWith, l)) {\r\n                l.y++;\r\n            }\r\n        }\r\n    }\r\n    return layout;\r\n}\r\n/**\r\n * Get a layout item by ID. Used so we can override later on if necessary.\r\n *\r\n * @param  {Array}  layout Layout array.\r\n * @param  {String} id     ID\r\n * @return {LayoutItem}    Item at ID.\r\n */\r\nfunction getLayoutItem(layout, id) {\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        if (layout[i].id === id) {\r\n            return layout[i];\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Returns the first item this layout collides with.\r\n * It doesn't appear to matter which order we approach this from, although\r\n * perhaps that is the wrong thing to do.\r\n *\r\n * @param  {Object} layoutItem Layout item.\r\n * @return {Object|undefined}  A colliding layout item, or undefined.\r\n */\r\nfunction getFirstCollision(layout, layoutItem) {\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        if (collides(layout[i], layoutItem)) {\r\n            return layout[i];\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction getAllCollisions(layout, layoutItem) {\r\n    return layout.filter(l => collides(l, layoutItem));\r\n}\r\n/**\r\n * Get all static elements.\r\n * @param  {Array} layout Array of layout objects.\r\n * @return {Array}        Array of static layout items..\r\n */\r\nfunction getStatics(layout) {\r\n    return layout.filter(l => l.static);\r\n}\r\n/**\r\n * Move an element. Responsible for doing cascading movements of other elements.\r\n *\r\n * @param  {Array}      layout            Full layout to modify.\r\n * @param  {LayoutItem} l                 element to move.\r\n * @param  {Number}     [x]               X position in grid units.\r\n * @param  {Number}     [y]               Y position in grid units.\r\n */\r\nfunction moveElement(layout, l, x, y, isUserAction, preventCollision, compactType, cols) {\r\n    // If this is static and not explicitly enabled as draggable,\r\n    // no move is possible, so we can short-circuit this immediately.\r\n    if (l.static && l.isDraggable !== true) {\r\n        return layout;\r\n    }\r\n    // Short-circuit if nothing to do.\r\n    if (l.y === y && l.x === x) {\r\n        return layout;\r\n    }\r\n    log(`Moving element ${l.id} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);\r\n    const oldX = l.x;\r\n    const oldY = l.y;\r\n    // This is quite a bit faster than extending the object\r\n    if (typeof x === 'number') {\r\n        l.x = x;\r\n    }\r\n    if (typeof y === 'number') {\r\n        l.y = y;\r\n    }\r\n    l.moved = true;\r\n    // If this collides with anything, move it.\r\n    // When doing this comparison, we have to sort the items we compare with\r\n    // to ensure, in the case of multiple collisions, that we're getting the\r\n    // nearest collision.\r\n    let sorted = sortLayoutItems(layout, compactType);\r\n    const movingUp = compactType === 'vertical' && typeof y === 'number'\r\n        ? oldY >= y\r\n        : compactType === 'horizontal' && typeof x === 'number'\r\n            ? oldX >= x\r\n            : false;\r\n    if (movingUp) {\r\n        sorted = sorted.reverse();\r\n    }\r\n    const collisions = getAllCollisions(sorted, l);\r\n    // There was a collision; abort\r\n    if (preventCollision && collisions.length) {\r\n        log(`Collision prevented on ${l.id}, reverting.`);\r\n        l.x = oldX;\r\n        l.y = oldY;\r\n        l.moved = false;\r\n        return layout;\r\n    }\r\n    // Move each item that collides away from this element.\r\n    for (let i = 0, len = collisions.length; i < len; i++) {\r\n        const collision = collisions[i];\r\n        log(`Resolving collision between ${l.id} at [${l.x},${l.y}] and ${collision.id} at [${collision.x},${collision.y}]`);\r\n        // Short circuit so we can't infinite loop\r\n        if (collision.moved) {\r\n            continue;\r\n        }\r\n        // Don't move static items - we have to move *this* element away\r\n        if (collision.static) {\r\n            layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\r\n        }\r\n        else {\r\n            layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\r\n        }\r\n    }\r\n    return layout;\r\n}\r\n/**\r\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\r\n * We attempt to move it up if there's room, otherwise it goes below.\r\n *\r\n * @param  {Array} layout            Full layout to modify.\r\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\r\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\r\n */\r\nfunction moveElementAwayFromCollision(layout, collidesWith, itemToMove, isUserAction, compactType, cols) {\r\n    const compactH = compactType === 'horizontal';\r\n    // Compact vertically if not set to horizontal\r\n    const compactV = compactType !== 'horizontal';\r\n    const preventCollision = collidesWith.static; // we're already colliding (not for static items)\r\n    // If there is enough space above the collision to put this element, move it there.\r\n    // We only do this on the main collision as this can get funky in cascades and cause\r\n    // unwanted swapping behavior.\r\n    if (isUserAction) {\r\n        // Reset isUserAction flag because we're not in the main collision anymore.\r\n        isUserAction = false;\r\n        // Make a mock item so we don't modify the item here, only modify in moveElement.\r\n        const fakeItem = {\r\n            x: compactH\r\n                ? Math.max(collidesWith.x - itemToMove.w, 0)\r\n                : itemToMove.x,\r\n            y: compactV\r\n                ? Math.max(collidesWith.y - itemToMove.h, 0)\r\n                : itemToMove.y,\r\n            w: itemToMove.w,\r\n            h: itemToMove.h,\r\n            id: '-1',\r\n        };\r\n        // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\r\n        if (!getFirstCollision(layout, fakeItem)) {\r\n            log(`Doing reverse collision on ${itemToMove.id} up to [${fakeItem.x},${fakeItem.y}].`);\r\n            return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\r\n        }\r\n    }\r\n    return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\r\n}\r\n/**\r\n * Helper to convert a number to a percentage string.\r\n *\r\n * @param  {Number} num Any number\r\n * @return {String}     That number as a percentage.\r\n */\r\nfunction perc(num) {\r\n    return num * 100 + '%';\r\n}\r\nfunction setTransform({ top, left, width, height }) {\r\n    // Replace unitless items with px\r\n    const translate = `translate(${left}px,${top}px)`;\r\n    return {\r\n        transform: translate,\r\n        WebkitTransform: translate,\r\n        MozTransform: translate,\r\n        msTransform: translate,\r\n        OTransform: translate,\r\n        width: `${width}px`,\r\n        height: `${height}px`,\r\n        position: 'absolute',\r\n    };\r\n}\r\nfunction setTopLeft({ top, left, width, height }) {\r\n    return {\r\n        top: `${top}px`,\r\n        left: `${left}px`,\r\n        width: `${width}px`,\r\n        height: `${height}px`,\r\n        position: 'absolute',\r\n    };\r\n}\r\n/**\r\n * Get layout items sorted from top left to right and down.\r\n *\r\n * @return {Array} Array of layout objects.\r\n * @return {Array}        Layout, sorted static items first.\r\n */\r\nfunction sortLayoutItems(layout, compactType) {\r\n    if (compactType === 'horizontal') {\r\n        return sortLayoutItemsByColRow(layout);\r\n    }\r\n    else {\r\n        return sortLayoutItemsByRowCol(layout);\r\n    }\r\n}\r\nfunction sortLayoutItemsByRowCol(layout) {\r\n    return [].concat(layout).sort(function (a, b) {\r\n        if (a.y > b.y || (a.y === b.y && a.x > b.x)) {\r\n            return 1;\r\n        }\r\n        else if (a.y === b.y && a.x === b.x) {\r\n            // Without this, we can get different sort results in IE vs. Chrome/FF\r\n            return 0;\r\n        }\r\n        return -1;\r\n    });\r\n}\r\nfunction sortLayoutItemsByColRow(layout) {\r\n    return [].concat(layout).sort(function (a, b) {\r\n        if (a.x > b.x || (a.x === b.x && a.y > b.y)) {\r\n            return 1;\r\n        }\r\n        return -1;\r\n    });\r\n}\r\n/**\r\n * Validate a layout. Throws errors.\r\n *\r\n * @param  {Array}  layout        Array of layout items.\r\n * @param  {String} [contextName] Context name for errors.\r\n * @throw  {Error}                Validation error.\r\n */\r\nfunction validateLayout(layout, contextName = 'Layout') {\r\n    const subProps = ['x', 'y', 'w', 'h'];\r\n    if (!Array.isArray(layout)) {\r\n        throw new Error(contextName + ' must be an array!');\r\n    }\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        const item = layout[i];\r\n        for (let j = 0; j < subProps.length; j++) {\r\n            if (typeof item[subProps[j]] !== 'number') {\r\n                throw new Error('ReactGridLayout: ' +\r\n                    contextName +\r\n                    '[' +\r\n                    i +\r\n                    '].' +\r\n                    subProps[j] +\r\n                    ' must be a number!');\r\n            }\r\n        }\r\n        if (item.id && typeof item.id !== 'string') {\r\n            throw new Error('ReactGridLayout: ' +\r\n                contextName +\r\n                '[' +\r\n                i +\r\n                '].i must be a string!');\r\n        }\r\n        if (item.static !== undefined && typeof item.static !== 'boolean') {\r\n            throw new Error('ReactGridLayout: ' +\r\n                contextName +\r\n                '[' +\r\n                i +\r\n                '].static must be a boolean!');\r\n        }\r\n    }\r\n}\r\n// Flow can't really figure this out, so we just use Object\r\nfunction autoBindHandlers(el, fns) {\r\n    fns.forEach(key => (el[key] = el[key].bind(el)));\r\n}\r\nfunction log(...args) {\r\n    if (!DEBUG) {\r\n        return;\r\n    }\r\n    // eslint-disable-next-line no-console\r\n    console.log(...args);\r\n}\r\nconst noop = () => { };\n\n/** Cached result of whether the user's browser supports passive event listeners. */\r\nlet supportsPassiveEvents;\r\n/**\r\n * Checks whether the user's browser supports passive event listeners.\r\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\r\n */\r\nfunction ktdSupportsPassiveEventListeners() {\r\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\r\n        try {\r\n            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\r\n                get: () => supportsPassiveEvents = true\r\n            }));\r\n        }\r\n        finally {\r\n            supportsPassiveEvents = supportsPassiveEvents || false;\r\n        }\r\n    }\r\n    return supportsPassiveEvents;\r\n}\r\n/**\r\n * Normalizes an `AddEventListener` object to something that can be passed\r\n * to `addEventListener` on any browser, no matter whether it supports the\r\n * `options` parameter.\r\n * @param options Object to be normalized.\r\n */\r\nfunction ktdNormalizePassiveListenerOptions(options) {\r\n    return ktdSupportsPassiveEventListeners() ? options : !!options.capture;\r\n}\n\n/** Options that can be used to bind a passive event listener. */\r\nconst passiveEventListenerOptions = ktdNormalizePassiveListenerOptions({ passive: true });\r\n/** Options that can be used to bind an active event listener. */\r\nconst activeEventListenerOptions = ktdNormalizePassiveListenerOptions({ passive: false });\r\nlet isMobile = null;\r\nfunction ktdIsMobileOrTablet() {\r\n    if (isMobile != null) {\r\n        return isMobile;\r\n    }\r\n    // Generic match pattern to identify mobile or tablet devices\r\n    const isMobileDevice = /Android|webOS|BlackBerry|Windows Phone|iPad|iPhone|iPod/i.test(navigator.userAgent);\r\n    // Since IOS 13 is not safe to just check for the generic solution. See: https://stackoverflow.com/questions/58019463/how-to-detect-device-name-in-safari-on-ios-13-while-it-doesnt-show-the-correct\r\n    const isIOSMobileDevice = /iPad|iPhone|iPod/.test(navigator.platform) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);\r\n    isMobile = isMobileDevice || isIOSMobileDevice;\r\n    return isMobile;\r\n}\r\nfunction ktdIsMouseEvent(event) {\r\n    return event.clientX != null;\r\n}\r\nfunction ktdIsTouchEvent(event) {\r\n    return event.touches != null && event.touches.length != null;\r\n}\r\nfunction ktdPointerClientX(event) {\r\n    return ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX;\r\n}\r\nfunction ktdPointerClientY(event) {\r\n    return ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY;\r\n}\r\nfunction ktdPointerClient(event) {\r\n    return {\r\n        clientX: ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX,\r\n        clientY: ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY\r\n    };\r\n}\r\n/**\r\n * Emits when a mousedown or touchstart emits. Avoids conflicts between both events.\r\n * @param element, html element where to  listen the events.\r\n * @param touchNumber number of the touch to track the event, default to the first one.\r\n */\r\nfunction ktdMouseOrTouchDown(element, touchNumber = 1) {\r\n    return iif(() => ktdIsMobileOrTablet(), fromEvent(element, 'touchstart', passiveEventListenerOptions).pipe(filter((touchEvent) => touchEvent.touches.length === touchNumber)), fromEvent(element, 'mousedown', activeEventListenerOptions).pipe(filter((mouseEvent) => {\r\n        /**\r\n         * 0 : Left mouse button\r\n         * 1 : Wheel button or middle button (if present)\r\n         * 2 : Right mouse button\r\n         */\r\n        return mouseEvent.button === 0; // Mouse down to be only fired if is left click\r\n    })));\r\n}\r\n/**\r\n * Emits when a 'mousemove' or a 'touchmove' event gets fired.\r\n * @param element, html element where to  listen the events.\r\n * @param touchNumber number of the touch to track the event, default to the first one.\r\n */\r\nfunction ktdMouseOrTouchMove(element, touchNumber = 1) {\r\n    return iif(() => ktdIsMobileOrTablet(), fromEvent(element, 'touchmove', activeEventListenerOptions).pipe(filter((touchEvent) => touchEvent.touches.length === touchNumber)), fromEvent(element, 'mousemove', activeEventListenerOptions));\r\n}\r\nfunction ktdTouchEnd(element, touchNumber = 1) {\r\n    return merge(fromEvent(element, 'touchend').pipe(filter((touchEvent) => touchEvent.touches.length === touchNumber - 1)), fromEvent(element, 'touchcancel').pipe(filter((touchEvent) => touchEvent.touches.length === touchNumber - 1)));\r\n}\r\n/**\r\n * Emits when a there is a 'mouseup' or the touch ends.\r\n * @param element, html element where to  listen the events.\r\n * @param touchNumber number of the touch to track the event, default to the first one.\r\n */\r\nfunction ktdMouseOrTouchEnd(element, touchNumber = 1) {\r\n    return iif(() => ktdIsMobileOrTablet(), ktdTouchEnd(element, touchNumber), fromEvent(element, 'mouseup'));\r\n}\n\n/** Tracks items by id. This function is mean to be used in conjunction with the ngFor that renders the 'ktd-grid-items' */\r\nfunction ktdTrackById(index, item) {\r\n    return item.id;\r\n}\r\n/**\r\n * Call react-grid-layout utils 'compact()' function and return the compacted layout.\r\n * @param layout to be compacted.\r\n * @param compactType, type of compaction.\r\n * @param cols, number of columns of the grid.\r\n */\r\nfunction ktdGridCompact(layout, compactType, cols) {\r\n    return compact(layout, compactType, cols)\r\n        // Prune react-grid-layout compact extra properties.\r\n        .map(item => ({ id: item.id, x: item.x, y: item.y, w: item.w, h: item.h, minW: item.minW, minH: item.minH, maxW: item.maxW, maxH: item.maxH }));\r\n}\r\nfunction screenXPosToGridValue(screenXPos, cols, width) {\r\n    return Math.round((screenXPos * cols) / width);\r\n}\r\nfunction screenYPosToGridValue(screenYPos, rowHeight, height) {\r\n    return Math.round(screenYPos / rowHeight);\r\n}\r\n/** Returns a Dictionary where the key is the id and the value is the change applied to that item. If no changes Dictionary is empty. */\r\nfunction ktdGetGridLayoutDiff(gridLayoutA, gridLayoutB) {\r\n    const diff = {};\r\n    gridLayoutA.forEach(itemA => {\r\n        const itemB = gridLayoutB.find(_itemB => _itemB.id === itemA.id);\r\n        if (itemB != null) {\r\n            const posChanged = itemA.x !== itemB.x || itemA.y !== itemB.y;\r\n            const sizeChanged = itemA.w !== itemB.w || itemA.h !== itemB.h;\r\n            const change = posChanged && sizeChanged ? 'moveresize' : posChanged ? 'move' : sizeChanged ? 'resize' : null;\r\n            if (change) {\r\n                diff[itemB.id] = { change };\r\n            }\r\n        }\r\n    });\r\n    return diff;\r\n}\r\n/**\r\n * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position\r\n * @param gridItem grid item that is been dragged\r\n * @param config current grid configuration\r\n * @param compactionType type of compaction that will be performed\r\n * @param draggingData contains all the information about the drag\r\n */\r\nfunction ktdGridItemDragging(gridItem, config, compactionType, draggingData) {\r\n    const { pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference } = draggingData;\r\n    const gridItemId = gridItem.id;\r\n    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId);\r\n    const clientStartX = ktdPointerClientX(pointerDownEvent);\r\n    const clientStartY = ktdPointerClientY(pointerDownEvent);\r\n    const clientX = ktdPointerClientX(pointerDragEvent);\r\n    const clientY = ktdPointerClientY(pointerDragEvent);\r\n    const offsetX = clientStartX - dragElemClientRect.left;\r\n    const offsetY = clientStartY - dragElemClientRect.top;\r\n    // Grid element positions taking into account the possible scroll total difference from the beginning.\r\n    const gridElementLeftPosition = gridElemClientRect.left + scrollDifference.left;\r\n    const gridElementTopPosition = gridElemClientRect.top + scrollDifference.top;\r\n    // Calculate position relative to the grid element.\r\n    const gridRelXPos = clientX - gridElementLeftPosition - offsetX;\r\n    const gridRelYPos = clientY - gridElementTopPosition - offsetY;\r\n    // Get layout item position\r\n    const layoutItem = {\r\n        ...draggingElemPrevItem,\r\n        x: screenXPosToGridValue(gridRelXPos, config.cols, gridElemClientRect.width),\r\n        y: screenYPosToGridValue(gridRelYPos, config.rowHeight, gridElemClientRect.height)\r\n    };\r\n    // Correct the values if they overflow, since 'moveElement' function doesn't do it\r\n    layoutItem.x = Math.max(0, layoutItem.x);\r\n    layoutItem.y = Math.max(0, layoutItem.y);\r\n    if (layoutItem.x + layoutItem.w > config.cols) {\r\n        layoutItem.x = Math.max(0, config.cols - layoutItem.w);\r\n    }\r\n    // Parse to LayoutItem array data in order to use 'react.grid-layout' utils\r\n    const layoutItems = config.layout;\r\n    const draggedLayoutItem = layoutItems.find(item => item.id === gridItemId);\r\n    let newLayoutItems = moveElement(layoutItems, draggedLayoutItem, layoutItem.x, layoutItem.y, true, config.preventCollision, compactionType, config.cols);\r\n    newLayoutItems = compact(newLayoutItems, compactionType, config.cols);\r\n    return {\r\n        layout: newLayoutItems,\r\n        draggedItemPos: {\r\n            top: gridRelYPos,\r\n            left: gridRelXPos,\r\n            width: dragElemClientRect.width,\r\n            height: dragElemClientRect.height,\r\n        }\r\n    };\r\n}\r\n/**\r\n * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position\r\n * @param gridItem grid item that is been dragged\r\n * @param config current grid configuration\r\n * @param compactionType type of compaction that will be performed\r\n * @param draggingData contains all the information about the drag\r\n */\r\nfunction ktdGridItemResizing(gridItem, config, compactionType, draggingData) {\r\n    const { pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference } = draggingData;\r\n    const gridItemId = gridItem.id;\r\n    const clientStartX = ktdPointerClientX(pointerDownEvent);\r\n    const clientStartY = ktdPointerClientY(pointerDownEvent);\r\n    const clientX = ktdPointerClientX(pointerDragEvent);\r\n    const clientY = ktdPointerClientY(pointerDragEvent);\r\n    // Get the difference between the mouseDown and the position 'right' of the resize element.\r\n    const resizeElemOffsetX = dragElemClientRect.width - (clientStartX - dragElemClientRect.left);\r\n    const resizeElemOffsetY = dragElemClientRect.height - (clientStartY - dragElemClientRect.top);\r\n    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId);\r\n    const width = clientX + resizeElemOffsetX - (dragElemClientRect.left + scrollDifference.left);\r\n    const height = clientY + resizeElemOffsetY - (dragElemClientRect.top + scrollDifference.top);\r\n    // Get layout item grid position\r\n    const layoutItem = {\r\n        ...draggingElemPrevItem,\r\n        w: screenXPosToGridValue(width, config.cols, gridElemClientRect.width),\r\n        h: screenYPosToGridValue(height, config.rowHeight, gridElemClientRect.height)\r\n    };\r\n    layoutItem.w = limitNumberWithinRange(layoutItem.w, gridItem.minW ?? layoutItem.minW, gridItem.maxW ?? layoutItem.maxW);\r\n    layoutItem.h = limitNumberWithinRange(layoutItem.h, gridItem.minH ?? layoutItem.minH, gridItem.maxH ?? layoutItem.maxH);\r\n    if (layoutItem.x + layoutItem.w > config.cols) {\r\n        layoutItem.w = Math.max(1, config.cols - layoutItem.x);\r\n    }\r\n    if (config.preventCollision) {\r\n        const maxW = layoutItem.w;\r\n        const maxH = layoutItem.h;\r\n        let colliding = hasCollision(config.layout, layoutItem);\r\n        let shrunkDimension;\r\n        while (colliding) {\r\n            shrunkDimension = getDimensionToShrink(layoutItem, shrunkDimension);\r\n            layoutItem[shrunkDimension]--;\r\n            colliding = hasCollision(config.layout, layoutItem);\r\n        }\r\n        if (shrunkDimension === 'w') {\r\n            layoutItem.h = maxH;\r\n            colliding = hasCollision(config.layout, layoutItem);\r\n            while (colliding) {\r\n                layoutItem.h--;\r\n                colliding = hasCollision(config.layout, layoutItem);\r\n            }\r\n        }\r\n        if (shrunkDimension === 'h') {\r\n            layoutItem.w = maxW;\r\n            colliding = hasCollision(config.layout, layoutItem);\r\n            while (colliding) {\r\n                layoutItem.w--;\r\n                colliding = hasCollision(config.layout, layoutItem);\r\n            }\r\n        }\r\n    }\r\n    const newLayoutItems = config.layout.map((item) => {\r\n        return item.id === gridItemId ? layoutItem : item;\r\n    });\r\n    return {\r\n        layout: compact(newLayoutItems, compactionType, config.cols),\r\n        draggedItemPos: {\r\n            top: dragElemClientRect.top - gridElemClientRect.top,\r\n            left: dragElemClientRect.left - gridElemClientRect.left,\r\n            width,\r\n            height,\r\n        }\r\n    };\r\n}\r\nfunction hasCollision(layout, layoutItem) {\r\n    return !!getFirstCollision(layout, layoutItem);\r\n}\r\nfunction getDimensionToShrink(layoutItem, lastShrunk) {\r\n    if (layoutItem.h <= 1) {\r\n        return 'w';\r\n    }\r\n    if (layoutItem.w <= 1) {\r\n        return 'h';\r\n    }\r\n    return lastShrunk === 'w' ? 'h' : 'w';\r\n}\r\n/**\r\n * Given the current number and min/max values, returns the number within the range\r\n * @param number can be any numeric value\r\n * @param min minimum value of range\r\n * @param max maximum value of range\r\n */\r\nfunction limitNumberWithinRange(num, min = 1, max = Infinity) {\r\n    return Math.min(Math.max(num, min < 1 ? 1 : min), max);\r\n}\n\n/**\r\n * Injection token that can be used to reference instances of `KtdGridDragHandle`. It serves as\r\n * alternative token to the actual `KtdGridDragHandle` class which could cause unnecessary\r\n * retention of the class and its directive metadata.\r\n */\r\nconst KTD_GRID_DRAG_HANDLE = new InjectionToken('KtdGridDragHandle');\r\n/** Handle that can be used to drag a KtdGridItem instance. */\r\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\r\nclass KtdGridDragHandle {\r\n    constructor(element) {\r\n        this.element = element;\r\n    }\r\n}\r\nKtdGridDragHandle.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridDragHandle, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\r\nKtdGridDragHandle.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.2.7\", type: KtdGridDragHandle, selector: \"[ktdGridDragHandle]\", host: { classAttribute: \"ktd-grid-drag-handle\" }, providers: [{ provide: KTD_GRID_DRAG_HANDLE, useExisting: KtdGridDragHandle }], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridDragHandle, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[ktdGridDragHandle]',\r\n                    // eslint-disable-next-line @angular-eslint/no-host-metadata-property\r\n                    host: {\r\n                        class: 'ktd-grid-drag-handle'\r\n                    },\r\n                    providers: [{ provide: KTD_GRID_DRAG_HANDLE, useExisting: KtdGridDragHandle }],\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });\n\n/**\r\n * Injection token that can be used to reference instances of `KtdGridResizeHandle`. It serves as\r\n * alternative token to the actual `KtdGridResizeHandle` class which could cause unnecessary\r\n * retention of the class and its directive metadata.\r\n */\r\nconst KTD_GRID_RESIZE_HANDLE = new InjectionToken('KtdGridResizeHandle');\r\n/** Handle that can be used to drag a KtdGridItem instance. */\r\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\r\nclass KtdGridResizeHandle {\r\n    constructor(element) {\r\n        this.element = element;\r\n    }\r\n}\r\nKtdGridResizeHandle.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridResizeHandle, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\r\nKtdGridResizeHandle.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.2.7\", type: KtdGridResizeHandle, selector: \"[ktdGridResizeHandle]\", host: { classAttribute: \"ktd-grid-resize-handle\" }, providers: [{ provide: KTD_GRID_RESIZE_HANDLE, useExisting: KtdGridResizeHandle }], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridResizeHandle, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[ktdGridResizeHandle]',\r\n                    // eslint-disable-next-line @angular-eslint/no-host-metadata-property\r\n                    host: {\r\n                        class: 'ktd-grid-resize-handle'\r\n                    },\r\n                    providers: [{ provide: KTD_GRID_RESIZE_HANDLE, useExisting: KtdGridResizeHandle }],\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });\n\nconst GRID_ITEM_GET_RENDER_DATA_TOKEN = new InjectionToken('GRID_ITEM_GET_RENDER_DATA_TOKEN');\n\n/** Runs source observable outside the zone */\r\nfunction ktdOutsideZone(zone) {\r\n    return (source) => {\r\n        return new Observable(observer => {\r\n            return zone.runOutsideAngular(() => source.subscribe(observer));\r\n        });\r\n    };\r\n}\r\n/** Rxjs operator that makes source observable to no emit any data */\r\nfunction ktdNoEmit() {\r\n    return (source$) => {\r\n        return source$.pipe(filter(() => false));\r\n    };\r\n}\n\n/** Coerces a data-bound value (typically a string) to a boolean. */\r\nfunction coerceBooleanProperty(value) {\r\n    return value != null && `${value}` !== 'false';\r\n}\n\nfunction coerceNumberProperty(value, fallbackValue = 0) {\r\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\r\n}\r\n/**\r\n * Whether the provided value is considered a number.\r\n * @docs-private\r\n */\r\nfunction _isNumberValue(value) {\r\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\r\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\r\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\r\n    return !isNaN(parseFloat(value)) && !isNaN(Number(value));\r\n}\n\n/** Event options that can be used to bind an active, capturing event. */\r\nconst activeCapturingEventOptions = ktdNormalizePassiveListenerOptions({\r\n    passive: false,\r\n    capture: true\r\n});\r\nclass KtdGridService {\r\n    constructor(ngZone) {\r\n        this.ngZone = ngZone;\r\n        this.touchMoveSubject = new Subject();\r\n        this.touchMove$ = this.touchMoveSubject.asObservable();\r\n        this.registerTouchMoveSubscription();\r\n    }\r\n    ngOnDestroy() {\r\n        this.touchMoveSubscription.unsubscribe();\r\n    }\r\n    mouseOrTouchMove$(element) {\r\n        return iif(() => ktdIsMobileOrTablet(), this.touchMove$, fromEvent(element, 'mousemove', activeCapturingEventOptions) // TODO: Fix rxjs typings, boolean should be a good param too.\r\n        );\r\n    }\r\n    registerTouchMoveSubscription() {\r\n        // The `touchmove` event gets bound once, ahead of time, because WebKit\r\n        // won't preventDefault on a dynamically-added `touchmove` listener.\r\n        // See https://bugs.webkit.org/show_bug.cgi?id=184250.\r\n        this.touchMoveSubscription = this.ngZone.runOutsideAngular(() => \r\n        // The event handler has to be explicitly active,\r\n        // because newer browsers make it passive by default.\r\n        fromEvent(document, 'touchmove', activeCapturingEventOptions) // TODO: Fix rxjs typings, boolean should be a good param too.\r\n            .pipe(filter((touchEvent) => touchEvent.touches.length === 1))\r\n            .subscribe((touchEvent) => this.touchMoveSubject.next(touchEvent)));\r\n    }\r\n}\r\nKtdGridService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\r\nKtdGridService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });\n\nclass KtdGridItemComponent {\r\n    constructor(elementRef, gridService, renderer, ngZone, getItemRenderData) {\r\n        this.elementRef = elementRef;\r\n        this.gridService = gridService;\r\n        this.renderer = renderer;\r\n        this.ngZone = ngZone;\r\n        this.getItemRenderData = getItemRenderData;\r\n        /** CSS transition style. Note that for more performance is preferable only make transition on transform property. */\r\n        this.transition = 'transform 500ms ease, width 500ms ease, height 500ms ease';\r\n        this._dragStartThreshold = 0;\r\n        this._draggable = true;\r\n        this._draggable$ = new BehaviorSubject(this._draggable);\r\n        this._resizable = true;\r\n        this._resizable$ = new BehaviorSubject(this._resizable);\r\n        this.dragStartSubject = new Subject();\r\n        this.resizeStartSubject = new Subject();\r\n        this.subscriptions = [];\r\n        this.dragStart$ = this.dragStartSubject.asObservable();\r\n        this.resizeStart$ = this.resizeStartSubject.asObservable();\r\n    }\r\n    /** Id of the grid item. This property is strictly compulsory. */\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    set id(val) {\r\n        this._id = val;\r\n    }\r\n    /** Minimum amount of pixels that the user should move before it starts the drag sequence. */\r\n    get dragStartThreshold() { return this._dragStartThreshold; }\r\n    set dragStartThreshold(val) {\r\n        this._dragStartThreshold = coerceNumberProperty(val);\r\n    }\r\n    /** Whether the item is draggable or not. Defaults to true. */\r\n    get draggable() {\r\n        return this._draggable;\r\n    }\r\n    set draggable(val) {\r\n        this._draggable = coerceBooleanProperty(val);\r\n        this._draggable$.next(this._draggable);\r\n    }\r\n    /** Whether the item is resizable or not. Defaults to true. */\r\n    get resizable() {\r\n        return this._resizable;\r\n    }\r\n    set resizable(val) {\r\n        this._resizable = coerceBooleanProperty(val);\r\n        this._resizable$.next(this._resizable);\r\n    }\r\n    ngOnInit() {\r\n        const gridItemRenderData = this.getItemRenderData(this.id);\r\n        this.setStyles(gridItemRenderData);\r\n    }\r\n    ngAfterContentInit() {\r\n        this.subscriptions.push(this._dragStart$().subscribe(this.dragStartSubject), this._resizeStart$().subscribe(this.resizeStartSubject));\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscriptions.forEach(sub => sub.unsubscribe());\r\n    }\r\n    setStyles({ top, left, width, height }) {\r\n        // transform is 6x times faster than top/left\r\n        this.renderer.setStyle(this.elementRef.nativeElement, 'transform', `translateX(${left}) translateY(${top})`);\r\n        this.renderer.setStyle(this.elementRef.nativeElement, 'display', `block`);\r\n        this.renderer.setStyle(this.elementRef.nativeElement, 'transition', this.transition);\r\n        if (width != null) {\r\n            this.renderer.setStyle(this.elementRef.nativeElement, 'width', width);\r\n        }\r\n        if (height != null) {\r\n            this.renderer.setStyle(this.elementRef.nativeElement, 'height', height);\r\n        }\r\n    }\r\n    _dragStart$() {\r\n        return this._draggable$.pipe(switchMap((draggable) => {\r\n            if (!draggable) {\r\n                return NEVER;\r\n            }\r\n            else {\r\n                return this._dragHandles.changes.pipe(startWith(this._dragHandles), switchMap((dragHandles) => {\r\n                    return iif(() => dragHandles.length > 0, merge(...dragHandles.toArray().map(dragHandle => ktdMouseOrTouchDown(dragHandle.element.nativeElement, 1))), ktdMouseOrTouchDown(this.elementRef.nativeElement, 1)).pipe(exhaustMap((startEvent) => {\r\n                        // If the event started from an element with the native HTML drag&drop, it'll interfere\r\n                        // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\r\n                        // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\r\n                        // it's flaky and it fails if the user drags it away quickly. Also note that we only want\r\n                        // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\r\n                        // events from firing on touch devices.\r\n                        if (startEvent.target && startEvent.target.draggable && startEvent.type === 'mousedown') {\r\n                            startEvent.preventDefault();\r\n                        }\r\n                        const startPointer = ktdPointerClient(startEvent);\r\n                        return this.gridService.mouseOrTouchMove$(document).pipe(takeUntil(ktdMouseOrTouchEnd(document, 1)), ktdOutsideZone(this.ngZone), filter((moveEvent) => {\r\n                            moveEvent.preventDefault();\r\n                            const movePointer = ktdPointerClient(moveEvent);\r\n                            const distanceX = Math.abs(startPointer.clientX - movePointer.clientX);\r\n                            const distanceY = Math.abs(startPointer.clientY - movePointer.clientY);\r\n                            // When this conditions returns true mean that we are over threshold.\r\n                            return distanceX + distanceY >= this.dragStartThreshold;\r\n                        }), take(1), \r\n                        // Return the original start event\r\n                        map(() => startEvent));\r\n                    }));\r\n                }));\r\n            }\r\n        }));\r\n    }\r\n    _resizeStart$() {\r\n        return this._resizable$.pipe(switchMap((resizable) => {\r\n            if (!resizable) {\r\n                // Side effect to hide the resizeElem if resize is disabled.\r\n                this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\r\n                return NEVER;\r\n            }\r\n            else {\r\n                return this._resizeHandles.changes.pipe(startWith(this._resizeHandles), switchMap((resizeHandles) => {\r\n                    if (resizeHandles.length > 0) {\r\n                        // Side effect to hide the resizeElem if there are resize handles.\r\n                        this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\r\n                        return merge(...resizeHandles.toArray().map(resizeHandle => ktdMouseOrTouchDown(resizeHandle.element.nativeElement, 1)));\r\n                    }\r\n                    else {\r\n                        this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'block');\r\n                        return ktdMouseOrTouchDown(this.resizeElem.nativeElement, 1);\r\n                    }\r\n                }));\r\n            }\r\n        }));\r\n    }\r\n}\r\nKtdGridItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridItemComponent, deps: [{ token: i0.ElementRef }, { token: KtdGridService }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: GRID_ITEM_GET_RENDER_DATA_TOKEN }], target: i0.ɵɵFactoryTarget.Component });\r\nKtdGridItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.2.7\", type: KtdGridItemComponent, selector: \"ktd-grid-item\", inputs: { minW: \"minW\", minH: \"minH\", maxW: \"maxW\", maxH: \"maxH\", transition: \"transition\", id: \"id\", dragStartThreshold: \"dragStartThreshold\", draggable: \"draggable\", resizable: \"resizable\" }, queries: [{ propertyName: \"_dragHandles\", predicate: KTD_GRID_DRAG_HANDLE, descendants: true }, { propertyName: \"_resizeHandles\", predicate: KTD_GRID_RESIZE_HANDLE, descendants: true }], viewQueries: [{ propertyName: \"resizeElem\", first: true, predicate: [\"resizeElem\"], descendants: true, read: ElementRef, static: true }], ngImport: i0, template: \"<ng-content></ng-content>\\n<div #resizeElem class=\\\"grid-item-resize-icon\\\"></div>\\n\", styles: [\":host{display:none;position:absolute;z-index:1;overflow:hidden}:host div{position:absolute;-webkit-user-select:none;user-select:none;z-index:10}:host div.grid-item-resize-icon{cursor:se-resize;width:20px;height:20px;bottom:0;right:0;color:inherit}:host div.grid-item-resize-icon:after{content:\\\"\\\";position:absolute;right:3px;bottom:3px;width:5px;height:5px;border-right:2px solid;border-bottom:2px solid}.display-none{display:none!important}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridItemComponent, decorators: [{\r\n            type: Component,\r\n            args: [{ selector: 'ktd-grid-item', changeDetection: ChangeDetectionStrategy.OnPush, template: \"<ng-content></ng-content>\\n<div #resizeElem class=\\\"grid-item-resize-icon\\\"></div>\\n\", styles: [\":host{display:none;position:absolute;z-index:1;overflow:hidden}:host div{position:absolute;-webkit-user-select:none;user-select:none;z-index:10}:host div.grid-item-resize-icon{cursor:se-resize;width:20px;height:20px;bottom:0;right:0;color:inherit}:host div.grid-item-resize-icon:after{content:\\\"\\\";position:absolute;right:3px;bottom:3px;width:5px;height:5px;border-right:2px solid;border-bottom:2px solid}.display-none{display:none!important}\\n\"] }]\r\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: KtdGridService }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: undefined, decorators: [{\r\n                    type: Inject,\r\n                    args: [GRID_ITEM_GET_RENDER_DATA_TOKEN]\r\n                }] }]; }, propDecorators: { _dragHandles: [{\r\n                type: ContentChildren,\r\n                args: [KTD_GRID_DRAG_HANDLE, { descendants: true }]\r\n            }], _resizeHandles: [{\r\n                type: ContentChildren,\r\n                args: [KTD_GRID_RESIZE_HANDLE, { descendants: true }]\r\n            }], resizeElem: [{\r\n                type: ViewChild,\r\n                args: ['resizeElem', { static: true, read: ElementRef }]\r\n            }], minW: [{\r\n                type: Input\r\n            }], minH: [{\r\n                type: Input\r\n            }], maxW: [{\r\n                type: Input\r\n            }], maxH: [{\r\n                type: Input\r\n            }], transition: [{\r\n                type: Input\r\n            }], id: [{\r\n                type: Input\r\n            }], dragStartThreshold: [{\r\n                type: Input\r\n            }], draggable: [{\r\n                type: Input\r\n            }], resizable: [{\r\n                type: Input\r\n            }] } });\n\n// tslint:disable\r\n/**\r\n * Client rect utilities.\r\n * This file is taken from Angular Material repository. This is the reason why the tslint is disabled on this case.\r\n * Don't enable it until some custom change is done on this file.\r\n */\r\n/** Gets a mutable version of an element's bounding `ClientRect`. */\r\nfunction getMutableClientRect(element) {\r\n    const { top, right, bottom, left, width, height, x, y, toJSON } = element.getBoundingClientRect();\r\n    // We need to clone the `clientRect` here, because all the values on it are readonly\r\n    // and we need to be able to update them. Also we can't use a spread here, because\r\n    // the values on a `ClientRect` aren't own properties. See:\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\r\n    return { top, right, bottom, left, width, height, x, y, toJSON };\r\n}\r\n/**\r\n * Checks whether some coordinates are within a `ClientRect`.\r\n * @param clientRect ClientRect that is being checked.\r\n * @param x Coordinates along the X axis.\r\n * @param y Coordinates along the Y axis.\r\n */\r\n// export function isInsideClientRect(clientRect: ClientRect, x: number, y: number) {\r\n//   const {top, bottom, left, right} = clientRect;\r\n//   return y >= top && y <= bottom && x >= left && x <= right;\r\n// }\r\n/**\r\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\r\n * @param clientRect `ClientRect` that should be updated.\r\n * @param top Amount to add to the `top` position.\r\n * @param left Amount to add to the `left` position.\r\n */\r\n// export function adjustClientRect(clientRect: ClientRect, top: number, left: number) {\r\n//   clientRect.top += top;\r\n//   clientRect.bottom = clientRect.top + clientRect.height;\r\n//   clientRect.left += left;\r\n//   clientRect.right = clientRect.left + clientRect.width;\r\n// }\r\n/**\r\n * Checks whether the pointer coordinates are close to a ClientRect.\r\n * @param rect ClientRect to check against.\r\n * @param threshold Threshold around the ClientRect.\r\n * @param pointerX Coordinates along the X axis.\r\n * @param pointerY Coordinates along the Y axis.\r\n */\r\n// export function isPointerNearClientRect(rect: ClientRect,\r\n//                                         threshold: number,\r\n//                                         pointerX: number,\r\n//                                         pointerY: number): boolean {\r\n//   const {top, right, bottom, left, width, height} = rect;\r\n//   const xThreshold = width * threshold;\r\n//   const yThreshold = height * threshold;\r\n//   return pointerY > top - yThreshold && pointerY < bottom + yThreshold &&\r\n//          pointerX > left - xThreshold && pointerX < right + xThreshold;\r\n// }\n\n/**\r\n * Proximity, as a ratio to width/height at which to start auto-scrolling.\r\n * The value comes from trying it out manually until it feels right.\r\n */\r\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\r\n/**\r\n * Increments the vertical scroll position of a node.\r\n * @param node Node whose scroll position should change.\r\n * @param amount Amount of pixels that the `node` should be scrolled.\r\n */\r\nfunction incrementVerticalScroll(node, amount) {\r\n    if (node === window) {\r\n        node.scrollBy(0, amount);\r\n    }\r\n    else {\r\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\r\n        node.scrollTop += amount;\r\n    }\r\n}\r\n/**\r\n * Increments the horizontal scroll position of a node.\r\n * @param node Node whose scroll position should change.\r\n * @param amount Amount of pixels that the `node` should be scrolled.\r\n */\r\nfunction incrementHorizontalScroll(node, amount) {\r\n    if (node === window) {\r\n        node.scrollBy(amount, 0);\r\n    }\r\n    else {\r\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\r\n        node.scrollLeft += amount;\r\n    }\r\n}\r\n/**\r\n * Gets whether the vertical auto-scroll direction of a node.\r\n * @param clientRect Dimensions of the node.\r\n * @param pointerY Position of the user's pointer along the y axis.\r\n */\r\nfunction getVerticalScrollDirection(clientRect, pointerY) {\r\n    const { top, bottom, height } = clientRect;\r\n    const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\r\n    if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\r\n        return 1 /* UP */;\r\n    }\r\n    else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\r\n        return 2 /* DOWN */;\r\n    }\r\n    return 0 /* NONE */;\r\n}\r\n/**\r\n * Gets whether the horizontal auto-scroll direction of a node.\r\n * @param clientRect Dimensions of the node.\r\n * @param pointerX Position of the user's pointer along the x axis.\r\n */\r\nfunction getHorizontalScrollDirection(clientRect, pointerX) {\r\n    const { left, right, width } = clientRect;\r\n    const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\r\n    if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\r\n        return 1 /* LEFT */;\r\n    }\r\n    else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\r\n        return 2 /* RIGHT */;\r\n    }\r\n    return 0 /* NONE */;\r\n}\r\n/**\r\n * Returns an observable that schedules a loop and apply scroll on the scrollNode into the specified direction/s.\r\n * This observable doesn't emit, it just performs the 'scroll' side effect.\r\n * @param scrollNode, node where the scroll would be applied.\r\n * @param verticalScrollDirection, vertical direction of the scroll.\r\n * @param horizontalScrollDirection, horizontal direction of the scroll.\r\n * @param scrollStep, scroll step in CSS pixels that would be applied in every loop.\r\n */\r\nfunction scrollToDirectionInterval$(scrollNode, verticalScrollDirection, horizontalScrollDirection, scrollStep = 2) {\r\n    return interval(0, animationFrameScheduler)\r\n        .pipe(tap(() => {\r\n        if (verticalScrollDirection === 1 /* UP */) {\r\n            incrementVerticalScroll(scrollNode, -scrollStep);\r\n        }\r\n        else if (verticalScrollDirection === 2 /* DOWN */) {\r\n            incrementVerticalScroll(scrollNode, scrollStep);\r\n        }\r\n        if (horizontalScrollDirection === 1 /* LEFT */) {\r\n            incrementHorizontalScroll(scrollNode, -scrollStep);\r\n        }\r\n        else if (horizontalScrollDirection === 2 /* RIGHT */) {\r\n            incrementHorizontalScroll(scrollNode, scrollStep);\r\n        }\r\n    }), ktdNoEmit());\r\n}\r\n/**\r\n * Given a source$ observable with pointer location, scroll the scrollNode if the pointer is near to it.\r\n * This observable doesn't emit, it just performs a 'scroll' side effect.\r\n * @param scrollableParent, parent node in which the scroll would be performed.\r\n * @param options, configuration options.\r\n */\r\nfunction ktdScrollIfNearElementClientRect$(scrollableParent, options) {\r\n    let scrollNode;\r\n    let scrollableParentClientRect;\r\n    let scrollableParentScrollWidth;\r\n    if (scrollableParent === document) {\r\n        scrollNode = document.defaultView;\r\n        const { width, height } = getViewportSize();\r\n        scrollableParentClientRect = { width, height, top: 0, right: width, bottom: height, left: 0, x: 0, y: 0, toJSON: () => null };\r\n        scrollableParentScrollWidth = getDocumentScrollWidth();\r\n    }\r\n    else {\r\n        scrollNode = scrollableParent;\r\n        scrollableParentClientRect = getMutableClientRect(scrollableParent);\r\n        scrollableParentScrollWidth = scrollableParent.scrollWidth;\r\n    }\r\n    /**\r\n     * IMPORTANT: By design, only let scroll horizontal if the scrollable parent has explicitly an scroll horizontal.\r\n     * This layout solution is not designed in mind to have any scroll horizontal, but exceptionally we allow it in this\r\n     * specific use case.\r\n     */\r\n    options = options || {};\r\n    if (options.disableHorizontal == null && scrollableParentScrollWidth <= scrollableParentClientRect.width) {\r\n        options.disableHorizontal = true;\r\n    }\r\n    return (source$) => source$.pipe(map(({ pointerX, pointerY }) => {\r\n        let verticalScrollDirection = getVerticalScrollDirection(scrollableParentClientRect, pointerY);\r\n        let horizontalScrollDirection = getHorizontalScrollDirection(scrollableParentClientRect, pointerX);\r\n        // Check if scroll directions are disabled.\r\n        if (options?.disableVertical) {\r\n            verticalScrollDirection = 0 /* NONE */;\r\n        }\r\n        if (options?.disableHorizontal) {\r\n            horizontalScrollDirection = 0 /* NONE */;\r\n        }\r\n        return { verticalScrollDirection, horizontalScrollDirection };\r\n    }), distinctUntilChanged((prev, actual) => {\r\n        return prev.verticalScrollDirection === actual.verticalScrollDirection\r\n            && prev.horizontalScrollDirection === actual.horizontalScrollDirection;\r\n    }), switchMap(({ verticalScrollDirection, horizontalScrollDirection }) => {\r\n        if (verticalScrollDirection || horizontalScrollDirection) {\r\n            return scrollToDirectionInterval$(scrollNode, verticalScrollDirection, horizontalScrollDirection, options?.scrollStep);\r\n        }\r\n        else {\r\n            return NEVER;\r\n        }\r\n    }));\r\n}\r\n/**\r\n * Emits on EVERY scroll event and returns the accumulated scroll offset relative to the initial scroll position.\r\n * @param scrollableParent, node in which scroll events would be listened.\r\n */\r\nfunction ktdGetScrollTotalRelativeDifference$(scrollableParent) {\r\n    let scrollInitialPosition;\r\n    // Calculate initial scroll position\r\n    if (scrollableParent === document) {\r\n        scrollInitialPosition = getViewportScrollPosition();\r\n    }\r\n    else {\r\n        scrollInitialPosition = {\r\n            top: scrollableParent.scrollTop,\r\n            left: scrollableParent.scrollLeft\r\n        };\r\n    }\r\n    return fromEvent(scrollableParent, 'scroll', ktdNormalizePassiveListenerOptions({ capture: true })).pipe(map(() => {\r\n        let newTop;\r\n        let newLeft;\r\n        if (scrollableParent === document) {\r\n            const viewportScrollPosition = getViewportScrollPosition();\r\n            newTop = viewportScrollPosition.top;\r\n            newLeft = viewportScrollPosition.left;\r\n        }\r\n        else {\r\n            newTop = scrollableParent.scrollTop;\r\n            newLeft = scrollableParent.scrollLeft;\r\n        }\r\n        const topDifference = scrollInitialPosition.top - newTop;\r\n        const leftDifference = scrollInitialPosition.left - newLeft;\r\n        return { top: topDifference, left: leftDifference };\r\n    }));\r\n}\r\n/** Returns the viewport's width and height. */\r\nfunction getViewportSize() {\r\n    const _window = document.defaultView || window;\r\n    return {\r\n        width: _window.innerWidth,\r\n        height: _window.innerHeight\r\n    };\r\n}\r\n/** Gets a ClientRect for the viewport's bounds. */\r\n// function getViewportRect(): ClientRect {\r\n//     // Use the document element's bounding rect rather than the window scroll properties\r\n//     // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\r\n//     // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\r\n//     // conceptual viewports. Under most circumstances these viewports are equivalent, but they\r\n//     // can disagree when the page is pinch-zoomed (on devices that support touch).\r\n//     // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\r\n//     // We use the documentElement instead of the body because, by default (without a css reset)\r\n//     // browsers typically give the document body an 8px margin, which is not included in\r\n//     // getBoundingClientRect().\r\n//     const scrollPosition = getViewportScrollPosition();\r\n//     const {width, height} = getViewportSize();\r\n//     return {\r\n//         top: scrollPosition.top,\r\n//         left: scrollPosition.left,\r\n//         bottom: scrollPosition.top + height,\r\n//         right: scrollPosition.left + width,\r\n//         height,\r\n//         width,\r\n//     };\r\n// }\r\n/** Gets the (top, left) scroll position of the viewport. */\r\nfunction getViewportScrollPosition() {\r\n    // The top-left-corner of the viewport is determined by the scroll position of the document\r\n    // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\r\n    // whether `document.body` or `document.documentElement` is the scrolled element, so reading\r\n    // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\r\n    // `document.documentElement` works consistently, where the `top` and `left` values will\r\n    // equal negative the scroll position.\r\n    const windowRef = document.defaultView || window;\r\n    const documentElement = document.documentElement;\r\n    const documentRect = documentElement.getBoundingClientRect();\r\n    const top = -documentRect.top || document.body.scrollTop || windowRef.scrollY ||\r\n        documentElement.scrollTop || 0;\r\n    const left = -documentRect.left || document.body.scrollLeft || windowRef.scrollX ||\r\n        documentElement.scrollLeft || 0;\r\n    return { top, left };\r\n}\r\n/** Returns the document scroll width */\r\nfunction getDocumentScrollWidth() {\r\n    return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\r\n}\n\nfunction getDragResizeEventData(gridItem, layout) {\r\n    return {\r\n        layout,\r\n        layoutItem: layout.find((item) => item.id === gridItem.id),\r\n        gridItemRef: gridItem\r\n    };\r\n}\r\nfunction layoutToRenderItems(config, width, height) {\r\n    const { cols, rowHeight, layout } = config;\r\n    const renderItems = {};\r\n    for (const item of layout) {\r\n        renderItems[item.id] = {\r\n            id: item.id,\r\n            top: item.y === 0 ? 0 : item.y * rowHeight,\r\n            left: item.x * (width / cols),\r\n            width: item.w * (width / cols),\r\n            height: item.h * rowHeight\r\n        };\r\n    }\r\n    return renderItems;\r\n}\r\nfunction getGridHeight(layout, rowHeight) {\r\n    return layout.reduce((acc, cur) => Math.max(acc, (cur.y + cur.h) * rowHeight), 0);\r\n}\r\n// tslint:disable-next-line\r\nfunction parseRenderItemToPixels(renderItem) {\r\n    return {\r\n        id: renderItem.id,\r\n        top: `${renderItem.top}px`,\r\n        left: `${renderItem.left}px`,\r\n        width: `${renderItem.width}px`,\r\n        height: `${renderItem.height}px`\r\n    };\r\n}\r\n// tslint:disable-next-line:ktd-prefix-code\r\nfunction __gridItemGetRenderDataFactoryFunc(gridCmp) {\r\n    // tslint:disable-next-line:only-arrow-functions\r\n    return function (id) {\r\n        return parseRenderItemToPixels(gridCmp.getItemRenderData(id));\r\n    };\r\n}\r\nfunction ktdGridItemGetRenderDataFactoryFunc(gridCmp) {\r\n    // Workaround explained: https://github.com/ng-packagr/ng-packagr/issues/696#issuecomment-387114613\r\n    const resultFunc = __gridItemGetRenderDataFactoryFunc(gridCmp);\r\n    return resultFunc;\r\n}\r\nclass KtdGridComponent {\r\n    constructor(gridService, elementRef, renderer, ngZone) {\r\n        this.gridService = gridService;\r\n        this.elementRef = elementRef;\r\n        this.renderer = renderer;\r\n        this.ngZone = ngZone;\r\n        /** Emits when layout change */\r\n        this.layoutUpdated = new EventEmitter();\r\n        /** Emits when drag starts */\r\n        this.dragStarted = new EventEmitter();\r\n        /** Emits when resize starts */\r\n        this.resizeStarted = new EventEmitter();\r\n        /** Emits when drag ends */\r\n        this.dragEnded = new EventEmitter();\r\n        /** Emits when resize ends */\r\n        this.resizeEnded = new EventEmitter();\r\n        /**\r\n         * Parent element that contains the scroll. If an string is provided it would search that element by id on the dom.\r\n         * If no data provided or null autoscroll is not performed.\r\n         */\r\n        this.scrollableParent = null;\r\n        this._compactOnPropsChange = true;\r\n        this._preventCollision = false;\r\n        this._scrollSpeed = 2;\r\n        this._compactType = 'vertical';\r\n        this._rowHeight = 100;\r\n        this._cols = 6;\r\n    }\r\n    /** Whether or not to update the internal layout when some dependent property change. */\r\n    get compactOnPropsChange() { return this._compactOnPropsChange; }\r\n    set compactOnPropsChange(value) {\r\n        this._compactOnPropsChange = coerceBooleanProperty(value);\r\n    }\r\n    /** If true, grid items won't change position when being dragged over. Handy when using no compaction */\r\n    get preventCollision() { return this._preventCollision; }\r\n    set preventCollision(value) {\r\n        this._preventCollision = coerceBooleanProperty(value);\r\n    }\r\n    /** Number of CSS pixels that would be scrolled on each 'tick' when auto scroll is performed. */\r\n    get scrollSpeed() { return this._scrollSpeed; }\r\n    set scrollSpeed(value) {\r\n        this._scrollSpeed = coerceNumberProperty(value, 2);\r\n    }\r\n    /** Type of compaction that will be applied to the layout (vertical, horizontal or free). Defaults to 'vertical' */\r\n    get compactType() {\r\n        return this._compactType;\r\n    }\r\n    set compactType(val) {\r\n        this._compactType = val;\r\n    }\r\n    /** Row height in css pixels */\r\n    get rowHeight() { return this._rowHeight; }\r\n    set rowHeight(val) {\r\n        this._rowHeight = Math.max(1, Math.round(coerceNumberProperty(val)));\r\n    }\r\n    /** Number of columns  */\r\n    get cols() { return this._cols; }\r\n    set cols(val) {\r\n        this._cols = Math.max(1, Math.round(coerceNumberProperty(val)));\r\n    }\r\n    /** Layout of the grid. Array of all the grid items with its 'id' and position on the grid. */\r\n    get layout() { return this._layout; }\r\n    set layout(layout) {\r\n        /**\r\n         * Enhancement:\r\n         * Only set layout if it's reference has changed and use a boolean to track whenever recalculate the layout on ngOnChanges.\r\n         *\r\n         * Why:\r\n         * The normal use of this lib is having the variable layout in the outer component or in a store, assigning it whenever it changes and\r\n         * binded in the component with it's input [layout]. In this scenario, we would always calculate one unnecessary change on the layout when\r\n         * it is re-binded on the input.\r\n         */\r\n        this._layout = layout;\r\n    }\r\n    get config() {\r\n        return {\r\n            cols: this.cols,\r\n            rowHeight: this.rowHeight,\r\n            layout: this.layout,\r\n            preventCollision: this.preventCollision,\r\n        };\r\n    }\r\n    ngOnChanges(changes) {\r\n        let needsCompactLayout = false;\r\n        let needsRecalculateRenderData = false;\r\n        // TODO: Does fist change need to be compacted by default?\r\n        // Compact layout whenever some dependent prop changes.\r\n        if (changes.compactType || changes.cols || changes.layout) {\r\n            needsCompactLayout = true;\r\n        }\r\n        // Check if wee need to recalculate rendering data.\r\n        if (needsCompactLayout || changes.rowHeight) {\r\n            needsRecalculateRenderData = true;\r\n        }\r\n        // Only compact layout if lib user has provided it. Lib users that want to save/store always the same layout  as it is represented (compacted)\r\n        // can use KtdCompactGrid utility and pre-compact the layout. This is the recommended behaviour for always having a the same layout on this component\r\n        // and the ones that uses it.\r\n        if (needsCompactLayout && this.compactOnPropsChange) {\r\n            this.compactLayout();\r\n        }\r\n        if (needsRecalculateRenderData) {\r\n            this.calculateRenderData();\r\n        }\r\n    }\r\n    ngAfterContentInit() {\r\n        this.initSubscriptions();\r\n    }\r\n    ngAfterContentChecked() {\r\n        this.render();\r\n    }\r\n    resize() {\r\n        this.calculateRenderData();\r\n        this.render();\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscriptions.forEach(sub => sub.unsubscribe());\r\n    }\r\n    compactLayout() {\r\n        this.layout = compact(this.layout, this.compactType, this.cols);\r\n    }\r\n    getItemsRenderData() {\r\n        return { ...this._gridItemsRenderData };\r\n    }\r\n    getItemRenderData(itemId) {\r\n        return this._gridItemsRenderData[itemId];\r\n    }\r\n    calculateRenderData() {\r\n        const clientRect = this.elementRef.nativeElement.getBoundingClientRect();\r\n        this._gridItemsRenderData = layoutToRenderItems(this.config, clientRect.width, clientRect.height);\r\n        this._height = getGridHeight(this.layout, this.rowHeight);\r\n    }\r\n    render() {\r\n        this.renderer.setStyle(this.elementRef.nativeElement, 'height', `${this._height}px`);\r\n        this.updateGridItemsStyles();\r\n    }\r\n    updateGridItemsStyles() {\r\n        this._gridItems.forEach(item => {\r\n            const gridItemRenderData = this._gridItemsRenderData[item.id];\r\n            if (gridItemRenderData == null) {\r\n                console.error(`Couldn\\'t find the specified grid item for the id: ${item.id}`);\r\n            }\r\n            else {\r\n                item.setStyles(parseRenderItemToPixels(gridItemRenderData));\r\n            }\r\n        });\r\n    }\r\n    initSubscriptions() {\r\n        this.subscriptions = [\r\n            this._gridItems.changes.pipe(startWith(this._gridItems), switchMap((gridItems) => {\r\n                return merge(...gridItems.map((gridItem) => gridItem.dragStart$.pipe(map((event) => ({ event, gridItem, type: 'drag' })))), ...gridItems.map((gridItem) => gridItem.resizeStart$.pipe(map((event) => ({ event, gridItem, type: 'resize' }))))).pipe(exhaustMap(({ event, gridItem, type }) => {\r\n                    // Emit drag or resize start events. Ensure that is start event is inside the zone.\r\n                    this.ngZone.run(() => (type === 'drag' ? this.dragStarted : this.resizeStarted).emit(getDragResizeEventData(gridItem, this.layout)));\r\n                    // Get the correct newStateFunc depending on if we are dragging or resizing\r\n                    const calcNewStateFunc = type === 'drag' ? ktdGridItemDragging : ktdGridItemResizing;\r\n                    // Perform drag sequence\r\n                    return this.performDragSequence$(gridItem, event, (gridItemId, config, compactionType, draggingData) => calcNewStateFunc(gridItem, config, compactionType, draggingData)).pipe(map((layout) => ({ layout, gridItem, type })));\r\n                }));\r\n            })).subscribe(({ layout, gridItem, type }) => {\r\n                this.layout = layout;\r\n                // Calculate new rendering data given the new layout.\r\n                this.calculateRenderData();\r\n                // Emit drag or resize end events.\r\n                (type === 'drag' ? this.dragEnded : this.resizeEnded).emit(getDragResizeEventData(gridItem, layout));\r\n                // Notify that the layout has been updated.\r\n                this.layoutUpdated.emit(layout);\r\n            })\r\n        ];\r\n    }\r\n    /**\r\n     * Perform a general grid drag action, from start to end. A general grid drag action basically includes creating the placeholder element and adding\r\n     * some class animations. calcNewStateFunc needs to be provided in order to calculate the new state of the layout.\r\n     * @param gridItem that is been dragged\r\n     * @param pointerDownEvent event (mousedown or touchdown) where the user initiated the drag\r\n     * @param calcNewStateFunc function that return the new layout state and the drag element position\r\n     */\r\n    performDragSequence$(gridItem, pointerDownEvent, calcNewStateFunc) {\r\n        return new Observable((observer) => {\r\n            // Retrieve grid (parent) and gridItem (draggedElem) client rects.\r\n            const gridElemClientRect = getMutableClientRect(this.elementRef.nativeElement);\r\n            const dragElemClientRect = getMutableClientRect(gridItem.elementRef.nativeElement);\r\n            const scrollableParent = typeof this.scrollableParent === 'string' ? document.getElementById(this.scrollableParent) : this.scrollableParent;\r\n            this.renderer.addClass(gridItem.elementRef.nativeElement, 'no-transitions');\r\n            this.renderer.addClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging');\r\n            // Create placeholder element. This element would represent the position where the dragged/resized element would be if the action ends\r\n            const placeholderElement = this.renderer.createElement('div');\r\n            placeholderElement.style.width = `${dragElemClientRect.width}px`;\r\n            placeholderElement.style.height = `${dragElemClientRect.height}px`;\r\n            placeholderElement.style.transform = `translateX(${dragElemClientRect.left - gridElemClientRect.left}px) translateY(${dragElemClientRect.top - gridElemClientRect.top}px)`;\r\n            this.renderer.addClass(placeholderElement, 'ktd-grid-item-placeholder');\r\n            this.renderer.appendChild(this.elementRef.nativeElement, placeholderElement);\r\n            let newLayout;\r\n            // TODO (enhancement): consider move this 'side effect' observable inside the main drag loop.\r\n            //  - Pros are that we would not repeat subscriptions and takeUntil would shut down observables at the same time.\r\n            //  - Cons are that moving this functionality as a side effect inside the main drag loop would be confusing.\r\n            const scrollSubscription = this.ngZone.runOutsideAngular(() => (!scrollableParent ? NEVER : this.gridService.mouseOrTouchMove$(document).pipe(map((event) => ({\r\n                pointerX: ktdPointerClientX(event),\r\n                pointerY: ktdPointerClientY(event)\r\n            })), ktdScrollIfNearElementClientRect$(scrollableParent, { scrollStep: this.scrollSpeed }))).pipe(takeUntil(ktdMouseOrTouchEnd(document))).subscribe());\r\n            /**\r\n             * Main subscription, it listens for 'pointer move' and 'scroll' events and recalculates the layout on each emission\r\n             */\r\n            const subscription = this.ngZone.runOutsideAngular(() => merge(combineLatest([\r\n                this.gridService.mouseOrTouchMove$(document),\r\n                ...(!scrollableParent ? [of({ top: 0, left: 0 })] : [\r\n                    ktdGetScrollTotalRelativeDifference$(scrollableParent).pipe(startWith({ top: 0, left: 0 }) // Force first emission to allow CombineLatest to emit even no scroll event has occurred\r\n                    )\r\n                ])\r\n            ])).pipe(takeUntil(ktdMouseOrTouchEnd(document))).subscribe(([pointerDragEvent, scrollDifference]) => {\r\n                pointerDragEvent.preventDefault();\r\n                /**\r\n                 * Set the new layout to be the layout in which the calcNewStateFunc would be executed.\r\n                 * NOTE: using the mutated layout is the way to go by 'react-grid-layout' utils. If we don't use the previous layout,\r\n                 * some utilities from 'react-grid-layout' would not work as expected.\r\n                 */\r\n                const currentLayout = newLayout || this.layout;\r\n                const { layout, draggedItemPos } = calcNewStateFunc(gridItem, {\r\n                    layout: currentLayout,\r\n                    rowHeight: this.rowHeight,\r\n                    cols: this.cols,\r\n                    preventCollision: this.preventCollision\r\n                }, this.compactType, {\r\n                    pointerDownEvent,\r\n                    pointerDragEvent,\r\n                    gridElemClientRect,\r\n                    dragElemClientRect,\r\n                    scrollDifference\r\n                });\r\n                newLayout = layout;\r\n                this._height = getGridHeight(newLayout, this.rowHeight);\r\n                this._gridItemsRenderData = layoutToRenderItems({\r\n                    cols: this.cols,\r\n                    rowHeight: this.rowHeight,\r\n                    layout: newLayout,\r\n                    preventCollision: this.preventCollision,\r\n                }, gridElemClientRect.width, gridElemClientRect.height);\r\n                const placeholderStyles = parseRenderItemToPixels(this._gridItemsRenderData[gridItem.id]);\r\n                // Put the real final position to the placeholder element\r\n                placeholderElement.style.width = placeholderStyles.width;\r\n                placeholderElement.style.height = placeholderStyles.height;\r\n                placeholderElement.style.transform = `translateX(${placeholderStyles.left}) translateY(${placeholderStyles.top})`;\r\n                // modify the position of the dragged item to be the once we want (for example the mouse position or whatever)\r\n                this._gridItemsRenderData[gridItem.id] = {\r\n                    ...draggedItemPos,\r\n                    id: this._gridItemsRenderData[gridItem.id].id\r\n                };\r\n                this.render();\r\n            }, (error) => observer.error(error), () => {\r\n                this.ngZone.run(() => {\r\n                    // Remove drag classes\r\n                    this.renderer.removeClass(gridItem.elementRef.nativeElement, 'no-transitions');\r\n                    this.renderer.removeClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging');\r\n                    // Remove placeholder element from the dom\r\n                    // NOTE: If we don't put the removeChild inside the zone it would not work... This may be a bug from angular or maybe is the intended behaviour, although strange.\r\n                    // It should work since AFAIK this action should not be done in a CD cycle.\r\n                    this.renderer.removeChild(this.elementRef.nativeElement, placeholderElement);\r\n                    if (newLayout) {\r\n                        // TODO: newLayout should already be pruned. If not, it should have type Layout, not KtdGridLayout as it is now.\r\n                        // Prune react-grid-layout compact extra properties.\r\n                        observer.next(newLayout.map(item => ({\r\n                            id: item.id,\r\n                            x: item.x,\r\n                            y: item.y,\r\n                            w: item.w,\r\n                            h: item.h,\r\n                            minW: item.minW,\r\n                            minH: item.minH,\r\n                            maxW: item.maxW,\r\n                            maxH: item.maxH,\r\n                        })));\r\n                    }\r\n                    else {\r\n                        // TODO: Need we really to emit if there is no layout change but drag started and ended?\r\n                        observer.next(this.layout);\r\n                    }\r\n                    observer.complete();\r\n                });\r\n            }));\r\n            return () => {\r\n                scrollSubscription.unsubscribe();\r\n                subscription.unsubscribe();\r\n            };\r\n        });\r\n    }\r\n}\r\nKtdGridComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridComponent, deps: [{ token: KtdGridService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });\r\nKtdGridComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.2.7\", type: KtdGridComponent, selector: \"ktd-grid\", inputs: { scrollableParent: \"scrollableParent\", compactOnPropsChange: \"compactOnPropsChange\", preventCollision: \"preventCollision\", scrollSpeed: \"scrollSpeed\", compactType: \"compactType\", rowHeight: \"rowHeight\", cols: \"cols\", layout: \"layout\" }, outputs: { layoutUpdated: \"layoutUpdated\", dragStarted: \"dragStarted\", resizeStarted: \"resizeStarted\", dragEnded: \"dragEnded\", resizeEnded: \"resizeEnded\" }, providers: [\r\n        {\r\n            provide: GRID_ITEM_GET_RENDER_DATA_TOKEN,\r\n            useFactory: ktdGridItemGetRenderDataFactoryFunc,\r\n            deps: [KtdGridComponent]\r\n        }\r\n    ], queries: [{ propertyName: \"_gridItems\", predicate: KtdGridItemComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: \"<ng-content></ng-content>\\n\", styles: [\"ktd-grid{display:block;position:relative;width:100%}ktd-grid ktd-grid-item.ktd-grid-item-dragging{z-index:1000}ktd-grid ktd-grid-item.no-transitions{transition:none!important}ktd-grid .ktd-grid-item-placeholder{position:absolute;background-color:#8b0000;opacity:.6;z-index:0;transition-property:transform;transition:all .15s ease}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridComponent, decorators: [{\r\n            type: Component,\r\n            args: [{ selector: 'ktd-grid', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, providers: [\r\n                        {\r\n                            provide: GRID_ITEM_GET_RENDER_DATA_TOKEN,\r\n                            useFactory: ktdGridItemGetRenderDataFactoryFunc,\r\n                            deps: [KtdGridComponent]\r\n                        }\r\n                    ], template: \"<ng-content></ng-content>\\n\", styles: [\"ktd-grid{display:block;position:relative;width:100%}ktd-grid ktd-grid-item.ktd-grid-item-dragging{z-index:1000}ktd-grid ktd-grid-item.no-transitions{transition:none!important}ktd-grid .ktd-grid-item-placeholder{position:absolute;background-color:#8b0000;opacity:.6;z-index:0;transition-property:transform;transition:all .15s ease}\\n\"] }]\r\n        }], ctorParameters: function () { return [{ type: KtdGridService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }]; }, propDecorators: { _gridItems: [{\r\n                type: ContentChildren,\r\n                args: [KtdGridItemComponent, { descendants: true }]\r\n            }], layoutUpdated: [{\r\n                type: Output\r\n            }], dragStarted: [{\r\n                type: Output\r\n            }], resizeStarted: [{\r\n                type: Output\r\n            }], dragEnded: [{\r\n                type: Output\r\n            }], resizeEnded: [{\r\n                type: Output\r\n            }], scrollableParent: [{\r\n                type: Input\r\n            }], compactOnPropsChange: [{\r\n                type: Input\r\n            }], preventCollision: [{\r\n                type: Input\r\n            }], scrollSpeed: [{\r\n                type: Input\r\n            }], compactType: [{\r\n                type: Input\r\n            }], rowHeight: [{\r\n                type: Input\r\n            }], cols: [{\r\n                type: Input\r\n            }], layout: [{\r\n                type: Input\r\n            }] } });\n\nclass KtdGridModule {\r\n}\r\nKtdGridModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nKtdGridModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridModule, declarations: [KtdGridComponent,\r\n        KtdGridItemComponent,\r\n        KtdGridDragHandle,\r\n        KtdGridResizeHandle], imports: [CommonModule], exports: [KtdGridComponent,\r\n        KtdGridItemComponent,\r\n        KtdGridDragHandle,\r\n        KtdGridResizeHandle] });\r\nKtdGridModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridModule, providers: [\r\n        KtdGridService\r\n    ], imports: [[\r\n            CommonModule\r\n        ]] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    declarations: [\r\n                        KtdGridComponent,\r\n                        KtdGridItemComponent,\r\n                        KtdGridDragHandle,\r\n                        KtdGridResizeHandle\r\n                    ],\r\n                    exports: [\r\n                        KtdGridComponent,\r\n                        KtdGridItemComponent,\r\n                        KtdGridDragHandle,\r\n                        KtdGridResizeHandle\r\n                    ],\r\n                    providers: [\r\n                        KtdGridService\r\n                    ],\r\n                    imports: [\r\n                        CommonModule\r\n                    ]\r\n                }]\r\n        }] });\n\n/*\r\n * Public API Surface of grid\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { GRID_ITEM_GET_RENDER_DATA_TOKEN, KTD_GRID_DRAG_HANDLE, KTD_GRID_RESIZE_HANDLE, KtdGridComponent, KtdGridDragHandle, KtdGridItemComponent, KtdGridModule, KtdGridResizeHandle, __gridItemGetRenderDataFactoryFunc, ktdGridCompact, ktdGridItemGetRenderDataFactoryFunc, ktdTrackById, parseRenderItemToPixels };\n//# sourceMappingURL=angular-grid-layout-ngx13.mjs.map\n","map":{"version":3,"file":"angular-grid-layout-ngx13.mjs","sources":["../../../projects/angular-grid-layout/src/lib/utils/react-grid-layout.utils.ts","../../../projects/angular-grid-layout/src/lib/utils/passive-listeners.ts","../../../projects/angular-grid-layout/src/lib/utils/pointer.utils.ts","../../../projects/angular-grid-layout/src/lib/utils/grid.utils.ts","../../../projects/angular-grid-layout/src/lib/directives/drag-handle.ts","../../../projects/angular-grid-layout/src/lib/directives/resize-handle.ts","../../../projects/angular-grid-layout/src/lib/grid.definitions.ts","../../../projects/angular-grid-layout/src/lib/utils/operators.ts","../../../projects/angular-grid-layout/src/lib/coercion/boolean-property.ts","../../../projects/angular-grid-layout/src/lib/coercion/number-property.ts","../../../projects/angular-grid-layout/src/lib/grid.service.ts","../../../projects/angular-grid-layout/src/lib/grid-item/grid-item.component.ts","../../../projects/angular-grid-layout/src/lib/grid-item/grid-item.component.html","../../../projects/angular-grid-layout/src/lib/utils/client-rect.ts","../../../projects/angular-grid-layout/src/lib/utils/scroll.ts","../../../projects/angular-grid-layout/src/lib/grid.component.ts","../../../projects/angular-grid-layout/src/lib/grid.component.html","../../../projects/angular-grid-layout/src/lib/grid.module.ts","../../../projects/angular-grid-layout/src/public-api.ts","../../../projects/angular-grid-layout/src/angular-grid-layout-ngx13.ts"],"sourcesContent":["\n/**\n * IMPORTANT:\n * This utils are taken from the project: https://github.com/STRML/react-grid-layout.\n * The code should be as less modified as possible for easy maintenance.\n */\n\n// Disable lint since we don't want to modify this code\n// tslint:disable\nexport type LayoutItem = {\n    w: number;\n    h: number;\n    x: number;\n    y: number;\n    id: string;\n    minW?: number;\n    minH?: number;\n    maxW?: number;\n    maxH?: number;\n    moved?: boolean;\n    static?: boolean;\n    isDraggable?: boolean | null | undefined;\n    isResizable?: boolean | null | undefined;\n};\nexport type Layout = Array<LayoutItem>;\nexport type Position = {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n};\nexport type ReactDraggableCallbackData = {\n    node: HTMLElement;\n    x?: number;\n    y?: number;\n    deltaX: number;\n    deltaY: number;\n    lastX?: number;\n    lastY?: number;\n};\n\nexport type PartialPosition = { left: number; top: number };\nexport type DroppingPosition = { x: number; y: number; e: Event };\nexport type Size = { width: number; height: number };\nexport type GridDragEvent = {\n    e: Event;\n    node: HTMLElement;\n    newPosition: PartialPosition;\n};\nexport type GridResizeEvent = { e: Event; node: HTMLElement; size: Size };\nexport type DragOverEvent = MouseEvent & {\n    nativeEvent: {\n        layerX: number;\n        layerY: number;\n        target: {\n            className: String;\n        };\n    };\n};\n\n//type REl = ReactElement<any>;\n//export type ReactChildren = ReactChildrenArray<REl>;\n\n// All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).\nexport type EventCallback = (\n    arg0: Layout,\n    oldItem: LayoutItem | null | undefined,\n    newItem: LayoutItem | null | undefined,\n    placeholder: LayoutItem | null | undefined,\n    arg4: Event,\n    arg5: HTMLElement | null | undefined,\n) => void;\nexport type CompactType = ('horizontal' | 'vertical') | null | undefined;\n\nconst DEBUG = false;\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nexport function bottom(layout: Layout): number {\n    let max = 0,\n        bottomY;\n    for (let i = 0, len = layout.length; i < len; i++) {\n        bottomY = layout[i].y + layout[i].h;\n        if (bottomY > max) {\n            max = bottomY;\n        }\n    }\n    return max;\n}\n\nexport function cloneLayout(layout: Layout): Layout {\n    const newLayout = Array(layout.length);\n    for (let i = 0, len = layout.length; i < len; i++) {\n        newLayout[i] = cloneLayoutItem(layout[i]);\n    }\n    return newLayout;\n}\n\n// Fast path to cloning, since this is monomorphic\n/** NOTE: This code has been modified from the original source */\nexport function cloneLayoutItem(layoutItem: LayoutItem): LayoutItem {\n    const clonedLayoutItem: LayoutItem = {\n        w: layoutItem.w,\n        h: layoutItem.h,\n        x: layoutItem.x,\n        y: layoutItem.y,\n        id: layoutItem.id,\n        moved: !!layoutItem.moved,\n        static: !!layoutItem.static,\n    };\n\n    if (layoutItem.minW !== undefined) { clonedLayoutItem.minW = layoutItem.minW;}\n    if (layoutItem.maxW !== undefined) { clonedLayoutItem.maxW = layoutItem.maxW;}\n    if (layoutItem.minH !== undefined) { clonedLayoutItem.minH = layoutItem.minH;}\n    if (layoutItem.maxH !== undefined) { clonedLayoutItem.maxH = layoutItem.maxH;}\n    // These can be null\n    if (layoutItem.isDraggable !== undefined) { clonedLayoutItem.isDraggable = layoutItem.isDraggable;}\n    if (layoutItem.isResizable !== undefined) { clonedLayoutItem.isResizable = layoutItem.isResizable;}\n\n    return clonedLayoutItem;\n}\n\n/**\n * Given two layoutitems, check if they collide.\n */\nexport function collides(l1: LayoutItem, l2: LayoutItem): boolean {\n    if (l1.id === l2.id) {\n        return false;\n    } // same element\n    if (l1.x + l1.w <= l2.x) {\n        return false;\n    } // l1 is left of l2\n    if (l1.x >= l2.x + l2.w) {\n        return false;\n    } // l1 is right of l2\n    if (l1.y + l1.h <= l2.y) {\n        return false;\n    } // l1 is above l2\n    if (l1.y >= l2.y + l2.h) {\n        return false;\n    } // l1 is below l2\n    return true; // boxes overlap\n}\n\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\nexport function compact(\n    layout: Layout,\n    compactType: CompactType,\n    cols: number,\n): Layout {\n    // Statics go in the compareWith array right away so items flow around them.\n    const compareWith = getStatics(layout);\n    // We go through the items by row and column.\n    const sorted = sortLayoutItems(layout, compactType);\n    // Holding for new items.\n    const out = Array(layout.length);\n\n    for (let i = 0, len = sorted.length; i < len; i++) {\n        let l = cloneLayoutItem(sorted[i]);\n\n        // Don't move static elements\n        if (!l.static) {\n            l = compactItem(compareWith, l, compactType, cols, sorted);\n\n            // Add to comparison array. We only collide with items before this one.\n            // Statics are already in this array.\n            compareWith.push(l);\n        }\n\n        // Add to output array to make sure they still come out in the right order.\n        out[layout.indexOf(sorted[i])] = l;\n\n        // Clear moved flag, if it exists.\n        l.moved = false;\n    }\n\n    return out;\n}\n\nconst heightWidth = {x: 'w', y: 'h'};\n\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\nfunction resolveCompactionCollision(\n    layout: Layout,\n    item: LayoutItem,\n    moveToCoord: number,\n    axis: 'x' | 'y',\n) {\n    const sizeProp = heightWidth[axis];\n    item[axis] += 1;\n    const itemIndex = layout\n        .map(layoutItem => {\n            return layoutItem.id;\n        })\n        .indexOf(item.id);\n\n    // Go through each item we collide with.\n    for (let i = itemIndex + 1; i < layout.length; i++) {\n        const otherItem = layout[i];\n        // Ignore static items\n        if (otherItem.static) {\n            continue;\n        }\n\n        // Optimization: we can break early if we know we're past this el\n        // We can do this b/c it's a sorted layout\n        if (otherItem.y > item.y + item.h) {\n            break;\n        }\n\n        if (collides(item, otherItem)) {\n            resolveCompactionCollision(\n                layout,\n                otherItem,\n                moveToCoord + item[sizeProp],\n                axis,\n            );\n        }\n    }\n\n    item[axis] = moveToCoord;\n}\n\n/**\n * Compact an item in the layout.\n */\nexport function compactItem(\n    compareWith: Layout,\n    l: LayoutItem,\n    compactType: CompactType,\n    cols: number,\n    fullLayout: Layout,\n): LayoutItem {\n    const compactV = compactType === 'vertical';\n    const compactH = compactType === 'horizontal';\n    if (compactV) {\n        // Bottom 'y' possible is the bottom of the layout.\n        // This allows you to do nice stuff like specify {y: Infinity}\n        // This is here because the layout must be sorted in order to get the correct bottom `y`.\n        l.y = Math.min(bottom(compareWith), l.y);\n        // Move the element up as far as it can go without colliding.\n        while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n            l.y--;\n        }\n    } else if (compactH) {\n        l.y = Math.min(bottom(compareWith), l.y);\n        // Move the element left as far as it can go without colliding.\n        while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n            l.x--;\n        }\n    }\n\n    // Move it down, and keep moving it down if it's colliding.\n    let collides;\n    while ((collides = getFirstCollision(compareWith, l))) {\n        if (compactH) {\n            resolveCompactionCollision(\n                fullLayout,\n                l,\n                collides.x + collides.w,\n                'x',\n            );\n        } else {\n            resolveCompactionCollision(\n                fullLayout,\n                l,\n                collides.y + collides.h,\n                'y',\n            );\n        }\n        // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n        if (compactH && l.x + l.w > cols) {\n            l.x = cols - l.w;\n            l.y++;\n        }\n    }\n    return l;\n}\n\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\nexport function correctBounds(layout: Layout, bounds: { cols: number }): Layout {\n    const collidesWith = getStatics(layout);\n    for (let i = 0, len = layout.length; i < len; i++) {\n        const l = layout[i];\n        // Overflows right\n        if (l.x + l.w > bounds.cols) {\n            l.x = bounds.cols - l.w;\n        }\n        // Overflows left\n        if (l.x < 0) {\n            l.x = 0;\n            l.w = bounds.cols;\n        }\n        if (!l.static) {\n            collidesWith.push(l);\n        } else {\n            // If this is static and collides with other statics, we must move it down.\n            // We have to do something nicer than just letting them overlap.\n            while (getFirstCollision(collidesWith, l)) {\n                l.y++;\n            }\n        }\n    }\n    return layout;\n}\n\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\nexport function getLayoutItem(\n    layout: Layout,\n    id: string,\n): LayoutItem | null | undefined {\n    for (let i = 0, len = layout.length; i < len; i++) {\n        if (layout[i].id === id) {\n            return layout[i];\n        }\n    }\n    return null;\n}\n\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\nexport function getFirstCollision(\n    layout: Layout,\n    layoutItem: LayoutItem,\n): LayoutItem | null | undefined {\n    for (let i = 0, len = layout.length; i < len; i++) {\n        if (collides(layout[i], layoutItem)) {\n            return layout[i];\n        }\n    }\n    return null;\n}\n\nexport function getAllCollisions(\n    layout: Layout,\n    layoutItem: LayoutItem,\n): Array<LayoutItem> {\n    return layout.filter(l => collides(l, layoutItem));\n}\n\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\nexport function getStatics(layout: Layout): Array<LayoutItem> {\n    return layout.filter(l => l.static);\n}\n\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\nexport function moveElement(\n    layout: Layout,\n    l: LayoutItem,\n    x: number | null | undefined,\n    y: number | null | undefined,\n    isUserAction: boolean | null | undefined,\n    preventCollision: boolean | null | undefined,\n    compactType: CompactType,\n    cols: number,\n): Layout {\n    // If this is static and not explicitly enabled as draggable,\n    // no move is possible, so we can short-circuit this immediately.\n    if (l.static && l.isDraggable !== true) {\n        return layout;\n    }\n\n    // Short-circuit if nothing to do.\n    if (l.y === y && l.x === x) {\n        return layout;\n    }\n\n    log(\n        `Moving element ${l.id} to [${String(x)},${String(y)}] from [${l.x},${\n            l.y\n        }]`,\n    );\n    const oldX = l.x;\n    const oldY = l.y;\n\n    // This is quite a bit faster than extending the object\n    if (typeof x === 'number') {\n        l.x = x;\n    }\n    if (typeof y === 'number') {\n        l.y = y;\n    }\n    l.moved = true;\n\n    // If this collides with anything, move it.\n    // When doing this comparison, we have to sort the items we compare with\n    // to ensure, in the case of multiple collisions, that we're getting the\n    // nearest collision.\n    let sorted = sortLayoutItems(layout, compactType);\n    const movingUp =\n        compactType === 'vertical' && typeof y === 'number'\n            ? oldY >= y\n            : compactType === 'horizontal' && typeof x === 'number'\n            ? oldX >= x\n            : false;\n    if (movingUp) {\n        sorted = sorted.reverse();\n    }\n    const collisions = getAllCollisions(sorted, l);\n\n    // There was a collision; abort\n    if (preventCollision && collisions.length) {\n        log(`Collision prevented on ${l.id}, reverting.`);\n        l.x = oldX;\n        l.y = oldY;\n        l.moved = false;\n        return layout;\n    }\n\n    // Move each item that collides away from this element.\n    for (let i = 0, len = collisions.length; i < len; i++) {\n        const collision = collisions[i];\n        log(\n            `Resolving collision between ${l.id} at [${l.x},${l.y}] and ${\n                collision.id\n            } at [${collision.x},${collision.y}]`,\n        );\n\n        // Short circuit so we can't infinite loop\n        if (collision.moved) {\n            continue;\n        }\n\n        // Don't move static items - we have to move *this* element away\n        if (collision.static) {\n            layout = moveElementAwayFromCollision(\n                layout,\n                collision,\n                l,\n                isUserAction,\n                compactType,\n                cols,\n            );\n        } else {\n            layout = moveElementAwayFromCollision(\n                layout,\n                l,\n                collision,\n                isUserAction,\n                compactType,\n                cols,\n            );\n        }\n    }\n\n    return layout;\n}\n\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\nexport function moveElementAwayFromCollision(\n    layout: Layout,\n    collidesWith: LayoutItem,\n    itemToMove: LayoutItem,\n    isUserAction: boolean | null | undefined,\n    compactType: CompactType,\n    cols: number,\n): Layout {\n    const compactH = compactType === 'horizontal';\n    // Compact vertically if not set to horizontal\n    const compactV = compactType !== 'horizontal';\n    const preventCollision = collidesWith.static; // we're already colliding (not for static items)\n\n    // If there is enough space above the collision to put this element, move it there.\n    // We only do this on the main collision as this can get funky in cascades and cause\n    // unwanted swapping behavior.\n    if (isUserAction) {\n        // Reset isUserAction flag because we're not in the main collision anymore.\n        isUserAction = false;\n\n        // Make a mock item so we don't modify the item here, only modify in moveElement.\n        const fakeItem: LayoutItem = {\n            x: compactH\n                ? Math.max(collidesWith.x - itemToMove.w, 0)\n                : itemToMove.x,\n            y: compactV\n                ? Math.max(collidesWith.y - itemToMove.h, 0)\n                : itemToMove.y,\n            w: itemToMove.w,\n            h: itemToMove.h,\n            id: '-1',\n        };\n\n        // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n        if (!getFirstCollision(layout, fakeItem)) {\n            log(\n                `Doing reverse collision on ${itemToMove.id} up to [${\n                    fakeItem.x\n                },${fakeItem.y}].`,\n            );\n            return moveElement(\n                layout,\n                itemToMove,\n                compactH ? fakeItem.x : undefined,\n                compactV ? fakeItem.y : undefined,\n                isUserAction,\n                preventCollision,\n                compactType,\n                cols,\n            );\n        }\n    }\n\n    return moveElement(\n        layout,\n        itemToMove,\n        compactH ? itemToMove.x + 1 : undefined,\n        compactV ? itemToMove.y + 1 : undefined,\n        isUserAction,\n        preventCollision,\n        compactType,\n        cols,\n    );\n}\n\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\nexport function perc(num: number): string {\n    return num * 100 + '%';\n}\n\nexport function setTransform({top, left, width, height}: Position): Object {\n    // Replace unitless items with px\n    const translate = `translate(${left}px,${top}px)`;\n    return {\n        transform: translate,\n        WebkitTransform: translate,\n        MozTransform: translate,\n        msTransform: translate,\n        OTransform: translate,\n        width: `${width}px`,\n        height: `${height}px`,\n        position: 'absolute',\n    };\n}\n\nexport function setTopLeft({top, left, width, height}: Position): Object {\n    return {\n        top: `${top}px`,\n        left: `${left}px`,\n        width: `${width}px`,\n        height: `${height}px`,\n        position: 'absolute',\n    };\n}\n\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\nexport function sortLayoutItems(\n    layout: Layout,\n    compactType: CompactType,\n): Layout {\n    if (compactType === 'horizontal') {\n        return sortLayoutItemsByColRow(layout);\n    } else {\n        return sortLayoutItemsByRowCol(layout);\n    }\n}\n\nexport function sortLayoutItemsByRowCol(layout: Layout): Layout {\n    return ([] as any[]).concat(layout).sort(function (a, b) {\n        if (a.y > b.y || (a.y === b.y && a.x > b.x)) {\n            return 1;\n        } else if (a.y === b.y && a.x === b.x) {\n            // Without this, we can get different sort results in IE vs. Chrome/FF\n            return 0;\n        }\n        return -1;\n    });\n}\n\nexport function sortLayoutItemsByColRow(layout: Layout): Layout {\n    return ([] as any[]).concat(layout).sort(function (a, b) {\n        if (a.x > b.x || (a.x === b.x && a.y > b.y)) {\n            return 1;\n        }\n        return -1;\n    });\n}\n\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nexport function validateLayout(\n    layout: Layout,\n    contextName: string = 'Layout',\n): void {\n    const subProps = ['x', 'y', 'w', 'h'];\n    if (!Array.isArray(layout)) {\n        throw new Error(contextName + ' must be an array!');\n    }\n    for (let i = 0, len = layout.length; i < len; i++) {\n        const item = layout[i];\n        for (let j = 0; j < subProps.length; j++) {\n            if (typeof item[subProps[j]] !== 'number') {\n                throw new Error(\n                    'ReactGridLayout: ' +\n                    contextName +\n                    '[' +\n                    i +\n                    '].' +\n                    subProps[j] +\n                    ' must be a number!',\n                );\n            }\n        }\n        if (item.id && typeof item.id !== 'string') {\n            throw new Error(\n                'ReactGridLayout: ' +\n                contextName +\n                '[' +\n                i +\n                '].i must be a string!',\n            );\n        }\n        if (item.static !== undefined && typeof item.static !== 'boolean') {\n            throw new Error(\n                'ReactGridLayout: ' +\n                contextName +\n                '[' +\n                i +\n                '].static must be a boolean!',\n            );\n        }\n    }\n}\n\n// Flow can't really figure this out, so we just use Object\nexport function autoBindHandlers(el: Object, fns: Array<string>): void {\n    fns.forEach(key => (el[key] = el[key].bind(el)));\n}\n\nfunction log(...args) {\n    if (!DEBUG) {\n        return;\n    }\n    // eslint-disable-next-line no-console\n    console.log(...args);\n}\n\nexport const noop = () => {};\n","/** Cached result of whether the user's browser supports passive event listeners. */\nlet supportsPassiveEvents: boolean;\n\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nexport function ktdSupportsPassiveEventListeners(): boolean {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', null!, Object.defineProperty({}, 'passive', {\n                get: () => supportsPassiveEvents = true\n            }));\n        } finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n\n    return supportsPassiveEvents;\n}\n\n/**\n * Normalizes an `AddEventListener` object to something that can be passed\n * to `addEventListener` on any browser, no matter whether it supports the\n * `options` parameter.\n * @param options Object to be normalized.\n */\nexport function ktdNormalizePassiveListenerOptions(options: AddEventListenerOptions):\n    AddEventListenerOptions | boolean {\n    return ktdSupportsPassiveEventListeners() ? options : !!options.capture;\n}\n","import { fromEvent, iif, merge, Observable } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport { ktdNormalizePassiveListenerOptions } from './passive-listeners';\n\n/** Options that can be used to bind a passive event listener. */\nconst passiveEventListenerOptions = ktdNormalizePassiveListenerOptions({passive: true});\n\n/** Options that can be used to bind an active event listener. */\nconst activeEventListenerOptions = ktdNormalizePassiveListenerOptions({passive: false});\n\nlet isMobile: boolean | null = null;\n\nexport function ktdIsMobileOrTablet(): boolean {\n\n    if (isMobile != null) {\n        return isMobile;\n    }\n\n    // Generic match pattern to identify mobile or tablet devices\n    const isMobileDevice = /Android|webOS|BlackBerry|Windows Phone|iPad|iPhone|iPod/i.test(navigator.userAgent);\n\n    // Since IOS 13 is not safe to just check for the generic solution. See: https://stackoverflow.com/questions/58019463/how-to-detect-device-name-in-safari-on-ios-13-while-it-doesnt-show-the-correct\n    const isIOSMobileDevice = /iPad|iPhone|iPod/.test(navigator.platform) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);\n\n    isMobile = isMobileDevice || isIOSMobileDevice;\n\n    return isMobile;\n}\n\nexport function ktdIsMouseEvent(event: any): event is MouseEvent {\n    return (event as MouseEvent).clientX != null;\n}\n\nexport function ktdIsTouchEvent(event: any): event is TouchEvent {\n    return (event as TouchEvent).touches != null && (event as TouchEvent).touches.length != null;\n}\n\nexport function ktdPointerClientX(event: MouseEvent | TouchEvent): number {\n    return ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX;\n}\n\nexport function ktdPointerClientY(event: MouseEvent | TouchEvent): number {\n    return ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY;\n}\n\nexport function ktdPointerClient(event: MouseEvent | TouchEvent): {clientX: number, clientY: number} {\n    return  {\n        clientX: ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX,\n        clientY: ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY\n    };\n}\n\n/**\n * Emits when a mousedown or touchstart emits. Avoids conflicts between both events.\n * @param element, html element where to  listen the events.\n * @param touchNumber number of the touch to track the event, default to the first one.\n */\nexport function ktdMouseOrTouchDown(element, touchNumber = 1): Observable<MouseEvent | TouchEvent> {\n    return iif(\n        () => ktdIsMobileOrTablet(),\n        fromEvent<TouchEvent>(element, 'touchstart', passiveEventListenerOptions as AddEventListenerOptions).pipe(\n            filter((touchEvent) => touchEvent.touches.length === touchNumber)\n        ),\n        fromEvent<MouseEvent>(element, 'mousedown', activeEventListenerOptions as AddEventListenerOptions).pipe(\n            filter((mouseEvent: MouseEvent) => {\n                /**\n                 * 0 : Left mouse button\n                 * 1 : Wheel button or middle button (if present)\n                 * 2 : Right mouse button\n                 */\n                return mouseEvent.button === 0; // Mouse down to be only fired if is left click\n            })\n        )\n    );\n}\n\n/**\n * Emits when a 'mousemove' or a 'touchmove' event gets fired.\n * @param element, html element where to  listen the events.\n * @param touchNumber number of the touch to track the event, default to the first one.\n */\nexport function ktdMouseOrTouchMove(element, touchNumber = 1): Observable<MouseEvent | TouchEvent> {\n    return iif(\n        () => ktdIsMobileOrTablet(),\n        fromEvent<TouchEvent>(element, 'touchmove', activeEventListenerOptions as AddEventListenerOptions).pipe(\n            filter((touchEvent) => touchEvent.touches.length === touchNumber),\n        ),\n        fromEvent<MouseEvent>(element, 'mousemove', activeEventListenerOptions as AddEventListenerOptions)\n    );\n}\n\nexport function ktdTouchEnd(element, touchNumber = 1): Observable<TouchEvent> {\n    return merge(\n        fromEvent<TouchEvent>(element, 'touchend').pipe(\n            filter((touchEvent) => touchEvent.touches.length === touchNumber - 1)\n        ),\n        fromEvent<TouchEvent>(element, 'touchcancel').pipe(\n            filter((touchEvent) => touchEvent.touches.length === touchNumber - 1)\n        )\n    );\n}\n\n/**\n * Emits when a there is a 'mouseup' or the touch ends.\n * @param element, html element where to  listen the events.\n * @param touchNumber number of the touch to track the event, default to the first one.\n */\nexport function ktdMouseOrTouchEnd(element, touchNumber = 1): Observable<MouseEvent | TouchEvent> {\n    return iif(\n        () => ktdIsMobileOrTablet(),\n        ktdTouchEnd(element, touchNumber),\n        fromEvent<MouseEvent>(element, 'mouseup'),\n    );\n}\n","import { compact, CompactType, getFirstCollision, Layout, LayoutItem, moveElement } from './react-grid-layout.utils';\nimport { KtdDraggingData, KtdGridCfg, KtdGridCompactType, KtdGridItemRect, KtdGridLayout, KtdGridLayoutItem } from '../grid.definitions';\nimport { ktdPointerClientX, ktdPointerClientY } from './pointer.utils';\nimport { KtdDictionary } from '../../types';\nimport { KtdGridItemComponent } from '../grid-item/grid-item.component';\n\n/** Tracks items by id. This function is mean to be used in conjunction with the ngFor that renders the 'ktd-grid-items' */\nexport function ktdTrackById(index: number, item: {id: string}) {\n    return item.id;\n}\n\n/**\n * Call react-grid-layout utils 'compact()' function and return the compacted layout.\n * @param layout to be compacted.\n * @param compactType, type of compaction.\n * @param cols, number of columns of the grid.\n */\nexport function ktdGridCompact(layout: KtdGridLayout, compactType: KtdGridCompactType, cols: number): KtdGridLayout {\n    return compact(layout, compactType, cols)\n        // Prune react-grid-layout compact extra properties.\n        .map(item => ({ id: item.id, x: item.x, y: item.y, w: item.w, h: item.h, minW: item.minW, minH: item.minH, maxW: item.maxW, maxH: item.maxH }));\n}\n\nfunction screenXPosToGridValue(screenXPos: number, cols: number, width: number): number {\n    return Math.round((screenXPos * cols) / width);\n}\n\nfunction screenYPosToGridValue(screenYPos: number, rowHeight: number, height: number): number {\n    return Math.round(screenYPos / rowHeight);\n}\n\n/** Returns a Dictionary where the key is the id and the value is the change applied to that item. If no changes Dictionary is empty. */\nexport function ktdGetGridLayoutDiff(gridLayoutA: KtdGridLayoutItem[], gridLayoutB: KtdGridLayoutItem[]): KtdDictionary<{ change: 'move' | 'resize' | 'moveresize' }> {\n    const diff: KtdDictionary<{ change: 'move' | 'resize' | 'moveresize' }> = {};\n\n    gridLayoutA.forEach(itemA => {\n        const itemB = gridLayoutB.find(_itemB => _itemB.id === itemA.id);\n        if (itemB != null) {\n            const posChanged = itemA.x !== itemB.x || itemA.y !== itemB.y;\n            const sizeChanged = itemA.w !== itemB.w || itemA.h !== itemB.h;\n            const change: 'move' | 'resize' | 'moveresize' | null = posChanged && sizeChanged ? 'moveresize' : posChanged ? 'move' : sizeChanged ? 'resize' : null;\n            if (change) {\n                diff[itemB.id] = {change};\n            }\n        }\n    });\n    return diff;\n}\n\n/**\n * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position\n * @param gridItem grid item that is been dragged\n * @param config current grid configuration\n * @param compactionType type of compaction that will be performed\n * @param draggingData contains all the information about the drag\n */\nexport function ktdGridItemDragging(gridItem: KtdGridItemComponent, config: KtdGridCfg, compactionType: CompactType, draggingData: KtdDraggingData): { layout: KtdGridLayoutItem[]; draggedItemPos: KtdGridItemRect } {\n    const {pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference} = draggingData;\n\n    const gridItemId = gridItem.id;\n\n    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId)!;\n\n    const clientStartX = ktdPointerClientX(pointerDownEvent);\n    const clientStartY = ktdPointerClientY(pointerDownEvent);\n    const clientX = ktdPointerClientX(pointerDragEvent);\n    const clientY = ktdPointerClientY(pointerDragEvent);\n\n    const offsetX = clientStartX - dragElemClientRect.left;\n    const offsetY = clientStartY - dragElemClientRect.top;\n\n    // Grid element positions taking into account the possible scroll total difference from the beginning.\n    const gridElementLeftPosition = gridElemClientRect.left + scrollDifference.left;\n    const gridElementTopPosition = gridElemClientRect.top + scrollDifference.top;\n\n    // Calculate position relative to the grid element.\n    const gridRelXPos = clientX - gridElementLeftPosition - offsetX;\n    const gridRelYPos = clientY - gridElementTopPosition - offsetY;\n\n    // Get layout item position\n    const layoutItem: KtdGridLayoutItem = {\n        ...draggingElemPrevItem,\n        x: screenXPosToGridValue(gridRelXPos, config.cols, gridElemClientRect.width),\n        y: screenYPosToGridValue(gridRelYPos, config.rowHeight, gridElemClientRect.height)\n    };\n\n    // Correct the values if they overflow, since 'moveElement' function doesn't do it\n    layoutItem.x = Math.max(0, layoutItem.x);\n    layoutItem.y = Math.max(0, layoutItem.y);\n    if (layoutItem.x + layoutItem.w > config.cols) {\n        layoutItem.x = Math.max(0, config.cols - layoutItem.w);\n    }\n\n    // Parse to LayoutItem array data in order to use 'react.grid-layout' utils\n    const layoutItems: LayoutItem[] = config.layout;\n    const draggedLayoutItem: LayoutItem = layoutItems.find(item => item.id === gridItemId)!;\n\n    let newLayoutItems: LayoutItem[] = moveElement(\n        layoutItems,\n        draggedLayoutItem,\n        layoutItem.x,\n        layoutItem.y,\n        true,\n        config.preventCollision,\n        compactionType,\n        config.cols\n    );\n\n    newLayoutItems = compact(newLayoutItems, compactionType, config.cols);\n\n    return {\n        layout: newLayoutItems,\n        draggedItemPos: {\n            top: gridRelYPos,\n            left: gridRelXPos,\n            width: dragElemClientRect.width,\n            height: dragElemClientRect.height,\n        }\n    };\n}\n\n/**\n * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position\n * @param gridItem grid item that is been dragged\n * @param config current grid configuration\n * @param compactionType type of compaction that will be performed\n * @param draggingData contains all the information about the drag\n */\nexport function ktdGridItemResizing(gridItem: KtdGridItemComponent, config: KtdGridCfg, compactionType: CompactType, draggingData: KtdDraggingData): { layout: KtdGridLayoutItem[]; draggedItemPos: KtdGridItemRect } {\n    const {pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference} = draggingData;\n    const gridItemId = gridItem.id;\n\n    const clientStartX = ktdPointerClientX(pointerDownEvent);\n    const clientStartY = ktdPointerClientY(pointerDownEvent);\n    const clientX = ktdPointerClientX(pointerDragEvent);\n    const clientY = ktdPointerClientY(pointerDragEvent);\n\n    // Get the difference between the mouseDown and the position 'right' of the resize element.\n    const resizeElemOffsetX = dragElemClientRect.width - (clientStartX - dragElemClientRect.left);\n    const resizeElemOffsetY = dragElemClientRect.height - (clientStartY - dragElemClientRect.top);\n\n    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId)!;\n    const width = clientX + resizeElemOffsetX - (dragElemClientRect.left + scrollDifference.left);\n    const height = clientY + resizeElemOffsetY - (dragElemClientRect.top + scrollDifference.top);\n\n\n    // Get layout item grid position\n    const layoutItem: KtdGridLayoutItem = {\n        ...draggingElemPrevItem,\n        w: screenXPosToGridValue(width, config.cols, gridElemClientRect.width),\n        h: screenYPosToGridValue(height, config.rowHeight, gridElemClientRect.height)\n    };\n\n    layoutItem.w = limitNumberWithinRange(layoutItem.w, gridItem.minW ?? layoutItem.minW, gridItem.maxW ?? layoutItem.maxW);\n    layoutItem.h = limitNumberWithinRange(layoutItem.h, gridItem.minH ?? layoutItem.minH, gridItem.maxH ?? layoutItem.maxH);\n\n    if (layoutItem.x + layoutItem.w > config.cols) {\n        layoutItem.w = Math.max(1, config.cols - layoutItem.x);\n    }\n\n    if (config.preventCollision) {\n        const maxW = layoutItem.w;\n        const maxH = layoutItem.h;\n\n        let colliding = hasCollision(config.layout, layoutItem);\n        let shrunkDimension: 'w' | 'h' | undefined;\n\n        while (colliding) {\n            shrunkDimension = getDimensionToShrink(layoutItem, shrunkDimension);\n            layoutItem[shrunkDimension]--;\n            colliding = hasCollision(config.layout, layoutItem);\n        }\n\n        if (shrunkDimension === 'w') {\n            layoutItem.h = maxH;\n\n            colliding = hasCollision(config.layout, layoutItem);\n            while (colliding) {\n                layoutItem.h--;\n                colliding = hasCollision(config.layout, layoutItem);\n            }\n        }\n        if (shrunkDimension === 'h') {\n            layoutItem.w = maxW;\n\n            colliding = hasCollision(config.layout, layoutItem);\n            while (colliding) {\n                layoutItem.w--;\n                colliding = hasCollision(config.layout, layoutItem);\n            }\n        }\n\n    }\n\n    const newLayoutItems: LayoutItem[] = config.layout.map((item) => {\n        return item.id === gridItemId ? layoutItem : item;\n    });\n\n    return {\n        layout: compact(newLayoutItems, compactionType, config.cols),\n        draggedItemPos: {\n            top: dragElemClientRect.top - gridElemClientRect.top,\n            left: dragElemClientRect.left - gridElemClientRect.left,\n            width,\n            height,\n        }\n    };\n}\n\nfunction hasCollision(layout: Layout, layoutItem: LayoutItem): boolean {\n    return !!getFirstCollision(layout, layoutItem);\n}\n\nfunction getDimensionToShrink(layoutItem, lastShrunk): 'w' | 'h' {\n    if (layoutItem.h <= 1) {\n        return 'w';\n    }\n    if (layoutItem.w <= 1) {\n        return 'h';\n    }\n\n    return lastShrunk === 'w' ? 'h' : 'w';\n}\n\n/**\n * Given the current number and min/max values, returns the number within the range\n * @param number can be any numeric value\n * @param min minimum value of range\n * @param max maximum value of range\n */\nfunction limitNumberWithinRange(num: number, min: number = 1, max: number = Infinity) {\n    return Math.min(Math.max(num, min < 1 ? 1 : min), max);\n}\n","import { Directive, ElementRef, InjectionToken } from '@angular/core';\n\n/**\n * Injection token that can be used to reference instances of `KtdGridDragHandle`. It serves as\n * alternative token to the actual `KtdGridDragHandle` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const KTD_GRID_DRAG_HANDLE = new InjectionToken<KtdGridDragHandle>('KtdGridDragHandle');\n\n/** Handle that can be used to drag a KtdGridItem instance. */\n@Directive({\n    selector: '[ktdGridDragHandle]',\n    // eslint-disable-next-line @angular-eslint/no-host-metadata-property\n    host: {\n        class: 'ktd-grid-drag-handle'\n    },\n    providers: [{provide: KTD_GRID_DRAG_HANDLE, useExisting: KtdGridDragHandle}],\n})\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\nexport class KtdGridDragHandle {\n    constructor(\n        public element: ElementRef<HTMLElement>) {\n    }\n}\n","import { Directive, ElementRef, InjectionToken, } from '@angular/core';\n\n\n/**\n * Injection token that can be used to reference instances of `KtdGridResizeHandle`. It serves as\n * alternative token to the actual `KtdGridResizeHandle` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const KTD_GRID_RESIZE_HANDLE = new InjectionToken<KtdGridResizeHandle>('KtdGridResizeHandle');\n\n/** Handle that can be used to drag a KtdGridItem instance. */\n@Directive({\n    selector: '[ktdGridResizeHandle]',\n    // eslint-disable-next-line @angular-eslint/no-host-metadata-property\n    host: {\n        class: 'ktd-grid-resize-handle'\n    },\n    providers: [{provide: KTD_GRID_RESIZE_HANDLE, useExisting: KtdGridResizeHandle}],\n})\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\nexport class KtdGridResizeHandle {\n\n    constructor(\n        public element: ElementRef<HTMLElement>) {\n    }\n}\n","import { InjectionToken } from '@angular/core';\nimport { CompactType } from './utils/react-grid-layout.utils';\n\nexport interface KtdGridLayoutItem {\n    id: string;\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    minW?: number;\n    minH?: number;\n    maxW?: number;\n    maxH?: number;\n}\n\nexport type KtdGridCompactType = CompactType;\n\nexport interface KtdGridCfg {\n    cols: number;\n    rowHeight: number; // row height in pixels\n    layout: KtdGridLayoutItem[];\n    preventCollision: boolean;\n}\n\nexport type KtdGridLayout = KtdGridLayoutItem[];\n\n// TODO: Remove this interface. If can't remove, move and rename this interface in the core module or similar.\nexport interface KtdGridItemRect {\n    top: number;\n    left: number;\n    width: number;\n    height: number;\n}\n\nexport interface KtdGridItemRenderData<T = number | string> {\n    id: string;\n    top: T;\n    left: T;\n    width: T;\n    height: T;\n}\n\n/**\n * We inject a token because of the 'circular dependency issue warning'. In case we don't had this issue with the circular dependency, we could just\n * import KtdGridComponent on KtdGridItem and execute the needed function to get the rendering data.\n */\nexport type KtdGridItemRenderDataTokenType = (id: string) => KtdGridItemRenderData<string>;\nexport const GRID_ITEM_GET_RENDER_DATA_TOKEN: InjectionToken<KtdGridItemRenderDataTokenType> = new InjectionToken('GRID_ITEM_GET_RENDER_DATA_TOKEN');\n\nexport interface KtdDraggingData {\n    pointerDownEvent: MouseEvent | TouchEvent;\n    pointerDragEvent: MouseEvent | TouchEvent;\n    gridElemClientRect: ClientRect;\n    dragElemClientRect: ClientRect;\n    scrollDifference: { top: number, left: number };\n}\n","import { NgZone } from '@angular/core';\nimport { Observable, Subscription } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\n/** Runs source observable outside the zone */\nexport function ktdOutsideZone<T>(zone: NgZone) {\n    return (source: Observable<T>) => {\n        return new Observable<T>(observer => {\n            return zone.runOutsideAngular<Subscription>(() => source.subscribe(observer));\n        });\n    };\n}\n\n\n/** Rxjs operator that makes source observable to no emit any data */\nexport function ktdNoEmit() {\n    return (source$: Observable<any>): Observable<any> => {\n        return source$.pipe(filter(() => false));\n    };\n}\n","// tslint:disable\n/**\n * Type describing the allowed values for a boolean input.\n * @docs-private\n */\nexport type BooleanInput = string | boolean | null | undefined;\n\n/** Coerces a data-bound value (typically a string) to a boolean. */\nexport function coerceBooleanProperty(value: any): boolean {\n  return value != null && `${value}` !== 'false';\n}\n","// tslint:disable\nexport type NumberInput = string | number | null | undefined;\n\n/** Coerces a data-bound value (typically a string) to a number. */\nexport function coerceNumberProperty(value: any): number;\nexport function coerceNumberProperty<D>(value: any, fallback: D): number | D;\nexport function coerceNumberProperty(value: any, fallbackValue = 0) {\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n\n/**\n * Whether the provided value is considered a number.\n * @docs-private\n */\nexport function _isNumberValue(value: any): boolean {\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return !isNaN(parseFloat(value as any)) && !isNaN(Number(value));\n}\n","import { Injectable, NgZone, OnDestroy } from '@angular/core';\nimport { ktdNormalizePassiveListenerOptions } from './utils/passive-listeners';\nimport { fromEvent, iif, Observable, Subject, Subscription } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport { ktdIsMobileOrTablet } from './utils/pointer.utils';\n\n/** Event options that can be used to bind an active, capturing event. */\nconst activeCapturingEventOptions = ktdNormalizePassiveListenerOptions({\n    passive: false,\n    capture: true\n});\n\n@Injectable({providedIn: 'root'})\nexport class KtdGridService implements OnDestroy {\n\n    touchMove$: Observable<TouchEvent>;\n    private touchMoveSubject: Subject<TouchEvent> = new Subject<TouchEvent>();\n    private touchMoveSubscription: Subscription;\n\n    constructor(private ngZone: NgZone) {\n        this.touchMove$ = this.touchMoveSubject.asObservable();\n        this.registerTouchMoveSubscription();\n    }\n\n    ngOnDestroy() {\n        this.touchMoveSubscription.unsubscribe();\n    }\n\n    mouseOrTouchMove$(element): Observable<MouseEvent | TouchEvent> {\n        return iif(\n            () => ktdIsMobileOrTablet(),\n            this.touchMove$,\n            fromEvent<MouseEvent>(element, 'mousemove', activeCapturingEventOptions as AddEventListenerOptions) // TODO: Fix rxjs typings, boolean should be a good param too.\n        );\n    }\n\n    private registerTouchMoveSubscription() {\n        // The `touchmove` event gets bound once, ahead of time, because WebKit\n        // won't preventDefault on a dynamically-added `touchmove` listener.\n        // See https://bugs.webkit.org/show_bug.cgi?id=184250.\n        this.touchMoveSubscription = this.ngZone.runOutsideAngular(() =>\n            // The event handler has to be explicitly active,\n            // because newer browsers make it passive by default.\n            fromEvent(document, 'touchmove', activeCapturingEventOptions as AddEventListenerOptions) // TODO: Fix rxjs typings, boolean should be a good param too.\n                .pipe(filter((touchEvent: TouchEvent) => touchEvent.touches.length === 1))\n                .subscribe((touchEvent: TouchEvent) => this.touchMoveSubject.next(touchEvent))\n        );\n    }\n}\n","import {\n    AfterContentInit, ChangeDetectionStrategy, Component, ContentChildren, ElementRef, Inject, Input, NgZone, OnDestroy, OnInit, QueryList, Renderer2,\n    ViewChild\n} from '@angular/core';\nimport { BehaviorSubject, iif, merge, NEVER, Observable, Subject, Subscription } from 'rxjs';\nimport { exhaustMap, filter, map, startWith, switchMap, take, takeUntil } from 'rxjs/operators';\nimport { ktdMouseOrTouchDown, ktdMouseOrTouchEnd, ktdPointerClient } from '../utils/pointer.utils';\nimport { GRID_ITEM_GET_RENDER_DATA_TOKEN, KtdGridItemRenderDataTokenType } from '../grid.definitions';\nimport { KTD_GRID_DRAG_HANDLE, KtdGridDragHandle } from '../directives/drag-handle';\nimport { KTD_GRID_RESIZE_HANDLE, KtdGridResizeHandle } from '../directives/resize-handle';\nimport { KtdGridService } from '../grid.service';\nimport { ktdOutsideZone } from '../utils/operators';\nimport { BooleanInput, coerceBooleanProperty } from '../coercion/boolean-property';\nimport { coerceNumberProperty, NumberInput } from '../coercion/number-property';\n\n@Component({\n    selector: 'ktd-grid-item',\n    templateUrl: './grid-item.component.html',\n    styleUrls: ['./grid-item.component.scss'],\n    changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class KtdGridItemComponent implements OnInit, OnDestroy, AfterContentInit {\n    /** Elements that can be used to drag the grid item. */\n    @ContentChildren(KTD_GRID_DRAG_HANDLE, {descendants: true}) _dragHandles: QueryList<KtdGridDragHandle>;\n    @ContentChildren(KTD_GRID_RESIZE_HANDLE, {descendants: true}) _resizeHandles: QueryList<KtdGridResizeHandle>;\n    @ViewChild('resizeElem', {static: true, read: ElementRef}) resizeElem: ElementRef;\n\n    /** Min and max size input properties. Any of these would 'override' the min/max values specified in the layout. */\n    @Input() minW?: number;\n    @Input() minH?: number;\n    @Input() maxW?: number;\n    @Input() maxH?: number;\n\n    /** CSS transition style. Note that for more performance is preferable only make transition on transform property. */\n    @Input() transition: string = 'transform 500ms ease, width 500ms ease, height 500ms ease';\n\n    dragStart$: Observable<MouseEvent | TouchEvent>;\n    resizeStart$: Observable<MouseEvent | TouchEvent>;\n\n    /** Id of the grid item. This property is strictly compulsory. */\n    @Input()\n    get id(): string {\n        return this._id;\n    }\n\n    set id(val: string) {\n        this._id = val;\n    }\n\n    private _id: string;\n\n    /** Minimum amount of pixels that the user should move before it starts the drag sequence. */\n    @Input()\n    get dragStartThreshold(): number { return this._dragStartThreshold; }\n\n    set dragStartThreshold(val: number) {\n        this._dragStartThreshold = coerceNumberProperty(val);\n    }\n\n    private _dragStartThreshold: number = 0;\n\n\n    /** Whether the item is draggable or not. Defaults to true. */\n    @Input()\n    get draggable(): boolean {\n        return this._draggable;\n    }\n\n    set draggable(val: boolean) {\n        this._draggable = coerceBooleanProperty(val);\n        this._draggable$.next(this._draggable);\n    }\n\n    private _draggable: boolean = true;\n    private _draggable$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(this._draggable);\n\n    /** Whether the item is resizable or not. Defaults to true. */\n    @Input()\n    get resizable(): boolean {\n        return this._resizable;\n    }\n\n    set resizable(val: boolean) {\n        this._resizable = coerceBooleanProperty(val);\n        this._resizable$.next(this._resizable);\n    }\n\n    private _resizable: boolean = true;\n    private _resizable$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(this._resizable);\n\n    private dragStartSubject: Subject<MouseEvent | TouchEvent> = new Subject<MouseEvent | TouchEvent>();\n    private resizeStartSubject: Subject<MouseEvent | TouchEvent> = new Subject<MouseEvent | TouchEvent>();\n\n    private subscriptions: Subscription[] = [];\n\n    constructor(public elementRef: ElementRef,\n                private gridService: KtdGridService,\n                private renderer: Renderer2,\n                private ngZone: NgZone,\n                @Inject(GRID_ITEM_GET_RENDER_DATA_TOKEN) private getItemRenderData: KtdGridItemRenderDataTokenType) {\n        this.dragStart$ = this.dragStartSubject.asObservable();\n        this.resizeStart$ = this.resizeStartSubject.asObservable();\n    }\n\n    ngOnInit() {\n        const gridItemRenderData = this.getItemRenderData(this.id)!;\n        this.setStyles(gridItemRenderData);\n    }\n\n    ngAfterContentInit() {\n        this.subscriptions.push(\n            this._dragStart$().subscribe(this.dragStartSubject),\n            this._resizeStart$().subscribe(this.resizeStartSubject),\n        );\n    }\n\n    ngOnDestroy() {\n        this.subscriptions.forEach(sub => sub.unsubscribe());\n    }\n\n    setStyles({top, left, width, height}: { top: string, left: string, width?: string, height?: string }) {\n        // transform is 6x times faster than top/left\n        this.renderer.setStyle(this.elementRef.nativeElement, 'transform', `translateX(${left}) translateY(${top})`);\n        this.renderer.setStyle(this.elementRef.nativeElement, 'display', `block`);\n        this.renderer.setStyle(this.elementRef.nativeElement, 'transition', this.transition);\n        if (width != null) { this.renderer.setStyle(this.elementRef.nativeElement, 'width', width); }\n        if (height != null) {this.renderer.setStyle(this.elementRef.nativeElement, 'height', height); }\n    }\n\n    private _dragStart$(): Observable<MouseEvent | TouchEvent> {\n        return this._draggable$.pipe(\n            switchMap((draggable) => {\n                if (!draggable) {\n                    return NEVER;\n                } else {\n                    return this._dragHandles.changes.pipe(\n                        startWith(this._dragHandles),\n                        switchMap((dragHandles: QueryList<KtdGridDragHandle>) => {\n                            return iif(\n                                () => dragHandles.length > 0,\n                                merge(...dragHandles.toArray().map(dragHandle => ktdMouseOrTouchDown(dragHandle.element.nativeElement, 1))),\n                                ktdMouseOrTouchDown(this.elementRef.nativeElement, 1)\n                            ).pipe(\n                                exhaustMap((startEvent) => {\n                                    // If the event started from an element with the native HTML drag&drop, it'll interfere\n                                    // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\n                                    // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\n                                    // it's flaky and it fails if the user drags it away quickly. Also note that we only want\n                                    // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\n                                    // events from firing on touch devices.\n                                    if (startEvent.target && (startEvent.target as HTMLElement).draggable && startEvent.type === 'mousedown') {\n                                        startEvent.preventDefault();\n                                    }\n\n                                    const startPointer = ktdPointerClient(startEvent);\n                                    return this.gridService.mouseOrTouchMove$(document).pipe(\n                                        takeUntil(ktdMouseOrTouchEnd(document, 1)),\n                                        ktdOutsideZone(this.ngZone),\n                                        filter((moveEvent) => {\n                                            moveEvent.preventDefault();\n                                            const movePointer = ktdPointerClient(moveEvent);\n                                            const distanceX = Math.abs(startPointer.clientX - movePointer.clientX);\n                                            const distanceY = Math.abs(startPointer.clientY - movePointer.clientY);\n                                            // When this conditions returns true mean that we are over threshold.\n                                            return distanceX + distanceY >= this.dragStartThreshold;\n                                        }),\n                                        take(1),\n                                        // Return the original start event\n                                        map(() => startEvent)\n                                    );\n                                })\n                            );\n                        })\n                    );\n                }\n            })\n        );\n    }\n\n    private _resizeStart$(): Observable<MouseEvent | TouchEvent> {\n        return this._resizable$.pipe(\n            switchMap((resizable) => {\n                if (!resizable) {\n                    // Side effect to hide the resizeElem if resize is disabled.\n                    this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\n                    return NEVER;\n                } else {\n                    return this._resizeHandles.changes.pipe(\n                        startWith(this._resizeHandles),\n                        switchMap((resizeHandles: QueryList<KtdGridResizeHandle>) => {\n                            if (resizeHandles.length > 0) {\n                                // Side effect to hide the resizeElem if there are resize handles.\n                                this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\n                                return merge(...resizeHandles.toArray().map(resizeHandle => ktdMouseOrTouchDown(resizeHandle.element.nativeElement, 1)));\n                            } else {\n                                this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'block');\n                                return ktdMouseOrTouchDown(this.resizeElem.nativeElement, 1);\n                            }\n                        })\n                    );\n                }\n            })\n        );\n    }\n\n\n    // tslint:disable-next-line\n    static ngAcceptInputType_minW: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_minH: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_maxW: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_maxH: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_draggable: BooleanInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_resizable: BooleanInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_dragStartThreshold: NumberInput;\n\n}\n","<ng-content></ng-content>\n<div #resizeElem class=\"grid-item-resize-icon\"></div>\n","\n// tslint:disable\n\n/**\n * Client rect utilities.\n * This file is taken from Angular Material repository. This is the reason why the tslint is disabled on this case.\n * Don't enable it until some custom change is done on this file.\n */\n\n\n/** Gets a mutable version of an element's bounding `ClientRect`. */\nexport function getMutableClientRect(element: Element): ClientRect {\n    const { top, right, bottom, left, width, height, x, y, toJSON } = element.getBoundingClientRect();\n\n    // We need to clone the `clientRect` here, because all the values on it are readonly\n    // and we need to be able to update them. Also we can't use a spread here, because\n    // the values on a `ClientRect` aren't own properties. See:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n    return { top, right, bottom, left, width, height, x, y, toJSON };\n}\n\n/**\n * Checks whether some coordinates are within a `ClientRect`.\n * @param clientRect ClientRect that is being checked.\n * @param x Coordinates along the X axis.\n * @param y Coordinates along the Y axis.\n */\n// export function isInsideClientRect(clientRect: ClientRect, x: number, y: number) {\n//   const {top, bottom, left, right} = clientRect;\n//   return y >= top && y <= bottom && x >= left && x <= right;\n// }\n\n/**\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\n * @param clientRect `ClientRect` that should be updated.\n * @param top Amount to add to the `top` position.\n * @param left Amount to add to the `left` position.\n */\n// export function adjustClientRect(clientRect: ClientRect, top: number, left: number) {\n//   clientRect.top += top;\n//   clientRect.bottom = clientRect.top + clientRect.height;\n\n//   clientRect.left += left;\n//   clientRect.right = clientRect.left + clientRect.width;\n// }\n\n/**\n * Checks whether the pointer coordinates are close to a ClientRect.\n * @param rect ClientRect to check against.\n * @param threshold Threshold around the ClientRect.\n * @param pointerX Coordinates along the X axis.\n * @param pointerY Coordinates along the Y axis.\n */\n// export function isPointerNearClientRect(rect: ClientRect,\n//                                         threshold: number,\n//                                         pointerX: number,\n//                                         pointerY: number): boolean {\n//   const {top, right, bottom, left, width, height} = rect;\n//   const xThreshold = width * threshold;\n//   const yThreshold = height * threshold;\n\n//   return pointerY > top - yThreshold && pointerY < bottom + yThreshold &&\n//          pointerX > left - xThreshold && pointerX < right + xThreshold;\n// }\n","import { animationFrameScheduler, fromEvent, interval, NEVER, Observable } from 'rxjs';\nimport { distinctUntilChanged, map, switchMap, tap } from 'rxjs/operators';\nimport { ktdNormalizePassiveListenerOptions } from './passive-listeners';\nimport { getMutableClientRect } from './client-rect';\nimport { ktdNoEmit } from './operators';\n\n/**\n * Proximity, as a ratio to width/height at which to start auto-scrolling.\n * The value comes from trying it out manually until it feels right.\n */\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\n\n/** Vertical direction in which we can auto-scroll. */\nconst enum AutoScrollVerticalDirection {NONE, UP, DOWN}\n\n/** Horizontal direction in which we can auto-scroll. */\nconst enum AutoScrollHorizontalDirection {NONE, LEFT, RIGHT}\n\nexport interface KtdScrollPosition {\n    top: number;\n    left: number;\n}\n\n\n/**\n * Increments the vertical scroll position of a node.\n * @param node Node whose scroll position should change.\n * @param amount Amount of pixels that the `node` should be scrolled.\n */\nfunction incrementVerticalScroll(node: HTMLElement | Window, amount: number) {\n    if (node === window) {\n        (node as Window).scrollBy(0, amount);\n    } else {\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n        (node as HTMLElement).scrollTop += amount;\n    }\n}\n\n/**\n * Increments the horizontal scroll position of a node.\n * @param node Node whose scroll position should change.\n * @param amount Amount of pixels that the `node` should be scrolled.\n */\nfunction incrementHorizontalScroll(node: HTMLElement | Window, amount: number) {\n    if (node === window) {\n        (node as Window).scrollBy(amount, 0);\n    } else {\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n        (node as HTMLElement).scrollLeft += amount;\n    }\n}\n\n\n/**\n * Gets whether the vertical auto-scroll direction of a node.\n * @param clientRect Dimensions of the node.\n * @param pointerY Position of the user's pointer along the y axis.\n */\nfunction getVerticalScrollDirection(clientRect: ClientRect, pointerY: number) {\n    const {top, bottom, height} = clientRect;\n    const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\n\n    if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\n        return AutoScrollVerticalDirection.UP;\n    } else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\n        return AutoScrollVerticalDirection.DOWN;\n    }\n\n    return AutoScrollVerticalDirection.NONE;\n}\n\n/**\n * Gets whether the horizontal auto-scroll direction of a node.\n * @param clientRect Dimensions of the node.\n * @param pointerX Position of the user's pointer along the x axis.\n */\nfunction getHorizontalScrollDirection(clientRect: ClientRect, pointerX: number) {\n    const {left, right, width} = clientRect;\n    const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\n\n    if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\n        return AutoScrollHorizontalDirection.LEFT;\n    } else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\n        return AutoScrollHorizontalDirection.RIGHT;\n    }\n\n    return AutoScrollHorizontalDirection.NONE;\n}\n\n/**\n * Returns an observable that schedules a loop and apply scroll on the scrollNode into the specified direction/s.\n * This observable doesn't emit, it just performs the 'scroll' side effect.\n * @param scrollNode, node where the scroll would be applied.\n * @param verticalScrollDirection, vertical direction of the scroll.\n * @param horizontalScrollDirection, horizontal direction of the scroll.\n * @param scrollStep, scroll step in CSS pixels that would be applied in every loop.\n */\nfunction scrollToDirectionInterval$(scrollNode: HTMLElement | Window, verticalScrollDirection: AutoScrollVerticalDirection, horizontalScrollDirection: AutoScrollHorizontalDirection, scrollStep: number = 2) {\n    return interval(0, animationFrameScheduler)\n        .pipe(\n            tap(() => {\n                if (verticalScrollDirection === AutoScrollVerticalDirection.UP) {\n                    incrementVerticalScroll(scrollNode, -scrollStep);\n                } else if (verticalScrollDirection === AutoScrollVerticalDirection.DOWN) {\n                    incrementVerticalScroll(scrollNode, scrollStep);\n                }\n\n                if (horizontalScrollDirection === AutoScrollHorizontalDirection.LEFT) {\n                    incrementHorizontalScroll(scrollNode, -scrollStep);\n                } else if (horizontalScrollDirection === AutoScrollHorizontalDirection.RIGHT) {\n                    incrementHorizontalScroll(scrollNode, scrollStep);\n                }\n            }),\n            ktdNoEmit()\n        );\n}\n\nexport interface KtdScrollIfNearElementOptions {\n    scrollStep?: number;\n    disableVertical?: boolean;\n    disableHorizontal?: boolean;\n}\n\n/**\n * Given a source$ observable with pointer location, scroll the scrollNode if the pointer is near to it.\n * This observable doesn't emit, it just performs a 'scroll' side effect.\n * @param scrollableParent, parent node in which the scroll would be performed.\n * @param options, configuration options.\n */\nexport function ktdScrollIfNearElementClientRect$(scrollableParent: HTMLElement | Document, options?: KtdScrollIfNearElementOptions): (source$: Observable<{ pointerX: number, pointerY: number }>) => Observable<any> {\n\n    let scrollNode: Window | HTMLElement;\n    let scrollableParentClientRect: ClientRect;\n    let scrollableParentScrollWidth: number;\n\n    if (scrollableParent === document) {\n        scrollNode = document.defaultView as Window;\n        const {width, height} = getViewportSize();\n        scrollableParentClientRect = {width, height, top: 0, right: width, bottom: height, left: 0, x:0, y: 0, toJSON: () => null};\n        scrollableParentScrollWidth = getDocumentScrollWidth();\n    } else {\n        scrollNode = scrollableParent as HTMLElement;\n        scrollableParentClientRect = getMutableClientRect(scrollableParent as HTMLElement);\n        scrollableParentScrollWidth = (scrollableParent as HTMLElement).scrollWidth;\n    }\n\n    /**\n     * IMPORTANT: By design, only let scroll horizontal if the scrollable parent has explicitly an scroll horizontal.\n     * This layout solution is not designed in mind to have any scroll horizontal, but exceptionally we allow it in this\n     * specific use case.\n     */\n    options = options || {};\n    if (options.disableHorizontal == null && scrollableParentScrollWidth <= scrollableParentClientRect.width) {\n        options.disableHorizontal = true;\n    }\n\n    return (source$) => source$.pipe(\n        map(({pointerX, pointerY}) => {\n            let verticalScrollDirection = getVerticalScrollDirection(scrollableParentClientRect, pointerY);\n            let horizontalScrollDirection = getHorizontalScrollDirection(scrollableParentClientRect, pointerX);\n\n            // Check if scroll directions are disabled.\n            if (options?.disableVertical) {\n                verticalScrollDirection = AutoScrollVerticalDirection.NONE;\n            }\n            if (options?.disableHorizontal) {\n                horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;\n            }\n\n            return {verticalScrollDirection, horizontalScrollDirection};\n        }),\n        distinctUntilChanged((prev, actual) => {\n            return prev.verticalScrollDirection === actual.verticalScrollDirection\n                && prev.horizontalScrollDirection === actual.horizontalScrollDirection;\n        }),\n        switchMap(({verticalScrollDirection, horizontalScrollDirection}) => {\n            if (verticalScrollDirection || horizontalScrollDirection) {\n                return scrollToDirectionInterval$(scrollNode, verticalScrollDirection, horizontalScrollDirection, options?.scrollStep);\n            } else {\n                return NEVER;\n            }\n        })\n    );\n}\n\n/**\n * Emits on EVERY scroll event and returns the accumulated scroll offset relative to the initial scroll position.\n * @param scrollableParent, node in which scroll events would be listened.\n */\nexport function ktdGetScrollTotalRelativeDifference$(scrollableParent: HTMLElement | Document): Observable<{ top: number, left: number }> {\n    let scrollInitialPosition;\n\n    // Calculate initial scroll position\n    if (scrollableParent === document) {\n        scrollInitialPosition = getViewportScrollPosition();\n    } else {\n        scrollInitialPosition = {\n            top: (scrollableParent as HTMLElement).scrollTop,\n            left: (scrollableParent as HTMLElement).scrollLeft\n        };\n    }\n\n    return fromEvent(scrollableParent, 'scroll', ktdNormalizePassiveListenerOptions({capture: true}) as AddEventListenerOptions).pipe(\n        map(() => {\n            let newTop: number;\n            let newLeft: number;\n\n            if (scrollableParent === document) {\n                const viewportScrollPosition = getViewportScrollPosition();\n                newTop = viewportScrollPosition.top;\n                newLeft = viewportScrollPosition.left;\n            } else {\n                newTop = (scrollableParent as HTMLElement).scrollTop;\n                newLeft = (scrollableParent as HTMLElement).scrollLeft;\n            }\n\n            const topDifference = scrollInitialPosition.top - newTop;\n            const leftDifference = scrollInitialPosition.left - newLeft;\n\n            return {top: topDifference, left: leftDifference};\n        })\n    );\n\n}\n\n/** Returns the viewport's width and height. */\nfunction getViewportSize(): { width: number, height: number } {\n    const _window = document.defaultView || window;\n    return {\n        width: _window.innerWidth,\n        height: _window.innerHeight\n    };\n\n}\n\n/** Gets a ClientRect for the viewport's bounds. */\n// function getViewportRect(): ClientRect {\n//     // Use the document element's bounding rect rather than the window scroll properties\n//     // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n//     // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n//     // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n//     // can disagree when the page is pinch-zoomed (on devices that support touch).\n//     // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n//     // We use the documentElement instead of the body because, by default (without a css reset)\n//     // browsers typically give the document body an 8px margin, which is not included in\n//     // getBoundingClientRect().\n//     const scrollPosition = getViewportScrollPosition();\n//     const {width, height} = getViewportSize();\n\n//     return {\n//         top: scrollPosition.top,\n//         left: scrollPosition.left,\n//         bottom: scrollPosition.top + height,\n//         right: scrollPosition.left + width,\n//         height,\n//         width,\n//     };\n// }\n\n/** Gets the (top, left) scroll position of the viewport. */\nfunction getViewportScrollPosition(): { top: number, left: number } {\n\n    // The top-left-corner of the viewport is determined by the scroll position of the document\n    // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n    // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n    // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n    // `document.documentElement` works consistently, where the `top` and `left` values will\n    // equal negative the scroll position.\n    const windowRef = document.defaultView || window;\n    const documentElement = document.documentElement!;\n    const documentRect = documentElement.getBoundingClientRect();\n\n    const top = -documentRect.top || document.body.scrollTop || windowRef.scrollY ||\n        documentElement.scrollTop || 0;\n\n    const left = -documentRect.left || document.body.scrollLeft || windowRef.scrollX ||\n        documentElement.scrollLeft || 0;\n\n    return {top, left};\n}\n\n/** Returns the document scroll width */\nfunction getDocumentScrollWidth() {\n    return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\n}\n\n","import {\n    AfterContentChecked, AfterContentInit, ChangeDetectionStrategy, Component, ContentChildren, ElementRef, EventEmitter, Input, NgZone, OnChanges,\n    OnDestroy, Output, QueryList, Renderer2, SimpleChanges, ViewEncapsulation\n} from '@angular/core';\nimport { coerceNumberProperty, NumberInput } from './coercion/number-property';\nimport { KtdGridItemComponent } from './grid-item/grid-item.component';\nimport { combineLatest, merge, NEVER, Observable, Observer, of, Subscription } from 'rxjs';\nimport { exhaustMap, map, startWith, switchMap, takeUntil } from 'rxjs/operators';\nimport { ktdGridItemDragging, ktdGridItemResizing } from './utils/grid.utils';\nimport { compact, CompactType } from './utils/react-grid-layout.utils';\nimport {\n    GRID_ITEM_GET_RENDER_DATA_TOKEN, KtdDraggingData, KtdGridCfg, KtdGridCompactType, KtdGridItemRect, KtdGridItemRenderData, KtdGridLayout,\n    KtdGridLayoutItem\n} from './grid.definitions';\nimport { ktdMouseOrTouchEnd, ktdPointerClientX, ktdPointerClientY } from './utils/pointer.utils';\nimport { KtdDictionary } from '../types';\nimport { KtdGridService } from './grid.service';\nimport { getMutableClientRect } from './utils/client-rect';\nimport { ktdGetScrollTotalRelativeDifference$, ktdScrollIfNearElementClientRect$ } from './utils/scroll';\nimport { BooleanInput, coerceBooleanProperty } from './coercion/boolean-property';\n\ninterface KtdDragResizeEvent {\n    layout: KtdGridLayout;\n    layoutItem: KtdGridLayoutItem;\n    gridItemRef: KtdGridItemComponent;\n}\n\nexport type KtdDragStart = KtdDragResizeEvent;\nexport type KtdResizeStart = KtdDragResizeEvent;\nexport type KtdDragEnd = KtdDragResizeEvent;\nexport type KtdResizeEnd = KtdDragResizeEvent;\n\nfunction getDragResizeEventData(gridItem: KtdGridItemComponent, layout: KtdGridLayout): KtdDragResizeEvent {\n    return {\n        layout,\n        layoutItem: layout.find((item) => item.id === gridItem.id)!,\n        gridItemRef: gridItem\n    };\n}\n\n\nfunction layoutToRenderItems(config: KtdGridCfg, width: number, height: number): KtdDictionary<KtdGridItemRenderData<number>> {\n    const {cols, rowHeight, layout} = config;\n\n    const renderItems: KtdDictionary<KtdGridItemRenderData<number>> = {};\n    for (const item of layout) {\n        renderItems[item.id] = {\n            id: item.id,\n            top: item.y === 0 ? 0 : item.y * rowHeight,\n            left: item.x * (width / cols),\n            width: item.w * (width / cols),\n            height: item.h * rowHeight\n        };\n    }\n    return renderItems;\n}\n\nfunction getGridHeight(layout: KtdGridLayout, rowHeight: number): number {\n    return layout.reduce((acc, cur) => Math.max(acc, (cur.y + cur.h) * rowHeight), 0);\n}\n\n// tslint:disable-next-line\nexport function parseRenderItemToPixels(renderItem: KtdGridItemRenderData<number>): KtdGridItemRenderData<string> {\n    return {\n        id: renderItem.id,\n        top: `${renderItem.top}px`,\n        left: `${renderItem.left}px`,\n        width: `${renderItem.width}px`,\n        height: `${renderItem.height}px`\n    };\n}\n\n// tslint:disable-next-line:ktd-prefix-code\nexport function __gridItemGetRenderDataFactoryFunc(gridCmp: KtdGridComponent) {\n    // tslint:disable-next-line:only-arrow-functions\n    return function(id: string) {\n        return parseRenderItemToPixels(gridCmp.getItemRenderData(id));\n    };\n}\n\nexport function ktdGridItemGetRenderDataFactoryFunc(gridCmp: KtdGridComponent) {\n    // Workaround explained: https://github.com/ng-packagr/ng-packagr/issues/696#issuecomment-387114613\n    const resultFunc = __gridItemGetRenderDataFactoryFunc(gridCmp);\n    return resultFunc;\n}\n\n\n@Component({\n    selector: 'ktd-grid',\n    templateUrl: './grid.component.html',\n    styleUrls: ['./grid.component.scss'],\n    encapsulation: ViewEncapsulation.None,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    providers: [\n        {\n            provide: GRID_ITEM_GET_RENDER_DATA_TOKEN,\n            useFactory: ktdGridItemGetRenderDataFactoryFunc,\n            deps: [KtdGridComponent]\n        }\n    ]\n})\nexport class KtdGridComponent implements OnChanges, AfterContentInit, AfterContentChecked, OnDestroy {\n    /** Query list of grid items that are being rendered. */\n    @ContentChildren(KtdGridItemComponent, {descendants: true}) _gridItems: QueryList<KtdGridItemComponent>;\n\n    /** Emits when layout change */\n    @Output() layoutUpdated: EventEmitter<KtdGridLayout> = new EventEmitter<KtdGridLayout>();\n\n    /** Emits when drag starts */\n    @Output() dragStarted: EventEmitter<KtdDragStart> = new EventEmitter<KtdDragStart>();\n\n    /** Emits when resize starts */\n    @Output() resizeStarted: EventEmitter<KtdResizeStart> = new EventEmitter<KtdResizeStart>();\n\n    /** Emits when drag ends */\n    @Output() dragEnded: EventEmitter<KtdDragEnd> = new EventEmitter<KtdDragEnd>();\n\n    /** Emits when resize ends */\n    @Output() resizeEnded: EventEmitter<KtdResizeEnd> = new EventEmitter<KtdResizeEnd>();\n\n    /**\n     * Parent element that contains the scroll. If an string is provided it would search that element by id on the dom.\n     * If no data provided or null autoscroll is not performed.\n     */\n    @Input() scrollableParent: HTMLElement | Document | string | null = null;\n\n    /** Whether or not to update the internal layout when some dependent property change. */\n    @Input()\n    get compactOnPropsChange(): boolean { return this._compactOnPropsChange; }\n\n    set compactOnPropsChange(value: boolean) {\n        this._compactOnPropsChange = coerceBooleanProperty(value);\n    }\n\n    private _compactOnPropsChange: boolean = true;\n\n    /** If true, grid items won't change position when being dragged over. Handy when using no compaction */\n    @Input()\n    get preventCollision(): boolean { return this._preventCollision; }\n\n    set preventCollision(value: boolean) {\n        this._preventCollision = coerceBooleanProperty(value);\n    }\n\n    private _preventCollision: boolean = false;\n\n    /** Number of CSS pixels that would be scrolled on each 'tick' when auto scroll is performed. */\n    @Input()\n    get scrollSpeed(): number { return this._scrollSpeed; }\n\n    set scrollSpeed(value: number) {\n        this._scrollSpeed = coerceNumberProperty(value, 2);\n    }\n\n    private _scrollSpeed: number = 2;\n\n    /** Type of compaction that will be applied to the layout (vertical, horizontal or free). Defaults to 'vertical' */\n    @Input()\n    get compactType(): KtdGridCompactType {\n        return this._compactType;\n    }\n\n    set compactType(val: KtdGridCompactType) {\n        this._compactType = val;\n    }\n\n    private _compactType: KtdGridCompactType = 'vertical';\n\n    /** Row height in css pixels */\n    @Input()\n    get rowHeight(): number { return this._rowHeight; }\n\n    set rowHeight(val: number) {\n        this._rowHeight = Math.max(1, Math.round(coerceNumberProperty(val)));\n    }\n\n    private _rowHeight: number = 100;\n\n    /** Number of columns  */\n    @Input()\n    get cols(): number { return this._cols; }\n\n    set cols(val: number) {\n        this._cols = Math.max(1, Math.round(coerceNumberProperty(val)));\n    }\n\n    private _cols: number = 6;\n\n    /** Layout of the grid. Array of all the grid items with its 'id' and position on the grid. */\n    @Input()\n    get layout(): KtdGridLayout { return this._layout; }\n\n    set layout(layout: KtdGridLayout) {\n        /**\n         * Enhancement:\n         * Only set layout if it's reference has changed and use a boolean to track whenever recalculate the layout on ngOnChanges.\n         *\n         * Why:\n         * The normal use of this lib is having the variable layout in the outer component or in a store, assigning it whenever it changes and\n         * binded in the component with it's input [layout]. In this scenario, we would always calculate one unnecessary change on the layout when\n         * it is re-binded on the input.\n         */\n        this._layout = layout;\n    }\n\n    private _layout: KtdGridLayout;\n\n    get config(): KtdGridCfg {\n        return {\n            cols: this.cols,\n            rowHeight: this.rowHeight,\n            layout: this.layout,\n            preventCollision: this.preventCollision,\n        };\n    }\n\n    /** Total height of the grid */\n    private _height: number;\n    private _gridItemsRenderData: KtdDictionary<KtdGridItemRenderData<number>>;\n    private subscriptions: Subscription[];\n\n    constructor(private gridService: KtdGridService,\n                private elementRef: ElementRef,\n                private renderer: Renderer2,\n                private ngZone: NgZone) {\n\n    }\n\n    ngOnChanges(changes: SimpleChanges) {\n        let needsCompactLayout = false;\n        let needsRecalculateRenderData = false;\n\n        // TODO: Does fist change need to be compacted by default?\n        // Compact layout whenever some dependent prop changes.\n        if (changes.compactType || changes.cols || changes.layout) {\n            needsCompactLayout = true;\n        }\n\n        // Check if wee need to recalculate rendering data.\n        if (needsCompactLayout || changes.rowHeight) {\n            needsRecalculateRenderData = true;\n        }\n\n        // Only compact layout if lib user has provided it. Lib users that want to save/store always the same layout  as it is represented (compacted)\n        // can use KtdCompactGrid utility and pre-compact the layout. This is the recommended behaviour for always having a the same layout on this component\n        // and the ones that uses it.\n        if (needsCompactLayout && this.compactOnPropsChange) {\n            this.compactLayout();\n        }\n\n        if (needsRecalculateRenderData) {\n            this.calculateRenderData();\n        }\n    }\n\n    ngAfterContentInit() {\n        this.initSubscriptions();\n    }\n\n    ngAfterContentChecked() {\n        this.render();\n    }\n\n    resize() {\n        this.calculateRenderData();\n        this.render();\n    }\n\n    ngOnDestroy() {\n        this.subscriptions.forEach(sub => sub.unsubscribe());\n    }\n\n    compactLayout() {\n        this.layout = compact(this.layout, this.compactType, this.cols);\n    }\n\n    getItemsRenderData(): KtdDictionary<KtdGridItemRenderData<number>> {\n        return {...this._gridItemsRenderData};\n    }\n\n    getItemRenderData(itemId: string): KtdGridItemRenderData<number> {\n        return this._gridItemsRenderData[itemId];\n    }\n\n    calculateRenderData() {\n        const clientRect = (this.elementRef.nativeElement as HTMLElement).getBoundingClientRect();\n        this._gridItemsRenderData = layoutToRenderItems(this.config, clientRect.width, clientRect.height);\n        this._height = getGridHeight(this.layout, this.rowHeight);\n    }\n\n    render() {\n        this.renderer.setStyle(this.elementRef.nativeElement, 'height', `${this._height}px`);\n        this.updateGridItemsStyles();\n    }\n\n    private updateGridItemsStyles() {\n        this._gridItems.forEach(item => {\n            const gridItemRenderData: KtdGridItemRenderData<number> | undefined = this._gridItemsRenderData[item.id];\n            if (gridItemRenderData == null) {\n                console.error(`Couldn\\'t find the specified grid item for the id: ${item.id}`);\n            } else {\n                item.setStyles(parseRenderItemToPixels(gridItemRenderData));\n            }\n        });\n    }\n\n    private initSubscriptions() {\n        this.subscriptions = [\n            this._gridItems.changes.pipe(\n                startWith(this._gridItems),\n                switchMap((gridItems: QueryList<KtdGridItemComponent>) => {\n                    return merge(\n                        ...gridItems.map((gridItem) => gridItem.dragStart$.pipe(map((event) => ({event, gridItem, type: 'drag'})))),\n                        ...gridItems.map((gridItem) => gridItem.resizeStart$.pipe(map((event) => ({event, gridItem, type: 'resize'})))),\n                    ).pipe(exhaustMap(({event, gridItem, type}) => {\n                        // Emit drag or resize start events. Ensure that is start event is inside the zone.\n                        this.ngZone.run(() => (type === 'drag' ? this.dragStarted : this.resizeStarted).emit(getDragResizeEventData(gridItem, this.layout)));\n                        // Get the correct newStateFunc depending on if we are dragging or resizing\n                        const calcNewStateFunc = type === 'drag' ? ktdGridItemDragging : ktdGridItemResizing;\n\n                        // Perform drag sequence\n                        return this.performDragSequence$(gridItem, event, (gridItemId, config, compactionType, draggingData) =>\n                            calcNewStateFunc(gridItem, config, compactionType, draggingData)\n                        ).pipe(map((layout) => ({layout, gridItem, type})));\n\n                    }));\n                })\n            ).subscribe(({layout, gridItem, type}) => {\n                this.layout = layout;\n                // Calculate new rendering data given the new layout.\n                this.calculateRenderData();\n                // Emit drag or resize end events.\n                (type === 'drag' ? this.dragEnded : this.resizeEnded).emit(getDragResizeEventData(gridItem, layout));\n                // Notify that the layout has been updated.\n                this.layoutUpdated.emit(layout);\n            })\n\n        ];\n    }\n\n    /**\n     * Perform a general grid drag action, from start to end. A general grid drag action basically includes creating the placeholder element and adding\n     * some class animations. calcNewStateFunc needs to be provided in order to calculate the new state of the layout.\n     * @param gridItem that is been dragged\n     * @param pointerDownEvent event (mousedown or touchdown) where the user initiated the drag\n     * @param calcNewStateFunc function that return the new layout state and the drag element position\n     */\n    private performDragSequence$(gridItem: KtdGridItemComponent, pointerDownEvent: MouseEvent | TouchEvent,\n                                 calcNewStateFunc: (gridItem: KtdGridItemComponent, config: KtdGridCfg, compactionType: CompactType, draggingData: KtdDraggingData) => { layout: KtdGridLayoutItem[]; draggedItemPos: KtdGridItemRect }): Observable<KtdGridLayout> {\n\n        return new Observable<KtdGridLayout>((observer: Observer<KtdGridLayout>) => {\n            // Retrieve grid (parent) and gridItem (draggedElem) client rects.\n            const gridElemClientRect: ClientRect = getMutableClientRect(this.elementRef.nativeElement as HTMLElement);\n            const dragElemClientRect: ClientRect = getMutableClientRect(gridItem.elementRef.nativeElement as HTMLElement);\n\n            const scrollableParent = typeof this.scrollableParent === 'string' ? document.getElementById(this.scrollableParent) : this.scrollableParent;\n\n            this.renderer.addClass(gridItem.elementRef.nativeElement, 'no-transitions');\n            this.renderer.addClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging');\n\n            // Create placeholder element. This element would represent the position where the dragged/resized element would be if the action ends\n            const placeholderElement: HTMLDivElement = this.renderer.createElement('div');\n            placeholderElement.style.width = `${dragElemClientRect.width}px`;\n            placeholderElement.style.height = `${dragElemClientRect.height}px`;\n            placeholderElement.style.transform = `translateX(${dragElemClientRect.left - gridElemClientRect.left}px) translateY(${dragElemClientRect.top - gridElemClientRect.top}px)`;\n\n            this.renderer.addClass(placeholderElement, 'ktd-grid-item-placeholder');\n            this.renderer.appendChild(this.elementRef.nativeElement, placeholderElement);\n\n            let newLayout: KtdGridLayoutItem[];\n\n            // TODO (enhancement): consider move this 'side effect' observable inside the main drag loop.\n            //  - Pros are that we would not repeat subscriptions and takeUntil would shut down observables at the same time.\n            //  - Cons are that moving this functionality as a side effect inside the main drag loop would be confusing.\n            const scrollSubscription = this.ngZone.runOutsideAngular(() =>\n                (!scrollableParent ? NEVER : this.gridService.mouseOrTouchMove$(document).pipe(\n                    map((event) => ({\n                        pointerX: ktdPointerClientX(event),\n                        pointerY: ktdPointerClientY(event)\n                    })),\n                    ktdScrollIfNearElementClientRect$(scrollableParent, {scrollStep: this.scrollSpeed})\n                )).pipe(\n                    takeUntil(ktdMouseOrTouchEnd(document))\n                ).subscribe());\n\n            /**\n             * Main subscription, it listens for 'pointer move' and 'scroll' events and recalculates the layout on each emission\n             */\n            const subscription = this.ngZone.runOutsideAngular(() =>\n                merge(\n                    combineLatest([\n                        this.gridService.mouseOrTouchMove$(document),\n                        ...(!scrollableParent ? [of({top: 0, left: 0})] : [\n                            ktdGetScrollTotalRelativeDifference$(scrollableParent).pipe(\n                                startWith({top: 0, left: 0}) // Force first emission to allow CombineLatest to emit even no scroll event has occurred\n                            )\n                        ])\n                    ])\n                ).pipe(\n                    takeUntil(ktdMouseOrTouchEnd(document)),\n                ).subscribe(([pointerDragEvent, scrollDifference]: [MouseEvent | TouchEvent, { top: number, left: number }]) => {\n                        pointerDragEvent.preventDefault();\n\n                        /**\n                         * Set the new layout to be the layout in which the calcNewStateFunc would be executed.\n                         * NOTE: using the mutated layout is the way to go by 'react-grid-layout' utils. If we don't use the previous layout,\n                         * some utilities from 'react-grid-layout' would not work as expected.\n                         */\n                        const currentLayout: KtdGridLayout = newLayout || this.layout;\n\n                        const {layout, draggedItemPos} = calcNewStateFunc(gridItem, {\n                            layout: currentLayout,\n                            rowHeight: this.rowHeight,\n                            cols: this.cols,\n                            preventCollision: this.preventCollision\n                        }, this.compactType, {\n                            pointerDownEvent,\n                            pointerDragEvent,\n                            gridElemClientRect,\n                            dragElemClientRect,\n                            scrollDifference\n                        });\n                        newLayout = layout;\n\n                        this._height = getGridHeight(newLayout, this.rowHeight);\n\n                        this._gridItemsRenderData = layoutToRenderItems({\n                            cols: this.cols,\n                            rowHeight: this.rowHeight,\n                            layout: newLayout,\n                            preventCollision: this.preventCollision,\n                        }, gridElemClientRect.width, gridElemClientRect.height);\n\n                        const placeholderStyles = parseRenderItemToPixels(this._gridItemsRenderData[gridItem.id]);\n\n                        // Put the real final position to the placeholder element\n                        placeholderElement.style.width = placeholderStyles.width;\n                        placeholderElement.style.height = placeholderStyles.height;\n                        placeholderElement.style.transform = `translateX(${placeholderStyles.left}) translateY(${placeholderStyles.top})`;\n\n                        // modify the position of the dragged item to be the once we want (for example the mouse position or whatever)\n                        this._gridItemsRenderData[gridItem.id] = {\n                            ...draggedItemPos,\n                            id: this._gridItemsRenderData[gridItem.id].id\n                        };\n\n                        this.render();\n                    },\n                    (error) => observer.error(error),\n                    () => {\n                        this.ngZone.run(() => {\n                            // Remove drag classes\n                            this.renderer.removeClass(gridItem.elementRef.nativeElement, 'no-transitions');\n                            this.renderer.removeClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging');\n\n                            // Remove placeholder element from the dom\n                            // NOTE: If we don't put the removeChild inside the zone it would not work... This may be a bug from angular or maybe is the intended behaviour, although strange.\n                            // It should work since AFAIK this action should not be done in a CD cycle.\n                            this.renderer.removeChild(this.elementRef.nativeElement, placeholderElement);\n\n                            if (newLayout) {\n                                // TODO: newLayout should already be pruned. If not, it should have type Layout, not KtdGridLayout as it is now.\n                                // Prune react-grid-layout compact extra properties.\n                                observer.next(newLayout.map(item => ({\n                                    id: item.id,\n                                    x: item.x,\n                                    y: item.y,\n                                    w: item.w,\n                                    h: item.h,\n                                    minW: item.minW,\n                                    minH: item.minH,\n                                    maxW: item.maxW,\n                                    maxH: item.maxH,\n                                })) as KtdGridLayout);\n                            } else {\n                                // TODO: Need we really to emit if there is no layout change but drag started and ended?\n                                observer.next(this.layout);\n                            }\n\n                            observer.complete();\n                        });\n\n                    }));\n\n\n            return () => {\n                scrollSubscription.unsubscribe();\n                subscription.unsubscribe();\n            };\n        });\n    }\n\n\n    // tslint:disable-next-line\n    static ngAcceptInputType_cols: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_rowHeight: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_scrollSpeed: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_compactOnPropsChange: BooleanInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_preventCollision: BooleanInput;\n}\n\n","<ng-content></ng-content>\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { KtdGridComponent } from './grid.component';\nimport { KtdGridItemComponent } from './grid-item/grid-item.component';\nimport { KtdGridDragHandle } from './directives/drag-handle';\nimport { KtdGridResizeHandle } from './directives/resize-handle';\nimport { KtdGridService } from './grid.service';\n\n@NgModule({\n    declarations: [\n        KtdGridComponent,\n        KtdGridItemComponent,\n        KtdGridDragHandle,\n        KtdGridResizeHandle\n    ],\n    exports: [\n        KtdGridComponent,\n        KtdGridItemComponent,\n        KtdGridDragHandle,\n        KtdGridResizeHandle\n    ],\n    providers: [\n        KtdGridService\n    ],\n    imports: [\n        CommonModule\n    ]\n})\nexport class KtdGridModule {}\n","/*\n * Public API Surface of grid\n */\nexport { ktdGridCompact, ktdTrackById } from './lib/utils/grid.utils';\nexport * from './lib/directives/drag-handle';\nexport * from './lib/directives/resize-handle';\nexport * from './lib/grid-item/grid-item.component';\nexport * from './lib/grid.definitions';\nexport * from './lib/grid.component';\nexport * from './lib/grid.module';\n\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["i1.KtdGridService"],"mappings":"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"}},"fesm2015":{"code":"import { iif, fromEvent, merge, Observable, Subject, BehaviorSubject, NEVER, interval, animationFrameScheduler, combineLatest, of } from 'rxjs';\nimport { filter, switchMap, startWith, exhaustMap, takeUntil, take, map, tap, distinctUntilChanged } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Directive, Injectable, ElementRef, Component, ChangeDetectionStrategy, Inject, ContentChildren, ViewChild, Input, EventEmitter, ViewEncapsulation, Output, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n/**\r\n * IMPORTANT:\r\n * This utils are taken from the project: https://github.com/STRML/react-grid-layout.\r\n * The code should be as less modified as possible for easy maintenance.\r\n */\r\nconst DEBUG = false;\r\n/**\r\n * Return the bottom coordinate of the layout.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @return {Number}       Bottom coordinate.\r\n */\r\nfunction bottom(layout) {\r\n    let max = 0, bottomY;\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        bottomY = layout[i].y + layout[i].h;\r\n        if (bottomY > max) {\r\n            max = bottomY;\r\n        }\r\n    }\r\n    return max;\r\n}\r\nfunction cloneLayout(layout) {\r\n    const newLayout = Array(layout.length);\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        newLayout[i] = cloneLayoutItem(layout[i]);\r\n    }\r\n    return newLayout;\r\n}\r\n// Fast path to cloning, since this is monomorphic\r\n/** NOTE: This code has been modified from the original source */\r\nfunction cloneLayoutItem(layoutItem) {\r\n    const clonedLayoutItem = {\r\n        w: layoutItem.w,\r\n        h: layoutItem.h,\r\n        x: layoutItem.x,\r\n        y: layoutItem.y,\r\n        id: layoutItem.id,\r\n        moved: !!layoutItem.moved,\r\n        static: !!layoutItem.static,\r\n    };\r\n    if (layoutItem.minW !== undefined) {\r\n        clonedLayoutItem.minW = layoutItem.minW;\r\n    }\r\n    if (layoutItem.maxW !== undefined) {\r\n        clonedLayoutItem.maxW = layoutItem.maxW;\r\n    }\r\n    if (layoutItem.minH !== undefined) {\r\n        clonedLayoutItem.minH = layoutItem.minH;\r\n    }\r\n    if (layoutItem.maxH !== undefined) {\r\n        clonedLayoutItem.maxH = layoutItem.maxH;\r\n    }\r\n    // These can be null\r\n    if (layoutItem.isDraggable !== undefined) {\r\n        clonedLayoutItem.isDraggable = layoutItem.isDraggable;\r\n    }\r\n    if (layoutItem.isResizable !== undefined) {\r\n        clonedLayoutItem.isResizable = layoutItem.isResizable;\r\n    }\r\n    return clonedLayoutItem;\r\n}\r\n/**\r\n * Given two layoutitems, check if they collide.\r\n */\r\nfunction collides(l1, l2) {\r\n    if (l1.id === l2.id) {\r\n        return false;\r\n    } // same element\r\n    if (l1.x + l1.w <= l2.x) {\r\n        return false;\r\n    } // l1 is left of l2\r\n    if (l1.x >= l2.x + l2.w) {\r\n        return false;\r\n    } // l1 is right of l2\r\n    if (l1.y + l1.h <= l2.y) {\r\n        return false;\r\n    } // l1 is above l2\r\n    if (l1.y >= l2.y + l2.h) {\r\n        return false;\r\n    } // l1 is below l2\r\n    return true; // boxes overlap\r\n}\r\n/**\r\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\r\n * between items.\r\n *\r\n * @param  {Array} layout Layout.\r\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\r\n *   vertically.\r\n * @return {Array}       Compacted Layout.\r\n */\r\nfunction compact(layout, compactType, cols) {\r\n    // Statics go in the compareWith array right away so items flow around them.\r\n    const compareWith = getStatics(layout);\r\n    // We go through the items by row and column.\r\n    const sorted = sortLayoutItems(layout, compactType);\r\n    // Holding for new items.\r\n    const out = Array(layout.length);\r\n    for (let i = 0, len = sorted.length; i < len; i++) {\r\n        let l = cloneLayoutItem(sorted[i]);\r\n        // Don't move static elements\r\n        if (!l.static) {\r\n            l = compactItem(compareWith, l, compactType, cols, sorted);\r\n            // Add to comparison array. We only collide with items before this one.\r\n            // Statics are already in this array.\r\n            compareWith.push(l);\r\n        }\r\n        // Add to output array to make sure they still come out in the right order.\r\n        out[layout.indexOf(sorted[i])] = l;\r\n        // Clear moved flag, if it exists.\r\n        l.moved = false;\r\n    }\r\n    return out;\r\n}\r\nconst heightWidth = { x: 'w', y: 'h' };\r\n/**\r\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\r\n */\r\nfunction resolveCompactionCollision(layout, item, moveToCoord, axis) {\r\n    const sizeProp = heightWidth[axis];\r\n    item[axis] += 1;\r\n    const itemIndex = layout\r\n        .map(layoutItem => {\r\n        return layoutItem.id;\r\n    })\r\n        .indexOf(item.id);\r\n    // Go through each item we collide with.\r\n    for (let i = itemIndex + 1; i < layout.length; i++) {\r\n        const otherItem = layout[i];\r\n        // Ignore static items\r\n        if (otherItem.static) {\r\n            continue;\r\n        }\r\n        // Optimization: we can break early if we know we're past this el\r\n        // We can do this b/c it's a sorted layout\r\n        if (otherItem.y > item.y + item.h) {\r\n            break;\r\n        }\r\n        if (collides(item, otherItem)) {\r\n            resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\r\n        }\r\n    }\r\n    item[axis] = moveToCoord;\r\n}\r\n/**\r\n * Compact an item in the layout.\r\n */\r\nfunction compactItem(compareWith, l, compactType, cols, fullLayout) {\r\n    const compactV = compactType === 'vertical';\r\n    const compactH = compactType === 'horizontal';\r\n    if (compactV) {\r\n        // Bottom 'y' possible is the bottom of the layout.\r\n        // This allows you to do nice stuff like specify {y: Infinity}\r\n        // This is here because the layout must be sorted in order to get the correct bottom `y`.\r\n        l.y = Math.min(bottom(compareWith), l.y);\r\n        // Move the element up as far as it can go without colliding.\r\n        while (l.y > 0 && !getFirstCollision(compareWith, l)) {\r\n            l.y--;\r\n        }\r\n    }\r\n    else if (compactH) {\r\n        l.y = Math.min(bottom(compareWith), l.y);\r\n        // Move the element left as far as it can go without colliding.\r\n        while (l.x > 0 && !getFirstCollision(compareWith, l)) {\r\n            l.x--;\r\n        }\r\n    }\r\n    // Move it down, and keep moving it down if it's colliding.\r\n    let collides;\r\n    while ((collides = getFirstCollision(compareWith, l))) {\r\n        if (compactH) {\r\n            resolveCompactionCollision(fullLayout, l, collides.x + collides.w, 'x');\r\n        }\r\n        else {\r\n            resolveCompactionCollision(fullLayout, l, collides.y + collides.h, 'y');\r\n        }\r\n        // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\r\n        if (compactH && l.x + l.w > cols) {\r\n            l.x = cols - l.w;\r\n            l.y++;\r\n        }\r\n    }\r\n    return l;\r\n}\r\n/**\r\n * Given a layout, make sure all elements fit within its bounds.\r\n *\r\n * @param  {Array} layout Layout array.\r\n * @param  {Number} bounds Number of columns.\r\n */\r\nfunction correctBounds(layout, bounds) {\r\n    const collidesWith = getStatics(layout);\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        const l = layout[i];\r\n        // Overflows right\r\n        if (l.x + l.w > bounds.cols) {\r\n            l.x = bounds.cols - l.w;\r\n        }\r\n        // Overflows left\r\n        if (l.x < 0) {\r\n            l.x = 0;\r\n            l.w = bounds.cols;\r\n        }\r\n        if (!l.static) {\r\n            collidesWith.push(l);\r\n        }\r\n        else {\r\n            // If this is static and collides with other statics, we must move it down.\r\n            // We have to do something nicer than just letting them overlap.\r\n            while (getFirstCollision(collidesWith, l)) {\r\n                l.y++;\r\n            }\r\n        }\r\n    }\r\n    return layout;\r\n}\r\n/**\r\n * Get a layout item by ID. Used so we can override later on if necessary.\r\n *\r\n * @param  {Array}  layout Layout array.\r\n * @param  {String} id     ID\r\n * @return {LayoutItem}    Item at ID.\r\n */\r\nfunction getLayoutItem(layout, id) {\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        if (layout[i].id === id) {\r\n            return layout[i];\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Returns the first item this layout collides with.\r\n * It doesn't appear to matter which order we approach this from, although\r\n * perhaps that is the wrong thing to do.\r\n *\r\n * @param  {Object} layoutItem Layout item.\r\n * @return {Object|undefined}  A colliding layout item, or undefined.\r\n */\r\nfunction getFirstCollision(layout, layoutItem) {\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        if (collides(layout[i], layoutItem)) {\r\n            return layout[i];\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction getAllCollisions(layout, layoutItem) {\r\n    return layout.filter(l => collides(l, layoutItem));\r\n}\r\n/**\r\n * Get all static elements.\r\n * @param  {Array} layout Array of layout objects.\r\n * @return {Array}        Array of static layout items..\r\n */\r\nfunction getStatics(layout) {\r\n    return layout.filter(l => l.static);\r\n}\r\n/**\r\n * Move an element. Responsible for doing cascading movements of other elements.\r\n *\r\n * @param  {Array}      layout            Full layout to modify.\r\n * @param  {LayoutItem} l                 element to move.\r\n * @param  {Number}     [x]               X position in grid units.\r\n * @param  {Number}     [y]               Y position in grid units.\r\n */\r\nfunction moveElement(layout, l, x, y, isUserAction, preventCollision, compactType, cols) {\r\n    // If this is static and not explicitly enabled as draggable,\r\n    // no move is possible, so we can short-circuit this immediately.\r\n    if (l.static && l.isDraggable !== true) {\r\n        return layout;\r\n    }\r\n    // Short-circuit if nothing to do.\r\n    if (l.y === y && l.x === x) {\r\n        return layout;\r\n    }\r\n    log(`Moving element ${l.id} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);\r\n    const oldX = l.x;\r\n    const oldY = l.y;\r\n    // This is quite a bit faster than extending the object\r\n    if (typeof x === 'number') {\r\n        l.x = x;\r\n    }\r\n    if (typeof y === 'number') {\r\n        l.y = y;\r\n    }\r\n    l.moved = true;\r\n    // If this collides with anything, move it.\r\n    // When doing this comparison, we have to sort the items we compare with\r\n    // to ensure, in the case of multiple collisions, that we're getting the\r\n    // nearest collision.\r\n    let sorted = sortLayoutItems(layout, compactType);\r\n    const movingUp = compactType === 'vertical' && typeof y === 'number'\r\n        ? oldY >= y\r\n        : compactType === 'horizontal' && typeof x === 'number'\r\n            ? oldX >= x\r\n            : false;\r\n    if (movingUp) {\r\n        sorted = sorted.reverse();\r\n    }\r\n    const collisions = getAllCollisions(sorted, l);\r\n    // There was a collision; abort\r\n    if (preventCollision && collisions.length) {\r\n        log(`Collision prevented on ${l.id}, reverting.`);\r\n        l.x = oldX;\r\n        l.y = oldY;\r\n        l.moved = false;\r\n        return layout;\r\n    }\r\n    // Move each item that collides away from this element.\r\n    for (let i = 0, len = collisions.length; i < len; i++) {\r\n        const collision = collisions[i];\r\n        log(`Resolving collision between ${l.id} at [${l.x},${l.y}] and ${collision.id} at [${collision.x},${collision.y}]`);\r\n        // Short circuit so we can't infinite loop\r\n        if (collision.moved) {\r\n            continue;\r\n        }\r\n        // Don't move static items - we have to move *this* element away\r\n        if (collision.static) {\r\n            layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\r\n        }\r\n        else {\r\n            layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\r\n        }\r\n    }\r\n    return layout;\r\n}\r\n/**\r\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\r\n * We attempt to move it up if there's room, otherwise it goes below.\r\n *\r\n * @param  {Array} layout            Full layout to modify.\r\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\r\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\r\n */\r\nfunction moveElementAwayFromCollision(layout, collidesWith, itemToMove, isUserAction, compactType, cols) {\r\n    const compactH = compactType === 'horizontal';\r\n    // Compact vertically if not set to horizontal\r\n    const compactV = compactType !== 'horizontal';\r\n    const preventCollision = collidesWith.static; // we're already colliding (not for static items)\r\n    // If there is enough space above the collision to put this element, move it there.\r\n    // We only do this on the main collision as this can get funky in cascades and cause\r\n    // unwanted swapping behavior.\r\n    if (isUserAction) {\r\n        // Reset isUserAction flag because we're not in the main collision anymore.\r\n        isUserAction = false;\r\n        // Make a mock item so we don't modify the item here, only modify in moveElement.\r\n        const fakeItem = {\r\n            x: compactH\r\n                ? Math.max(collidesWith.x - itemToMove.w, 0)\r\n                : itemToMove.x,\r\n            y: compactV\r\n                ? Math.max(collidesWith.y - itemToMove.h, 0)\r\n                : itemToMove.y,\r\n            w: itemToMove.w,\r\n            h: itemToMove.h,\r\n            id: '-1',\r\n        };\r\n        // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\r\n        if (!getFirstCollision(layout, fakeItem)) {\r\n            log(`Doing reverse collision on ${itemToMove.id} up to [${fakeItem.x},${fakeItem.y}].`);\r\n            return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\r\n        }\r\n    }\r\n    return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\r\n}\r\n/**\r\n * Helper to convert a number to a percentage string.\r\n *\r\n * @param  {Number} num Any number\r\n * @return {String}     That number as a percentage.\r\n */\r\nfunction perc(num) {\r\n    return num * 100 + '%';\r\n}\r\nfunction setTransform({ top, left, width, height }) {\r\n    // Replace unitless items with px\r\n    const translate = `translate(${left}px,${top}px)`;\r\n    return {\r\n        transform: translate,\r\n        WebkitTransform: translate,\r\n        MozTransform: translate,\r\n        msTransform: translate,\r\n        OTransform: translate,\r\n        width: `${width}px`,\r\n        height: `${height}px`,\r\n        position: 'absolute',\r\n    };\r\n}\r\nfunction setTopLeft({ top, left, width, height }) {\r\n    return {\r\n        top: `${top}px`,\r\n        left: `${left}px`,\r\n        width: `${width}px`,\r\n        height: `${height}px`,\r\n        position: 'absolute',\r\n    };\r\n}\r\n/**\r\n * Get layout items sorted from top left to right and down.\r\n *\r\n * @return {Array} Array of layout objects.\r\n * @return {Array}        Layout, sorted static items first.\r\n */\r\nfunction sortLayoutItems(layout, compactType) {\r\n    if (compactType === 'horizontal') {\r\n        return sortLayoutItemsByColRow(layout);\r\n    }\r\n    else {\r\n        return sortLayoutItemsByRowCol(layout);\r\n    }\r\n}\r\nfunction sortLayoutItemsByRowCol(layout) {\r\n    return [].concat(layout).sort(function (a, b) {\r\n        if (a.y > b.y || (a.y === b.y && a.x > b.x)) {\r\n            return 1;\r\n        }\r\n        else if (a.y === b.y && a.x === b.x) {\r\n            // Without this, we can get different sort results in IE vs. Chrome/FF\r\n            return 0;\r\n        }\r\n        return -1;\r\n    });\r\n}\r\nfunction sortLayoutItemsByColRow(layout) {\r\n    return [].concat(layout).sort(function (a, b) {\r\n        if (a.x > b.x || (a.x === b.x && a.y > b.y)) {\r\n            return 1;\r\n        }\r\n        return -1;\r\n    });\r\n}\r\n/**\r\n * Validate a layout. Throws errors.\r\n *\r\n * @param  {Array}  layout        Array of layout items.\r\n * @param  {String} [contextName] Context name for errors.\r\n * @throw  {Error}                Validation error.\r\n */\r\nfunction validateLayout(layout, contextName = 'Layout') {\r\n    const subProps = ['x', 'y', 'w', 'h'];\r\n    if (!Array.isArray(layout)) {\r\n        throw new Error(contextName + ' must be an array!');\r\n    }\r\n    for (let i = 0, len = layout.length; i < len; i++) {\r\n        const item = layout[i];\r\n        for (let j = 0; j < subProps.length; j++) {\r\n            if (typeof item[subProps[j]] !== 'number') {\r\n                throw new Error('ReactGridLayout: ' +\r\n                    contextName +\r\n                    '[' +\r\n                    i +\r\n                    '].' +\r\n                    subProps[j] +\r\n                    ' must be a number!');\r\n            }\r\n        }\r\n        if (item.id && typeof item.id !== 'string') {\r\n            throw new Error('ReactGridLayout: ' +\r\n                contextName +\r\n                '[' +\r\n                i +\r\n                '].i must be a string!');\r\n        }\r\n        if (item.static !== undefined && typeof item.static !== 'boolean') {\r\n            throw new Error('ReactGridLayout: ' +\r\n                contextName +\r\n                '[' +\r\n                i +\r\n                '].static must be a boolean!');\r\n        }\r\n    }\r\n}\r\n// Flow can't really figure this out, so we just use Object\r\nfunction autoBindHandlers(el, fns) {\r\n    fns.forEach(key => (el[key] = el[key].bind(el)));\r\n}\r\nfunction log(...args) {\r\n    if (!DEBUG) {\r\n        return;\r\n    }\r\n    // eslint-disable-next-line no-console\r\n    console.log(...args);\r\n}\r\nconst noop = () => { };\n\n/** Cached result of whether the user's browser supports passive event listeners. */\r\nlet supportsPassiveEvents;\r\n/**\r\n * Checks whether the user's browser supports passive event listeners.\r\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\r\n */\r\nfunction ktdSupportsPassiveEventListeners() {\r\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\r\n        try {\r\n            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\r\n                get: () => supportsPassiveEvents = true\r\n            }));\r\n        }\r\n        finally {\r\n            supportsPassiveEvents = supportsPassiveEvents || false;\r\n        }\r\n    }\r\n    return supportsPassiveEvents;\r\n}\r\n/**\r\n * Normalizes an `AddEventListener` object to something that can be passed\r\n * to `addEventListener` on any browser, no matter whether it supports the\r\n * `options` parameter.\r\n * @param options Object to be normalized.\r\n */\r\nfunction ktdNormalizePassiveListenerOptions(options) {\r\n    return ktdSupportsPassiveEventListeners() ? options : !!options.capture;\r\n}\n\n/** Options that can be used to bind a passive event listener. */\r\nconst passiveEventListenerOptions = ktdNormalizePassiveListenerOptions({ passive: true });\r\n/** Options that can be used to bind an active event listener. */\r\nconst activeEventListenerOptions = ktdNormalizePassiveListenerOptions({ passive: false });\r\nlet isMobile = null;\r\nfunction ktdIsMobileOrTablet() {\r\n    if (isMobile != null) {\r\n        return isMobile;\r\n    }\r\n    // Generic match pattern to identify mobile or tablet devices\r\n    const isMobileDevice = /Android|webOS|BlackBerry|Windows Phone|iPad|iPhone|iPod/i.test(navigator.userAgent);\r\n    // Since IOS 13 is not safe to just check for the generic solution. See: https://stackoverflow.com/questions/58019463/how-to-detect-device-name-in-safari-on-ios-13-while-it-doesnt-show-the-correct\r\n    const isIOSMobileDevice = /iPad|iPhone|iPod/.test(navigator.platform) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);\r\n    isMobile = isMobileDevice || isIOSMobileDevice;\r\n    return isMobile;\r\n}\r\nfunction ktdIsMouseEvent(event) {\r\n    return event.clientX != null;\r\n}\r\nfunction ktdIsTouchEvent(event) {\r\n    return event.touches != null && event.touches.length != null;\r\n}\r\nfunction ktdPointerClientX(event) {\r\n    return ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX;\r\n}\r\nfunction ktdPointerClientY(event) {\r\n    return ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY;\r\n}\r\nfunction ktdPointerClient(event) {\r\n    return {\r\n        clientX: ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX,\r\n        clientY: ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY\r\n    };\r\n}\r\n/**\r\n * Emits when a mousedown or touchstart emits. Avoids conflicts between both events.\r\n * @param element, html element where to  listen the events.\r\n * @param touchNumber number of the touch to track the event, default to the first one.\r\n */\r\nfunction ktdMouseOrTouchDown(element, touchNumber = 1) {\r\n    return iif(() => ktdIsMobileOrTablet(), fromEvent(element, 'touchstart', passiveEventListenerOptions).pipe(filter((touchEvent) => touchEvent.touches.length === touchNumber)), fromEvent(element, 'mousedown', activeEventListenerOptions).pipe(filter((mouseEvent) => {\r\n        /**\r\n         * 0 : Left mouse button\r\n         * 1 : Wheel button or middle button (if present)\r\n         * 2 : Right mouse button\r\n         */\r\n        return mouseEvent.button === 0; // Mouse down to be only fired if is left click\r\n    })));\r\n}\r\n/**\r\n * Emits when a 'mousemove' or a 'touchmove' event gets fired.\r\n * @param element, html element where to  listen the events.\r\n * @param touchNumber number of the touch to track the event, default to the first one.\r\n */\r\nfunction ktdMouseOrTouchMove(element, touchNumber = 1) {\r\n    return iif(() => ktdIsMobileOrTablet(), fromEvent(element, 'touchmove', activeEventListenerOptions).pipe(filter((touchEvent) => touchEvent.touches.length === touchNumber)), fromEvent(element, 'mousemove', activeEventListenerOptions));\r\n}\r\nfunction ktdTouchEnd(element, touchNumber = 1) {\r\n    return merge(fromEvent(element, 'touchend').pipe(filter((touchEvent) => touchEvent.touches.length === touchNumber - 1)), fromEvent(element, 'touchcancel').pipe(filter((touchEvent) => touchEvent.touches.length === touchNumber - 1)));\r\n}\r\n/**\r\n * Emits when a there is a 'mouseup' or the touch ends.\r\n * @param element, html element where to  listen the events.\r\n * @param touchNumber number of the touch to track the event, default to the first one.\r\n */\r\nfunction ktdMouseOrTouchEnd(element, touchNumber = 1) {\r\n    return iif(() => ktdIsMobileOrTablet(), ktdTouchEnd(element, touchNumber), fromEvent(element, 'mouseup'));\r\n}\n\n/** Tracks items by id. This function is mean to be used in conjunction with the ngFor that renders the 'ktd-grid-items' */\r\nfunction ktdTrackById(index, item) {\r\n    return item.id;\r\n}\r\n/**\r\n * Call react-grid-layout utils 'compact()' function and return the compacted layout.\r\n * @param layout to be compacted.\r\n * @param compactType, type of compaction.\r\n * @param cols, number of columns of the grid.\r\n */\r\nfunction ktdGridCompact(layout, compactType, cols) {\r\n    return compact(layout, compactType, cols)\r\n        // Prune react-grid-layout compact extra properties.\r\n        .map(item => ({ id: item.id, x: item.x, y: item.y, w: item.w, h: item.h, minW: item.minW, minH: item.minH, maxW: item.maxW, maxH: item.maxH }));\r\n}\r\nfunction screenXPosToGridValue(screenXPos, cols, width) {\r\n    return Math.round((screenXPos * cols) / width);\r\n}\r\nfunction screenYPosToGridValue(screenYPos, rowHeight, height) {\r\n    return Math.round(screenYPos / rowHeight);\r\n}\r\n/** Returns a Dictionary where the key is the id and the value is the change applied to that item. If no changes Dictionary is empty. */\r\nfunction ktdGetGridLayoutDiff(gridLayoutA, gridLayoutB) {\r\n    const diff = {};\r\n    gridLayoutA.forEach(itemA => {\r\n        const itemB = gridLayoutB.find(_itemB => _itemB.id === itemA.id);\r\n        if (itemB != null) {\r\n            const posChanged = itemA.x !== itemB.x || itemA.y !== itemB.y;\r\n            const sizeChanged = itemA.w !== itemB.w || itemA.h !== itemB.h;\r\n            const change = posChanged && sizeChanged ? 'moveresize' : posChanged ? 'move' : sizeChanged ? 'resize' : null;\r\n            if (change) {\r\n                diff[itemB.id] = { change };\r\n            }\r\n        }\r\n    });\r\n    return diff;\r\n}\r\n/**\r\n * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position\r\n * @param gridItem grid item that is been dragged\r\n * @param config current grid configuration\r\n * @param compactionType type of compaction that will be performed\r\n * @param draggingData contains all the information about the drag\r\n */\r\nfunction ktdGridItemDragging(gridItem, config, compactionType, draggingData) {\r\n    const { pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference } = draggingData;\r\n    const gridItemId = gridItem.id;\r\n    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId);\r\n    const clientStartX = ktdPointerClientX(pointerDownEvent);\r\n    const clientStartY = ktdPointerClientY(pointerDownEvent);\r\n    const clientX = ktdPointerClientX(pointerDragEvent);\r\n    const clientY = ktdPointerClientY(pointerDragEvent);\r\n    const offsetX = clientStartX - dragElemClientRect.left;\r\n    const offsetY = clientStartY - dragElemClientRect.top;\r\n    // Grid element positions taking into account the possible scroll total difference from the beginning.\r\n    const gridElementLeftPosition = gridElemClientRect.left + scrollDifference.left;\r\n    const gridElementTopPosition = gridElemClientRect.top + scrollDifference.top;\r\n    // Calculate position relative to the grid element.\r\n    const gridRelXPos = clientX - gridElementLeftPosition - offsetX;\r\n    const gridRelYPos = clientY - gridElementTopPosition - offsetY;\r\n    // Get layout item position\r\n    const layoutItem = Object.assign(Object.assign({}, draggingElemPrevItem), { x: screenXPosToGridValue(gridRelXPos, config.cols, gridElemClientRect.width), y: screenYPosToGridValue(gridRelYPos, config.rowHeight, gridElemClientRect.height) });\r\n    // Correct the values if they overflow, since 'moveElement' function doesn't do it\r\n    layoutItem.x = Math.max(0, layoutItem.x);\r\n    layoutItem.y = Math.max(0, layoutItem.y);\r\n    if (layoutItem.x + layoutItem.w > config.cols) {\r\n        layoutItem.x = Math.max(0, config.cols - layoutItem.w);\r\n    }\r\n    // Parse to LayoutItem array data in order to use 'react.grid-layout' utils\r\n    const layoutItems = config.layout;\r\n    const draggedLayoutItem = layoutItems.find(item => item.id === gridItemId);\r\n    let newLayoutItems = moveElement(layoutItems, draggedLayoutItem, layoutItem.x, layoutItem.y, true, config.preventCollision, compactionType, config.cols);\r\n    newLayoutItems = compact(newLayoutItems, compactionType, config.cols);\r\n    return {\r\n        layout: newLayoutItems,\r\n        draggedItemPos: {\r\n            top: gridRelYPos,\r\n            left: gridRelXPos,\r\n            width: dragElemClientRect.width,\r\n            height: dragElemClientRect.height,\r\n        }\r\n    };\r\n}\r\n/**\r\n * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position\r\n * @param gridItem grid item that is been dragged\r\n * @param config current grid configuration\r\n * @param compactionType type of compaction that will be performed\r\n * @param draggingData contains all the information about the drag\r\n */\r\nfunction ktdGridItemResizing(gridItem, config, compactionType, draggingData) {\r\n    var _a, _b, _c, _d;\r\n    const { pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference } = draggingData;\r\n    const gridItemId = gridItem.id;\r\n    const clientStartX = ktdPointerClientX(pointerDownEvent);\r\n    const clientStartY = ktdPointerClientY(pointerDownEvent);\r\n    const clientX = ktdPointerClientX(pointerDragEvent);\r\n    const clientY = ktdPointerClientY(pointerDragEvent);\r\n    // Get the difference between the mouseDown and the position 'right' of the resize element.\r\n    const resizeElemOffsetX = dragElemClientRect.width - (clientStartX - dragElemClientRect.left);\r\n    const resizeElemOffsetY = dragElemClientRect.height - (clientStartY - dragElemClientRect.top);\r\n    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId);\r\n    const width = clientX + resizeElemOffsetX - (dragElemClientRect.left + scrollDifference.left);\r\n    const height = clientY + resizeElemOffsetY - (dragElemClientRect.top + scrollDifference.top);\r\n    // Get layout item grid position\r\n    const layoutItem = Object.assign(Object.assign({}, draggingElemPrevItem), { w: screenXPosToGridValue(width, config.cols, gridElemClientRect.width), h: screenYPosToGridValue(height, config.rowHeight, gridElemClientRect.height) });\r\n    layoutItem.w = limitNumberWithinRange(layoutItem.w, (_a = gridItem.minW) !== null && _a !== void 0 ? _a : layoutItem.minW, (_b = gridItem.maxW) !== null && _b !== void 0 ? _b : layoutItem.maxW);\r\n    layoutItem.h = limitNumberWithinRange(layoutItem.h, (_c = gridItem.minH) !== null && _c !== void 0 ? _c : layoutItem.minH, (_d = gridItem.maxH) !== null && _d !== void 0 ? _d : layoutItem.maxH);\r\n    if (layoutItem.x + layoutItem.w > config.cols) {\r\n        layoutItem.w = Math.max(1, config.cols - layoutItem.x);\r\n    }\r\n    if (config.preventCollision) {\r\n        const maxW = layoutItem.w;\r\n        const maxH = layoutItem.h;\r\n        let colliding = hasCollision(config.layout, layoutItem);\r\n        let shrunkDimension;\r\n        while (colliding) {\r\n            shrunkDimension = getDimensionToShrink(layoutItem, shrunkDimension);\r\n            layoutItem[shrunkDimension]--;\r\n            colliding = hasCollision(config.layout, layoutItem);\r\n        }\r\n        if (shrunkDimension === 'w') {\r\n            layoutItem.h = maxH;\r\n            colliding = hasCollision(config.layout, layoutItem);\r\n            while (colliding) {\r\n                layoutItem.h--;\r\n                colliding = hasCollision(config.layout, layoutItem);\r\n            }\r\n        }\r\n        if (shrunkDimension === 'h') {\r\n            layoutItem.w = maxW;\r\n            colliding = hasCollision(config.layout, layoutItem);\r\n            while (colliding) {\r\n                layoutItem.w--;\r\n                colliding = hasCollision(config.layout, layoutItem);\r\n            }\r\n        }\r\n    }\r\n    const newLayoutItems = config.layout.map((item) => {\r\n        return item.id === gridItemId ? layoutItem : item;\r\n    });\r\n    return {\r\n        layout: compact(newLayoutItems, compactionType, config.cols),\r\n        draggedItemPos: {\r\n            top: dragElemClientRect.top - gridElemClientRect.top,\r\n            left: dragElemClientRect.left - gridElemClientRect.left,\r\n            width,\r\n            height,\r\n        }\r\n    };\r\n}\r\nfunction hasCollision(layout, layoutItem) {\r\n    return !!getFirstCollision(layout, layoutItem);\r\n}\r\nfunction getDimensionToShrink(layoutItem, lastShrunk) {\r\n    if (layoutItem.h <= 1) {\r\n        return 'w';\r\n    }\r\n    if (layoutItem.w <= 1) {\r\n        return 'h';\r\n    }\r\n    return lastShrunk === 'w' ? 'h' : 'w';\r\n}\r\n/**\r\n * Given the current number and min/max values, returns the number within the range\r\n * @param number can be any numeric value\r\n * @param min minimum value of range\r\n * @param max maximum value of range\r\n */\r\nfunction limitNumberWithinRange(num, min = 1, max = Infinity) {\r\n    return Math.min(Math.max(num, min < 1 ? 1 : min), max);\r\n}\n\n/**\r\n * Injection token that can be used to reference instances of `KtdGridDragHandle`. It serves as\r\n * alternative token to the actual `KtdGridDragHandle` class which could cause unnecessary\r\n * retention of the class and its directive metadata.\r\n */\r\nconst KTD_GRID_DRAG_HANDLE = new InjectionToken('KtdGridDragHandle');\r\n/** Handle that can be used to drag a KtdGridItem instance. */\r\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\r\nclass KtdGridDragHandle {\r\n    constructor(element) {\r\n        this.element = element;\r\n    }\r\n}\r\nKtdGridDragHandle.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridDragHandle, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\r\nKtdGridDragHandle.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.2.7\", type: KtdGridDragHandle, selector: \"[ktdGridDragHandle]\", host: { classAttribute: \"ktd-grid-drag-handle\" }, providers: [{ provide: KTD_GRID_DRAG_HANDLE, useExisting: KtdGridDragHandle }], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridDragHandle, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[ktdGridDragHandle]',\r\n                    // eslint-disable-next-line @angular-eslint/no-host-metadata-property\r\n                    host: {\r\n                        class: 'ktd-grid-drag-handle'\r\n                    },\r\n                    providers: [{ provide: KTD_GRID_DRAG_HANDLE, useExisting: KtdGridDragHandle }],\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });\n\n/**\r\n * Injection token that can be used to reference instances of `KtdGridResizeHandle`. It serves as\r\n * alternative token to the actual `KtdGridResizeHandle` class which could cause unnecessary\r\n * retention of the class and its directive metadata.\r\n */\r\nconst KTD_GRID_RESIZE_HANDLE = new InjectionToken('KtdGridResizeHandle');\r\n/** Handle that can be used to drag a KtdGridItem instance. */\r\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\r\nclass KtdGridResizeHandle {\r\n    constructor(element) {\r\n        this.element = element;\r\n    }\r\n}\r\nKtdGridResizeHandle.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridResizeHandle, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });\r\nKtdGridResizeHandle.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.2.7\", type: KtdGridResizeHandle, selector: \"[ktdGridResizeHandle]\", host: { classAttribute: \"ktd-grid-resize-handle\" }, providers: [{ provide: KTD_GRID_RESIZE_HANDLE, useExisting: KtdGridResizeHandle }], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridResizeHandle, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[ktdGridResizeHandle]',\r\n                    // eslint-disable-next-line @angular-eslint/no-host-metadata-property\r\n                    host: {\r\n                        class: 'ktd-grid-resize-handle'\r\n                    },\r\n                    providers: [{ provide: KTD_GRID_RESIZE_HANDLE, useExisting: KtdGridResizeHandle }],\r\n                }]\r\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });\n\nconst GRID_ITEM_GET_RENDER_DATA_TOKEN = new InjectionToken('GRID_ITEM_GET_RENDER_DATA_TOKEN');\n\n/** Runs source observable outside the zone */\r\nfunction ktdOutsideZone(zone) {\r\n    return (source) => {\r\n        return new Observable(observer => {\r\n            return zone.runOutsideAngular(() => source.subscribe(observer));\r\n        });\r\n    };\r\n}\r\n/** Rxjs operator that makes source observable to no emit any data */\r\nfunction ktdNoEmit() {\r\n    return (source$) => {\r\n        return source$.pipe(filter(() => false));\r\n    };\r\n}\n\n/** Coerces a data-bound value (typically a string) to a boolean. */\r\nfunction coerceBooleanProperty(value) {\r\n    return value != null && `${value}` !== 'false';\r\n}\n\nfunction coerceNumberProperty(value, fallbackValue = 0) {\r\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\r\n}\r\n/**\r\n * Whether the provided value is considered a number.\r\n * @docs-private\r\n */\r\nfunction _isNumberValue(value) {\r\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\r\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\r\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\r\n    return !isNaN(parseFloat(value)) && !isNaN(Number(value));\r\n}\n\n/** Event options that can be used to bind an active, capturing event. */\r\nconst activeCapturingEventOptions = ktdNormalizePassiveListenerOptions({\r\n    passive: false,\r\n    capture: true\r\n});\r\nclass KtdGridService {\r\n    constructor(ngZone) {\r\n        this.ngZone = ngZone;\r\n        this.touchMoveSubject = new Subject();\r\n        this.touchMove$ = this.touchMoveSubject.asObservable();\r\n        this.registerTouchMoveSubscription();\r\n    }\r\n    ngOnDestroy() {\r\n        this.touchMoveSubscription.unsubscribe();\r\n    }\r\n    mouseOrTouchMove$(element) {\r\n        return iif(() => ktdIsMobileOrTablet(), this.touchMove$, fromEvent(element, 'mousemove', activeCapturingEventOptions) // TODO: Fix rxjs typings, boolean should be a good param too.\r\n        );\r\n    }\r\n    registerTouchMoveSubscription() {\r\n        // The `touchmove` event gets bound once, ahead of time, because WebKit\r\n        // won't preventDefault on a dynamically-added `touchmove` listener.\r\n        // See https://bugs.webkit.org/show_bug.cgi?id=184250.\r\n        this.touchMoveSubscription = this.ngZone.runOutsideAngular(() => \r\n        // The event handler has to be explicitly active,\r\n        // because newer browsers make it passive by default.\r\n        fromEvent(document, 'touchmove', activeCapturingEventOptions) // TODO: Fix rxjs typings, boolean should be a good param too.\r\n            .pipe(filter((touchEvent) => touchEvent.touches.length === 1))\r\n            .subscribe((touchEvent) => this.touchMoveSubject.next(touchEvent)));\r\n    }\r\n}\r\nKtdGridService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\r\nKtdGridService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridService, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });\n\nclass KtdGridItemComponent {\r\n    constructor(elementRef, gridService, renderer, ngZone, getItemRenderData) {\r\n        this.elementRef = elementRef;\r\n        this.gridService = gridService;\r\n        this.renderer = renderer;\r\n        this.ngZone = ngZone;\r\n        this.getItemRenderData = getItemRenderData;\r\n        /** CSS transition style. Note that for more performance is preferable only make transition on transform property. */\r\n        this.transition = 'transform 500ms ease, width 500ms ease, height 500ms ease';\r\n        this._dragStartThreshold = 0;\r\n        this._draggable = true;\r\n        this._draggable$ = new BehaviorSubject(this._draggable);\r\n        this._resizable = true;\r\n        this._resizable$ = new BehaviorSubject(this._resizable);\r\n        this.dragStartSubject = new Subject();\r\n        this.resizeStartSubject = new Subject();\r\n        this.subscriptions = [];\r\n        this.dragStart$ = this.dragStartSubject.asObservable();\r\n        this.resizeStart$ = this.resizeStartSubject.asObservable();\r\n    }\r\n    /** Id of the grid item. This property is strictly compulsory. */\r\n    get id() {\r\n        return this._id;\r\n    }\r\n    set id(val) {\r\n        this._id = val;\r\n    }\r\n    /** Minimum amount of pixels that the user should move before it starts the drag sequence. */\r\n    get dragStartThreshold() { return this._dragStartThreshold; }\r\n    set dragStartThreshold(val) {\r\n        this._dragStartThreshold = coerceNumberProperty(val);\r\n    }\r\n    /** Whether the item is draggable or not. Defaults to true. */\r\n    get draggable() {\r\n        return this._draggable;\r\n    }\r\n    set draggable(val) {\r\n        this._draggable = coerceBooleanProperty(val);\r\n        this._draggable$.next(this._draggable);\r\n    }\r\n    /** Whether the item is resizable or not. Defaults to true. */\r\n    get resizable() {\r\n        return this._resizable;\r\n    }\r\n    set resizable(val) {\r\n        this._resizable = coerceBooleanProperty(val);\r\n        this._resizable$.next(this._resizable);\r\n    }\r\n    ngOnInit() {\r\n        const gridItemRenderData = this.getItemRenderData(this.id);\r\n        this.setStyles(gridItemRenderData);\r\n    }\r\n    ngAfterContentInit() {\r\n        this.subscriptions.push(this._dragStart$().subscribe(this.dragStartSubject), this._resizeStart$().subscribe(this.resizeStartSubject));\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscriptions.forEach(sub => sub.unsubscribe());\r\n    }\r\n    setStyles({ top, left, width, height }) {\r\n        // transform is 6x times faster than top/left\r\n        this.renderer.setStyle(this.elementRef.nativeElement, 'transform', `translateX(${left}) translateY(${top})`);\r\n        this.renderer.setStyle(this.elementRef.nativeElement, 'display', `block`);\r\n        this.renderer.setStyle(this.elementRef.nativeElement, 'transition', this.transition);\r\n        if (width != null) {\r\n            this.renderer.setStyle(this.elementRef.nativeElement, 'width', width);\r\n        }\r\n        if (height != null) {\r\n            this.renderer.setStyle(this.elementRef.nativeElement, 'height', height);\r\n        }\r\n    }\r\n    _dragStart$() {\r\n        return this._draggable$.pipe(switchMap((draggable) => {\r\n            if (!draggable) {\r\n                return NEVER;\r\n            }\r\n            else {\r\n                return this._dragHandles.changes.pipe(startWith(this._dragHandles), switchMap((dragHandles) => {\r\n                    return iif(() => dragHandles.length > 0, merge(...dragHandles.toArray().map(dragHandle => ktdMouseOrTouchDown(dragHandle.element.nativeElement, 1))), ktdMouseOrTouchDown(this.elementRef.nativeElement, 1)).pipe(exhaustMap((startEvent) => {\r\n                        // If the event started from an element with the native HTML drag&drop, it'll interfere\r\n                        // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\r\n                        // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\r\n                        // it's flaky and it fails if the user drags it away quickly. Also note that we only want\r\n                        // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\r\n                        // events from firing on touch devices.\r\n                        if (startEvent.target && startEvent.target.draggable && startEvent.type === 'mousedown') {\r\n                            startEvent.preventDefault();\r\n                        }\r\n                        const startPointer = ktdPointerClient(startEvent);\r\n                        return this.gridService.mouseOrTouchMove$(document).pipe(takeUntil(ktdMouseOrTouchEnd(document, 1)), ktdOutsideZone(this.ngZone), filter((moveEvent) => {\r\n                            moveEvent.preventDefault();\r\n                            const movePointer = ktdPointerClient(moveEvent);\r\n                            const distanceX = Math.abs(startPointer.clientX - movePointer.clientX);\r\n                            const distanceY = Math.abs(startPointer.clientY - movePointer.clientY);\r\n                            // When this conditions returns true mean that we are over threshold.\r\n                            return distanceX + distanceY >= this.dragStartThreshold;\r\n                        }), take(1), \r\n                        // Return the original start event\r\n                        map(() => startEvent));\r\n                    }));\r\n                }));\r\n            }\r\n        }));\r\n    }\r\n    _resizeStart$() {\r\n        return this._resizable$.pipe(switchMap((resizable) => {\r\n            if (!resizable) {\r\n                // Side effect to hide the resizeElem if resize is disabled.\r\n                this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\r\n                return NEVER;\r\n            }\r\n            else {\r\n                return this._resizeHandles.changes.pipe(startWith(this._resizeHandles), switchMap((resizeHandles) => {\r\n                    if (resizeHandles.length > 0) {\r\n                        // Side effect to hide the resizeElem if there are resize handles.\r\n                        this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\r\n                        return merge(...resizeHandles.toArray().map(resizeHandle => ktdMouseOrTouchDown(resizeHandle.element.nativeElement, 1)));\r\n                    }\r\n                    else {\r\n                        this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'block');\r\n                        return ktdMouseOrTouchDown(this.resizeElem.nativeElement, 1);\r\n                    }\r\n                }));\r\n            }\r\n        }));\r\n    }\r\n}\r\nKtdGridItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridItemComponent, deps: [{ token: i0.ElementRef }, { token: KtdGridService }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: GRID_ITEM_GET_RENDER_DATA_TOKEN }], target: i0.ɵɵFactoryTarget.Component });\r\nKtdGridItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.2.7\", type: KtdGridItemComponent, selector: \"ktd-grid-item\", inputs: { minW: \"minW\", minH: \"minH\", maxW: \"maxW\", maxH: \"maxH\", transition: \"transition\", id: \"id\", dragStartThreshold: \"dragStartThreshold\", draggable: \"draggable\", resizable: \"resizable\" }, queries: [{ propertyName: \"_dragHandles\", predicate: KTD_GRID_DRAG_HANDLE, descendants: true }, { propertyName: \"_resizeHandles\", predicate: KTD_GRID_RESIZE_HANDLE, descendants: true }], viewQueries: [{ propertyName: \"resizeElem\", first: true, predicate: [\"resizeElem\"], descendants: true, read: ElementRef, static: true }], ngImport: i0, template: \"<ng-content></ng-content>\\n<div #resizeElem class=\\\"grid-item-resize-icon\\\"></div>\\n\", styles: [\":host{display:none;position:absolute;z-index:1;overflow:hidden}:host div{position:absolute;-webkit-user-select:none;user-select:none;z-index:10}:host div.grid-item-resize-icon{cursor:se-resize;width:20px;height:20px;bottom:0;right:0;color:inherit}:host div.grid-item-resize-icon:after{content:\\\"\\\";position:absolute;right:3px;bottom:3px;width:5px;height:5px;border-right:2px solid;border-bottom:2px solid}.display-none{display:none!important}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridItemComponent, decorators: [{\r\n            type: Component,\r\n            args: [{ selector: 'ktd-grid-item', changeDetection: ChangeDetectionStrategy.OnPush, template: \"<ng-content></ng-content>\\n<div #resizeElem class=\\\"grid-item-resize-icon\\\"></div>\\n\", styles: [\":host{display:none;position:absolute;z-index:1;overflow:hidden}:host div{position:absolute;-webkit-user-select:none;user-select:none;z-index:10}:host div.grid-item-resize-icon{cursor:se-resize;width:20px;height:20px;bottom:0;right:0;color:inherit}:host div.grid-item-resize-icon:after{content:\\\"\\\";position:absolute;right:3px;bottom:3px;width:5px;height:5px;border-right:2px solid;border-bottom:2px solid}.display-none{display:none!important}\\n\"] }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: i0.ElementRef }, { type: KtdGridService }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [GRID_ITEM_GET_RENDER_DATA_TOKEN]\r\n                    }] }];\r\n    }, propDecorators: { _dragHandles: [{\r\n                type: ContentChildren,\r\n                args: [KTD_GRID_DRAG_HANDLE, { descendants: true }]\r\n            }], _resizeHandles: [{\r\n                type: ContentChildren,\r\n                args: [KTD_GRID_RESIZE_HANDLE, { descendants: true }]\r\n            }], resizeElem: [{\r\n                type: ViewChild,\r\n                args: ['resizeElem', { static: true, read: ElementRef }]\r\n            }], minW: [{\r\n                type: Input\r\n            }], minH: [{\r\n                type: Input\r\n            }], maxW: [{\r\n                type: Input\r\n            }], maxH: [{\r\n                type: Input\r\n            }], transition: [{\r\n                type: Input\r\n            }], id: [{\r\n                type: Input\r\n            }], dragStartThreshold: [{\r\n                type: Input\r\n            }], draggable: [{\r\n                type: Input\r\n            }], resizable: [{\r\n                type: Input\r\n            }] } });\n\n// tslint:disable\r\n/**\r\n * Client rect utilities.\r\n * This file is taken from Angular Material repository. This is the reason why the tslint is disabled on this case.\r\n * Don't enable it until some custom change is done on this file.\r\n */\r\n/** Gets a mutable version of an element's bounding `ClientRect`. */\r\nfunction getMutableClientRect(element) {\r\n    const { top, right, bottom, left, width, height, x, y, toJSON } = element.getBoundingClientRect();\r\n    // We need to clone the `clientRect` here, because all the values on it are readonly\r\n    // and we need to be able to update them. Also we can't use a spread here, because\r\n    // the values on a `ClientRect` aren't own properties. See:\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\r\n    return { top, right, bottom, left, width, height, x, y, toJSON };\r\n}\r\n/**\r\n * Checks whether some coordinates are within a `ClientRect`.\r\n * @param clientRect ClientRect that is being checked.\r\n * @param x Coordinates along the X axis.\r\n * @param y Coordinates along the Y axis.\r\n */\r\n// export function isInsideClientRect(clientRect: ClientRect, x: number, y: number) {\r\n//   const {top, bottom, left, right} = clientRect;\r\n//   return y >= top && y <= bottom && x >= left && x <= right;\r\n// }\r\n/**\r\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\r\n * @param clientRect `ClientRect` that should be updated.\r\n * @param top Amount to add to the `top` position.\r\n * @param left Amount to add to the `left` position.\r\n */\r\n// export function adjustClientRect(clientRect: ClientRect, top: number, left: number) {\r\n//   clientRect.top += top;\r\n//   clientRect.bottom = clientRect.top + clientRect.height;\r\n//   clientRect.left += left;\r\n//   clientRect.right = clientRect.left + clientRect.width;\r\n// }\r\n/**\r\n * Checks whether the pointer coordinates are close to a ClientRect.\r\n * @param rect ClientRect to check against.\r\n * @param threshold Threshold around the ClientRect.\r\n * @param pointerX Coordinates along the X axis.\r\n * @param pointerY Coordinates along the Y axis.\r\n */\r\n// export function isPointerNearClientRect(rect: ClientRect,\r\n//                                         threshold: number,\r\n//                                         pointerX: number,\r\n//                                         pointerY: number): boolean {\r\n//   const {top, right, bottom, left, width, height} = rect;\r\n//   const xThreshold = width * threshold;\r\n//   const yThreshold = height * threshold;\r\n//   return pointerY > top - yThreshold && pointerY < bottom + yThreshold &&\r\n//          pointerX > left - xThreshold && pointerX < right + xThreshold;\r\n// }\n\n/**\r\n * Proximity, as a ratio to width/height at which to start auto-scrolling.\r\n * The value comes from trying it out manually until it feels right.\r\n */\r\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\r\n/**\r\n * Increments the vertical scroll position of a node.\r\n * @param node Node whose scroll position should change.\r\n * @param amount Amount of pixels that the `node` should be scrolled.\r\n */\r\nfunction incrementVerticalScroll(node, amount) {\r\n    if (node === window) {\r\n        node.scrollBy(0, amount);\r\n    }\r\n    else {\r\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\r\n        node.scrollTop += amount;\r\n    }\r\n}\r\n/**\r\n * Increments the horizontal scroll position of a node.\r\n * @param node Node whose scroll position should change.\r\n * @param amount Amount of pixels that the `node` should be scrolled.\r\n */\r\nfunction incrementHorizontalScroll(node, amount) {\r\n    if (node === window) {\r\n        node.scrollBy(amount, 0);\r\n    }\r\n    else {\r\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\r\n        node.scrollLeft += amount;\r\n    }\r\n}\r\n/**\r\n * Gets whether the vertical auto-scroll direction of a node.\r\n * @param clientRect Dimensions of the node.\r\n * @param pointerY Position of the user's pointer along the y axis.\r\n */\r\nfunction getVerticalScrollDirection(clientRect, pointerY) {\r\n    const { top, bottom, height } = clientRect;\r\n    const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\r\n    if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\r\n        return 1 /* UP */;\r\n    }\r\n    else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\r\n        return 2 /* DOWN */;\r\n    }\r\n    return 0 /* NONE */;\r\n}\r\n/**\r\n * Gets whether the horizontal auto-scroll direction of a node.\r\n * @param clientRect Dimensions of the node.\r\n * @param pointerX Position of the user's pointer along the x axis.\r\n */\r\nfunction getHorizontalScrollDirection(clientRect, pointerX) {\r\n    const { left, right, width } = clientRect;\r\n    const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\r\n    if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\r\n        return 1 /* LEFT */;\r\n    }\r\n    else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\r\n        return 2 /* RIGHT */;\r\n    }\r\n    return 0 /* NONE */;\r\n}\r\n/**\r\n * Returns an observable that schedules a loop and apply scroll on the scrollNode into the specified direction/s.\r\n * This observable doesn't emit, it just performs the 'scroll' side effect.\r\n * @param scrollNode, node where the scroll would be applied.\r\n * @param verticalScrollDirection, vertical direction of the scroll.\r\n * @param horizontalScrollDirection, horizontal direction of the scroll.\r\n * @param scrollStep, scroll step in CSS pixels that would be applied in every loop.\r\n */\r\nfunction scrollToDirectionInterval$(scrollNode, verticalScrollDirection, horizontalScrollDirection, scrollStep = 2) {\r\n    return interval(0, animationFrameScheduler)\r\n        .pipe(tap(() => {\r\n        if (verticalScrollDirection === 1 /* UP */) {\r\n            incrementVerticalScroll(scrollNode, -scrollStep);\r\n        }\r\n        else if (verticalScrollDirection === 2 /* DOWN */) {\r\n            incrementVerticalScroll(scrollNode, scrollStep);\r\n        }\r\n        if (horizontalScrollDirection === 1 /* LEFT */) {\r\n            incrementHorizontalScroll(scrollNode, -scrollStep);\r\n        }\r\n        else if (horizontalScrollDirection === 2 /* RIGHT */) {\r\n            incrementHorizontalScroll(scrollNode, scrollStep);\r\n        }\r\n    }), ktdNoEmit());\r\n}\r\n/**\r\n * Given a source$ observable with pointer location, scroll the scrollNode if the pointer is near to it.\r\n * This observable doesn't emit, it just performs a 'scroll' side effect.\r\n * @param scrollableParent, parent node in which the scroll would be performed.\r\n * @param options, configuration options.\r\n */\r\nfunction ktdScrollIfNearElementClientRect$(scrollableParent, options) {\r\n    let scrollNode;\r\n    let scrollableParentClientRect;\r\n    let scrollableParentScrollWidth;\r\n    if (scrollableParent === document) {\r\n        scrollNode = document.defaultView;\r\n        const { width, height } = getViewportSize();\r\n        scrollableParentClientRect = { width, height, top: 0, right: width, bottom: height, left: 0, x: 0, y: 0, toJSON: () => null };\r\n        scrollableParentScrollWidth = getDocumentScrollWidth();\r\n    }\r\n    else {\r\n        scrollNode = scrollableParent;\r\n        scrollableParentClientRect = getMutableClientRect(scrollableParent);\r\n        scrollableParentScrollWidth = scrollableParent.scrollWidth;\r\n    }\r\n    /**\r\n     * IMPORTANT: By design, only let scroll horizontal if the scrollable parent has explicitly an scroll horizontal.\r\n     * This layout solution is not designed in mind to have any scroll horizontal, but exceptionally we allow it in this\r\n     * specific use case.\r\n     */\r\n    options = options || {};\r\n    if (options.disableHorizontal == null && scrollableParentScrollWidth <= scrollableParentClientRect.width) {\r\n        options.disableHorizontal = true;\r\n    }\r\n    return (source$) => source$.pipe(map(({ pointerX, pointerY }) => {\r\n        let verticalScrollDirection = getVerticalScrollDirection(scrollableParentClientRect, pointerY);\r\n        let horizontalScrollDirection = getHorizontalScrollDirection(scrollableParentClientRect, pointerX);\r\n        // Check if scroll directions are disabled.\r\n        if (options === null || options === void 0 ? void 0 : options.disableVertical) {\r\n            verticalScrollDirection = 0 /* NONE */;\r\n        }\r\n        if (options === null || options === void 0 ? void 0 : options.disableHorizontal) {\r\n            horizontalScrollDirection = 0 /* NONE */;\r\n        }\r\n        return { verticalScrollDirection, horizontalScrollDirection };\r\n    }), distinctUntilChanged((prev, actual) => {\r\n        return prev.verticalScrollDirection === actual.verticalScrollDirection\r\n            && prev.horizontalScrollDirection === actual.horizontalScrollDirection;\r\n    }), switchMap(({ verticalScrollDirection, horizontalScrollDirection }) => {\r\n        if (verticalScrollDirection || horizontalScrollDirection) {\r\n            return scrollToDirectionInterval$(scrollNode, verticalScrollDirection, horizontalScrollDirection, options === null || options === void 0 ? void 0 : options.scrollStep);\r\n        }\r\n        else {\r\n            return NEVER;\r\n        }\r\n    }));\r\n}\r\n/**\r\n * Emits on EVERY scroll event and returns the accumulated scroll offset relative to the initial scroll position.\r\n * @param scrollableParent, node in which scroll events would be listened.\r\n */\r\nfunction ktdGetScrollTotalRelativeDifference$(scrollableParent) {\r\n    let scrollInitialPosition;\r\n    // Calculate initial scroll position\r\n    if (scrollableParent === document) {\r\n        scrollInitialPosition = getViewportScrollPosition();\r\n    }\r\n    else {\r\n        scrollInitialPosition = {\r\n            top: scrollableParent.scrollTop,\r\n            left: scrollableParent.scrollLeft\r\n        };\r\n    }\r\n    return fromEvent(scrollableParent, 'scroll', ktdNormalizePassiveListenerOptions({ capture: true })).pipe(map(() => {\r\n        let newTop;\r\n        let newLeft;\r\n        if (scrollableParent === document) {\r\n            const viewportScrollPosition = getViewportScrollPosition();\r\n            newTop = viewportScrollPosition.top;\r\n            newLeft = viewportScrollPosition.left;\r\n        }\r\n        else {\r\n            newTop = scrollableParent.scrollTop;\r\n            newLeft = scrollableParent.scrollLeft;\r\n        }\r\n        const topDifference = scrollInitialPosition.top - newTop;\r\n        const leftDifference = scrollInitialPosition.left - newLeft;\r\n        return { top: topDifference, left: leftDifference };\r\n    }));\r\n}\r\n/** Returns the viewport's width and height. */\r\nfunction getViewportSize() {\r\n    const _window = document.defaultView || window;\r\n    return {\r\n        width: _window.innerWidth,\r\n        height: _window.innerHeight\r\n    };\r\n}\r\n/** Gets a ClientRect for the viewport's bounds. */\r\n// function getViewportRect(): ClientRect {\r\n//     // Use the document element's bounding rect rather than the window scroll properties\r\n//     // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\r\n//     // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\r\n//     // conceptual viewports. Under most circumstances these viewports are equivalent, but they\r\n//     // can disagree when the page is pinch-zoomed (on devices that support touch).\r\n//     // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\r\n//     // We use the documentElement instead of the body because, by default (without a css reset)\r\n//     // browsers typically give the document body an 8px margin, which is not included in\r\n//     // getBoundingClientRect().\r\n//     const scrollPosition = getViewportScrollPosition();\r\n//     const {width, height} = getViewportSize();\r\n//     return {\r\n//         top: scrollPosition.top,\r\n//         left: scrollPosition.left,\r\n//         bottom: scrollPosition.top + height,\r\n//         right: scrollPosition.left + width,\r\n//         height,\r\n//         width,\r\n//     };\r\n// }\r\n/** Gets the (top, left) scroll position of the viewport. */\r\nfunction getViewportScrollPosition() {\r\n    // The top-left-corner of the viewport is determined by the scroll position of the document\r\n    // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\r\n    // whether `document.body` or `document.documentElement` is the scrolled element, so reading\r\n    // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\r\n    // `document.documentElement` works consistently, where the `top` and `left` values will\r\n    // equal negative the scroll position.\r\n    const windowRef = document.defaultView || window;\r\n    const documentElement = document.documentElement;\r\n    const documentRect = documentElement.getBoundingClientRect();\r\n    const top = -documentRect.top || document.body.scrollTop || windowRef.scrollY ||\r\n        documentElement.scrollTop || 0;\r\n    const left = -documentRect.left || document.body.scrollLeft || windowRef.scrollX ||\r\n        documentElement.scrollLeft || 0;\r\n    return { top, left };\r\n}\r\n/** Returns the document scroll width */\r\nfunction getDocumentScrollWidth() {\r\n    return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\r\n}\n\nfunction getDragResizeEventData(gridItem, layout) {\r\n    return {\r\n        layout,\r\n        layoutItem: layout.find((item) => item.id === gridItem.id),\r\n        gridItemRef: gridItem\r\n    };\r\n}\r\nfunction layoutToRenderItems(config, width, height) {\r\n    const { cols, rowHeight, layout } = config;\r\n    const renderItems = {};\r\n    for (const item of layout) {\r\n        renderItems[item.id] = {\r\n            id: item.id,\r\n            top: item.y === 0 ? 0 : item.y * rowHeight,\r\n            left: item.x * (width / cols),\r\n            width: item.w * (width / cols),\r\n            height: item.h * rowHeight\r\n        };\r\n    }\r\n    return renderItems;\r\n}\r\nfunction getGridHeight(layout, rowHeight) {\r\n    return layout.reduce((acc, cur) => Math.max(acc, (cur.y + cur.h) * rowHeight), 0);\r\n}\r\n// tslint:disable-next-line\r\nfunction parseRenderItemToPixels(renderItem) {\r\n    return {\r\n        id: renderItem.id,\r\n        top: `${renderItem.top}px`,\r\n        left: `${renderItem.left}px`,\r\n        width: `${renderItem.width}px`,\r\n        height: `${renderItem.height}px`\r\n    };\r\n}\r\n// tslint:disable-next-line:ktd-prefix-code\r\nfunction __gridItemGetRenderDataFactoryFunc(gridCmp) {\r\n    // tslint:disable-next-line:only-arrow-functions\r\n    return function (id) {\r\n        return parseRenderItemToPixels(gridCmp.getItemRenderData(id));\r\n    };\r\n}\r\nfunction ktdGridItemGetRenderDataFactoryFunc(gridCmp) {\r\n    // Workaround explained: https://github.com/ng-packagr/ng-packagr/issues/696#issuecomment-387114613\r\n    const resultFunc = __gridItemGetRenderDataFactoryFunc(gridCmp);\r\n    return resultFunc;\r\n}\r\nclass KtdGridComponent {\r\n    constructor(gridService, elementRef, renderer, ngZone) {\r\n        this.gridService = gridService;\r\n        this.elementRef = elementRef;\r\n        this.renderer = renderer;\r\n        this.ngZone = ngZone;\r\n        /** Emits when layout change */\r\n        this.layoutUpdated = new EventEmitter();\r\n        /** Emits when drag starts */\r\n        this.dragStarted = new EventEmitter();\r\n        /** Emits when resize starts */\r\n        this.resizeStarted = new EventEmitter();\r\n        /** Emits when drag ends */\r\n        this.dragEnded = new EventEmitter();\r\n        /** Emits when resize ends */\r\n        this.resizeEnded = new EventEmitter();\r\n        /**\r\n         * Parent element that contains the scroll. If an string is provided it would search that element by id on the dom.\r\n         * If no data provided or null autoscroll is not performed.\r\n         */\r\n        this.scrollableParent = null;\r\n        this._compactOnPropsChange = true;\r\n        this._preventCollision = false;\r\n        this._scrollSpeed = 2;\r\n        this._compactType = 'vertical';\r\n        this._rowHeight = 100;\r\n        this._cols = 6;\r\n    }\r\n    /** Whether or not to update the internal layout when some dependent property change. */\r\n    get compactOnPropsChange() { return this._compactOnPropsChange; }\r\n    set compactOnPropsChange(value) {\r\n        this._compactOnPropsChange = coerceBooleanProperty(value);\r\n    }\r\n    /** If true, grid items won't change position when being dragged over. Handy when using no compaction */\r\n    get preventCollision() { return this._preventCollision; }\r\n    set preventCollision(value) {\r\n        this._preventCollision = coerceBooleanProperty(value);\r\n    }\r\n    /** Number of CSS pixels that would be scrolled on each 'tick' when auto scroll is performed. */\r\n    get scrollSpeed() { return this._scrollSpeed; }\r\n    set scrollSpeed(value) {\r\n        this._scrollSpeed = coerceNumberProperty(value, 2);\r\n    }\r\n    /** Type of compaction that will be applied to the layout (vertical, horizontal or free). Defaults to 'vertical' */\r\n    get compactType() {\r\n        return this._compactType;\r\n    }\r\n    set compactType(val) {\r\n        this._compactType = val;\r\n    }\r\n    /** Row height in css pixels */\r\n    get rowHeight() { return this._rowHeight; }\r\n    set rowHeight(val) {\r\n        this._rowHeight = Math.max(1, Math.round(coerceNumberProperty(val)));\r\n    }\r\n    /** Number of columns  */\r\n    get cols() { return this._cols; }\r\n    set cols(val) {\r\n        this._cols = Math.max(1, Math.round(coerceNumberProperty(val)));\r\n    }\r\n    /** Layout of the grid. Array of all the grid items with its 'id' and position on the grid. */\r\n    get layout() { return this._layout; }\r\n    set layout(layout) {\r\n        /**\r\n         * Enhancement:\r\n         * Only set layout if it's reference has changed and use a boolean to track whenever recalculate the layout on ngOnChanges.\r\n         *\r\n         * Why:\r\n         * The normal use of this lib is having the variable layout in the outer component or in a store, assigning it whenever it changes and\r\n         * binded in the component with it's input [layout]. In this scenario, we would always calculate one unnecessary change on the layout when\r\n         * it is re-binded on the input.\r\n         */\r\n        this._layout = layout;\r\n    }\r\n    get config() {\r\n        return {\r\n            cols: this.cols,\r\n            rowHeight: this.rowHeight,\r\n            layout: this.layout,\r\n            preventCollision: this.preventCollision,\r\n        };\r\n    }\r\n    ngOnChanges(changes) {\r\n        let needsCompactLayout = false;\r\n        let needsRecalculateRenderData = false;\r\n        // TODO: Does fist change need to be compacted by default?\r\n        // Compact layout whenever some dependent prop changes.\r\n        if (changes.compactType || changes.cols || changes.layout) {\r\n            needsCompactLayout = true;\r\n        }\r\n        // Check if wee need to recalculate rendering data.\r\n        if (needsCompactLayout || changes.rowHeight) {\r\n            needsRecalculateRenderData = true;\r\n        }\r\n        // Only compact layout if lib user has provided it. Lib users that want to save/store always the same layout  as it is represented (compacted)\r\n        // can use KtdCompactGrid utility and pre-compact the layout. This is the recommended behaviour for always having a the same layout on this component\r\n        // and the ones that uses it.\r\n        if (needsCompactLayout && this.compactOnPropsChange) {\r\n            this.compactLayout();\r\n        }\r\n        if (needsRecalculateRenderData) {\r\n            this.calculateRenderData();\r\n        }\r\n    }\r\n    ngAfterContentInit() {\r\n        this.initSubscriptions();\r\n    }\r\n    ngAfterContentChecked() {\r\n        this.render();\r\n    }\r\n    resize() {\r\n        this.calculateRenderData();\r\n        this.render();\r\n    }\r\n    ngOnDestroy() {\r\n        this.subscriptions.forEach(sub => sub.unsubscribe());\r\n    }\r\n    compactLayout() {\r\n        this.layout = compact(this.layout, this.compactType, this.cols);\r\n    }\r\n    getItemsRenderData() {\r\n        return Object.assign({}, this._gridItemsRenderData);\r\n    }\r\n    getItemRenderData(itemId) {\r\n        return this._gridItemsRenderData[itemId];\r\n    }\r\n    calculateRenderData() {\r\n        const clientRect = this.elementRef.nativeElement.getBoundingClientRect();\r\n        this._gridItemsRenderData = layoutToRenderItems(this.config, clientRect.width, clientRect.height);\r\n        this._height = getGridHeight(this.layout, this.rowHeight);\r\n    }\r\n    render() {\r\n        this.renderer.setStyle(this.elementRef.nativeElement, 'height', `${this._height}px`);\r\n        this.updateGridItemsStyles();\r\n    }\r\n    updateGridItemsStyles() {\r\n        this._gridItems.forEach(item => {\r\n            const gridItemRenderData = this._gridItemsRenderData[item.id];\r\n            if (gridItemRenderData == null) {\r\n                console.error(`Couldn\\'t find the specified grid item for the id: ${item.id}`);\r\n            }\r\n            else {\r\n                item.setStyles(parseRenderItemToPixels(gridItemRenderData));\r\n            }\r\n        });\r\n    }\r\n    initSubscriptions() {\r\n        this.subscriptions = [\r\n            this._gridItems.changes.pipe(startWith(this._gridItems), switchMap((gridItems) => {\r\n                return merge(...gridItems.map((gridItem) => gridItem.dragStart$.pipe(map((event) => ({ event, gridItem, type: 'drag' })))), ...gridItems.map((gridItem) => gridItem.resizeStart$.pipe(map((event) => ({ event, gridItem, type: 'resize' }))))).pipe(exhaustMap(({ event, gridItem, type }) => {\r\n                    // Emit drag or resize start events. Ensure that is start event is inside the zone.\r\n                    this.ngZone.run(() => (type === 'drag' ? this.dragStarted : this.resizeStarted).emit(getDragResizeEventData(gridItem, this.layout)));\r\n                    // Get the correct newStateFunc depending on if we are dragging or resizing\r\n                    const calcNewStateFunc = type === 'drag' ? ktdGridItemDragging : ktdGridItemResizing;\r\n                    // Perform drag sequence\r\n                    return this.performDragSequence$(gridItem, event, (gridItemId, config, compactionType, draggingData) => calcNewStateFunc(gridItem, config, compactionType, draggingData)).pipe(map((layout) => ({ layout, gridItem, type })));\r\n                }));\r\n            })).subscribe(({ layout, gridItem, type }) => {\r\n                this.layout = layout;\r\n                // Calculate new rendering data given the new layout.\r\n                this.calculateRenderData();\r\n                // Emit drag or resize end events.\r\n                (type === 'drag' ? this.dragEnded : this.resizeEnded).emit(getDragResizeEventData(gridItem, layout));\r\n                // Notify that the layout has been updated.\r\n                this.layoutUpdated.emit(layout);\r\n            })\r\n        ];\r\n    }\r\n    /**\r\n     * Perform a general grid drag action, from start to end. A general grid drag action basically includes creating the placeholder element and adding\r\n     * some class animations. calcNewStateFunc needs to be provided in order to calculate the new state of the layout.\r\n     * @param gridItem that is been dragged\r\n     * @param pointerDownEvent event (mousedown or touchdown) where the user initiated the drag\r\n     * @param calcNewStateFunc function that return the new layout state and the drag element position\r\n     */\r\n    performDragSequence$(gridItem, pointerDownEvent, calcNewStateFunc) {\r\n        return new Observable((observer) => {\r\n            // Retrieve grid (parent) and gridItem (draggedElem) client rects.\r\n            const gridElemClientRect = getMutableClientRect(this.elementRef.nativeElement);\r\n            const dragElemClientRect = getMutableClientRect(gridItem.elementRef.nativeElement);\r\n            const scrollableParent = typeof this.scrollableParent === 'string' ? document.getElementById(this.scrollableParent) : this.scrollableParent;\r\n            this.renderer.addClass(gridItem.elementRef.nativeElement, 'no-transitions');\r\n            this.renderer.addClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging');\r\n            // Create placeholder element. This element would represent the position where the dragged/resized element would be if the action ends\r\n            const placeholderElement = this.renderer.createElement('div');\r\n            placeholderElement.style.width = `${dragElemClientRect.width}px`;\r\n            placeholderElement.style.height = `${dragElemClientRect.height}px`;\r\n            placeholderElement.style.transform = `translateX(${dragElemClientRect.left - gridElemClientRect.left}px) translateY(${dragElemClientRect.top - gridElemClientRect.top}px)`;\r\n            this.renderer.addClass(placeholderElement, 'ktd-grid-item-placeholder');\r\n            this.renderer.appendChild(this.elementRef.nativeElement, placeholderElement);\r\n            let newLayout;\r\n            // TODO (enhancement): consider move this 'side effect' observable inside the main drag loop.\r\n            //  - Pros are that we would not repeat subscriptions and takeUntil would shut down observables at the same time.\r\n            //  - Cons are that moving this functionality as a side effect inside the main drag loop would be confusing.\r\n            const scrollSubscription = this.ngZone.runOutsideAngular(() => (!scrollableParent ? NEVER : this.gridService.mouseOrTouchMove$(document).pipe(map((event) => ({\r\n                pointerX: ktdPointerClientX(event),\r\n                pointerY: ktdPointerClientY(event)\r\n            })), ktdScrollIfNearElementClientRect$(scrollableParent, { scrollStep: this.scrollSpeed }))).pipe(takeUntil(ktdMouseOrTouchEnd(document))).subscribe());\r\n            /**\r\n             * Main subscription, it listens for 'pointer move' and 'scroll' events and recalculates the layout on each emission\r\n             */\r\n            const subscription = this.ngZone.runOutsideAngular(() => merge(combineLatest([\r\n                this.gridService.mouseOrTouchMove$(document),\r\n                ...(!scrollableParent ? [of({ top: 0, left: 0 })] : [\r\n                    ktdGetScrollTotalRelativeDifference$(scrollableParent).pipe(startWith({ top: 0, left: 0 }) // Force first emission to allow CombineLatest to emit even no scroll event has occurred\r\n                    )\r\n                ])\r\n            ])).pipe(takeUntil(ktdMouseOrTouchEnd(document))).subscribe(([pointerDragEvent, scrollDifference]) => {\r\n                pointerDragEvent.preventDefault();\r\n                /**\r\n                 * Set the new layout to be the layout in which the calcNewStateFunc would be executed.\r\n                 * NOTE: using the mutated layout is the way to go by 'react-grid-layout' utils. If we don't use the previous layout,\r\n                 * some utilities from 'react-grid-layout' would not work as expected.\r\n                 */\r\n                const currentLayout = newLayout || this.layout;\r\n                const { layout, draggedItemPos } = calcNewStateFunc(gridItem, {\r\n                    layout: currentLayout,\r\n                    rowHeight: this.rowHeight,\r\n                    cols: this.cols,\r\n                    preventCollision: this.preventCollision\r\n                }, this.compactType, {\r\n                    pointerDownEvent,\r\n                    pointerDragEvent,\r\n                    gridElemClientRect,\r\n                    dragElemClientRect,\r\n                    scrollDifference\r\n                });\r\n                newLayout = layout;\r\n                this._height = getGridHeight(newLayout, this.rowHeight);\r\n                this._gridItemsRenderData = layoutToRenderItems({\r\n                    cols: this.cols,\r\n                    rowHeight: this.rowHeight,\r\n                    layout: newLayout,\r\n                    preventCollision: this.preventCollision,\r\n                }, gridElemClientRect.width, gridElemClientRect.height);\r\n                const placeholderStyles = parseRenderItemToPixels(this._gridItemsRenderData[gridItem.id]);\r\n                // Put the real final position to the placeholder element\r\n                placeholderElement.style.width = placeholderStyles.width;\r\n                placeholderElement.style.height = placeholderStyles.height;\r\n                placeholderElement.style.transform = `translateX(${placeholderStyles.left}) translateY(${placeholderStyles.top})`;\r\n                // modify the position of the dragged item to be the once we want (for example the mouse position or whatever)\r\n                this._gridItemsRenderData[gridItem.id] = Object.assign(Object.assign({}, draggedItemPos), { id: this._gridItemsRenderData[gridItem.id].id });\r\n                this.render();\r\n            }, (error) => observer.error(error), () => {\r\n                this.ngZone.run(() => {\r\n                    // Remove drag classes\r\n                    this.renderer.removeClass(gridItem.elementRef.nativeElement, 'no-transitions');\r\n                    this.renderer.removeClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging');\r\n                    // Remove placeholder element from the dom\r\n                    // NOTE: If we don't put the removeChild inside the zone it would not work... This may be a bug from angular or maybe is the intended behaviour, although strange.\r\n                    // It should work since AFAIK this action should not be done in a CD cycle.\r\n                    this.renderer.removeChild(this.elementRef.nativeElement, placeholderElement);\r\n                    if (newLayout) {\r\n                        // TODO: newLayout should already be pruned. If not, it should have type Layout, not KtdGridLayout as it is now.\r\n                        // Prune react-grid-layout compact extra properties.\r\n                        observer.next(newLayout.map(item => ({\r\n                            id: item.id,\r\n                            x: item.x,\r\n                            y: item.y,\r\n                            w: item.w,\r\n                            h: item.h,\r\n                            minW: item.minW,\r\n                            minH: item.minH,\r\n                            maxW: item.maxW,\r\n                            maxH: item.maxH,\r\n                        })));\r\n                    }\r\n                    else {\r\n                        // TODO: Need we really to emit if there is no layout change but drag started and ended?\r\n                        observer.next(this.layout);\r\n                    }\r\n                    observer.complete();\r\n                });\r\n            }));\r\n            return () => {\r\n                scrollSubscription.unsubscribe();\r\n                subscription.unsubscribe();\r\n            };\r\n        });\r\n    }\r\n}\r\nKtdGridComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridComponent, deps: [{ token: KtdGridService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });\r\nKtdGridComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.2.7\", type: KtdGridComponent, selector: \"ktd-grid\", inputs: { scrollableParent: \"scrollableParent\", compactOnPropsChange: \"compactOnPropsChange\", preventCollision: \"preventCollision\", scrollSpeed: \"scrollSpeed\", compactType: \"compactType\", rowHeight: \"rowHeight\", cols: \"cols\", layout: \"layout\" }, outputs: { layoutUpdated: \"layoutUpdated\", dragStarted: \"dragStarted\", resizeStarted: \"resizeStarted\", dragEnded: \"dragEnded\", resizeEnded: \"resizeEnded\" }, providers: [\r\n        {\r\n            provide: GRID_ITEM_GET_RENDER_DATA_TOKEN,\r\n            useFactory: ktdGridItemGetRenderDataFactoryFunc,\r\n            deps: [KtdGridComponent]\r\n        }\r\n    ], queries: [{ propertyName: \"_gridItems\", predicate: KtdGridItemComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: \"<ng-content></ng-content>\\n\", styles: [\"ktd-grid{display:block;position:relative;width:100%}ktd-grid ktd-grid-item.ktd-grid-item-dragging{z-index:1000}ktd-grid ktd-grid-item.no-transitions{transition:none!important}ktd-grid .ktd-grid-item-placeholder{position:absolute;background-color:#8b0000;opacity:.6;z-index:0;transition-property:transform;transition:all .15s ease}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridComponent, decorators: [{\r\n            type: Component,\r\n            args: [{ selector: 'ktd-grid', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, providers: [\r\n                        {\r\n                            provide: GRID_ITEM_GET_RENDER_DATA_TOKEN,\r\n                            useFactory: ktdGridItemGetRenderDataFactoryFunc,\r\n                            deps: [KtdGridComponent]\r\n                        }\r\n                    ], template: \"<ng-content></ng-content>\\n\", styles: [\"ktd-grid{display:block;position:relative;width:100%}ktd-grid ktd-grid-item.ktd-grid-item-dragging{z-index:1000}ktd-grid ktd-grid-item.no-transitions{transition:none!important}ktd-grid .ktd-grid-item-placeholder{position:absolute;background-color:#8b0000;opacity:.6;z-index:0;transition-property:transform;transition:all .15s ease}\\n\"] }]\r\n        }], ctorParameters: function () { return [{ type: KtdGridService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }]; }, propDecorators: { _gridItems: [{\r\n                type: ContentChildren,\r\n                args: [KtdGridItemComponent, { descendants: true }]\r\n            }], layoutUpdated: [{\r\n                type: Output\r\n            }], dragStarted: [{\r\n                type: Output\r\n            }], resizeStarted: [{\r\n                type: Output\r\n            }], dragEnded: [{\r\n                type: Output\r\n            }], resizeEnded: [{\r\n                type: Output\r\n            }], scrollableParent: [{\r\n                type: Input\r\n            }], compactOnPropsChange: [{\r\n                type: Input\r\n            }], preventCollision: [{\r\n                type: Input\r\n            }], scrollSpeed: [{\r\n                type: Input\r\n            }], compactType: [{\r\n                type: Input\r\n            }], rowHeight: [{\r\n                type: Input\r\n            }], cols: [{\r\n                type: Input\r\n            }], layout: [{\r\n                type: Input\r\n            }] } });\n\nclass KtdGridModule {\r\n}\r\nKtdGridModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nKtdGridModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridModule, declarations: [KtdGridComponent,\r\n        KtdGridItemComponent,\r\n        KtdGridDragHandle,\r\n        KtdGridResizeHandle], imports: [CommonModule], exports: [KtdGridComponent,\r\n        KtdGridItemComponent,\r\n        KtdGridDragHandle,\r\n        KtdGridResizeHandle] });\r\nKtdGridModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridModule, providers: [\r\n        KtdGridService\r\n    ], imports: [[\r\n            CommonModule\r\n        ]] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.7\", ngImport: i0, type: KtdGridModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    declarations: [\r\n                        KtdGridComponent,\r\n                        KtdGridItemComponent,\r\n                        KtdGridDragHandle,\r\n                        KtdGridResizeHandle\r\n                    ],\r\n                    exports: [\r\n                        KtdGridComponent,\r\n                        KtdGridItemComponent,\r\n                        KtdGridDragHandle,\r\n                        KtdGridResizeHandle\r\n                    ],\r\n                    providers: [\r\n                        KtdGridService\r\n                    ],\r\n                    imports: [\r\n                        CommonModule\r\n                    ]\r\n                }]\r\n        }] });\n\n/*\r\n * Public API Surface of grid\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { GRID_ITEM_GET_RENDER_DATA_TOKEN, KTD_GRID_DRAG_HANDLE, KTD_GRID_RESIZE_HANDLE, KtdGridComponent, KtdGridDragHandle, KtdGridItemComponent, KtdGridModule, KtdGridResizeHandle, __gridItemGetRenderDataFactoryFunc, ktdGridCompact, ktdGridItemGetRenderDataFactoryFunc, ktdTrackById, parseRenderItemToPixels };\n//# sourceMappingURL=angular-grid-layout-ngx13.mjs.map\n","map":{"version":3,"file":"angular-grid-layout-ngx13.mjs","sources":["../../../projects/angular-grid-layout/src/lib/utils/react-grid-layout.utils.ts","../../../projects/angular-grid-layout/src/lib/utils/passive-listeners.ts","../../../projects/angular-grid-layout/src/lib/utils/pointer.utils.ts","../../../projects/angular-grid-layout/src/lib/utils/grid.utils.ts","../../../projects/angular-grid-layout/src/lib/directives/drag-handle.ts","../../../projects/angular-grid-layout/src/lib/directives/resize-handle.ts","../../../projects/angular-grid-layout/src/lib/grid.definitions.ts","../../../projects/angular-grid-layout/src/lib/utils/operators.ts","../../../projects/angular-grid-layout/src/lib/coercion/boolean-property.ts","../../../projects/angular-grid-layout/src/lib/coercion/number-property.ts","../../../projects/angular-grid-layout/src/lib/grid.service.ts","../../../projects/angular-grid-layout/src/lib/grid-item/grid-item.component.ts","../../../projects/angular-grid-layout/src/lib/grid-item/grid-item.component.html","../../../projects/angular-grid-layout/src/lib/utils/client-rect.ts","../../../projects/angular-grid-layout/src/lib/utils/scroll.ts","../../../projects/angular-grid-layout/src/lib/grid.component.ts","../../../projects/angular-grid-layout/src/lib/grid.component.html","../../../projects/angular-grid-layout/src/lib/grid.module.ts","../../../projects/angular-grid-layout/src/public-api.ts","../../../projects/angular-grid-layout/src/angular-grid-layout-ngx13.ts"],"sourcesContent":["\n/**\n * IMPORTANT:\n * This utils are taken from the project: https://github.com/STRML/react-grid-layout.\n * The code should be as less modified as possible for easy maintenance.\n */\n\n// Disable lint since we don't want to modify this code\n// tslint:disable\nexport type LayoutItem = {\n    w: number;\n    h: number;\n    x: number;\n    y: number;\n    id: string;\n    minW?: number;\n    minH?: number;\n    maxW?: number;\n    maxH?: number;\n    moved?: boolean;\n    static?: boolean;\n    isDraggable?: boolean | null | undefined;\n    isResizable?: boolean | null | undefined;\n};\nexport type Layout = Array<LayoutItem>;\nexport type Position = {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n};\nexport type ReactDraggableCallbackData = {\n    node: HTMLElement;\n    x?: number;\n    y?: number;\n    deltaX: number;\n    deltaY: number;\n    lastX?: number;\n    lastY?: number;\n};\n\nexport type PartialPosition = { left: number; top: number };\nexport type DroppingPosition = { x: number; y: number; e: Event };\nexport type Size = { width: number; height: number };\nexport type GridDragEvent = {\n    e: Event;\n    node: HTMLElement;\n    newPosition: PartialPosition;\n};\nexport type GridResizeEvent = { e: Event; node: HTMLElement; size: Size };\nexport type DragOverEvent = MouseEvent & {\n    nativeEvent: {\n        layerX: number;\n        layerY: number;\n        target: {\n            className: String;\n        };\n    };\n};\n\n//type REl = ReactElement<any>;\n//export type ReactChildren = ReactChildrenArray<REl>;\n\n// All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).\nexport type EventCallback = (\n    arg0: Layout,\n    oldItem: LayoutItem | null | undefined,\n    newItem: LayoutItem | null | undefined,\n    placeholder: LayoutItem | null | undefined,\n    arg4: Event,\n    arg5: HTMLElement | null | undefined,\n) => void;\nexport type CompactType = ('horizontal' | 'vertical') | null | undefined;\n\nconst DEBUG = false;\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nexport function bottom(layout: Layout): number {\n    let max = 0,\n        bottomY;\n    for (let i = 0, len = layout.length; i < len; i++) {\n        bottomY = layout[i].y + layout[i].h;\n        if (bottomY > max) {\n            max = bottomY;\n        }\n    }\n    return max;\n}\n\nexport function cloneLayout(layout: Layout): Layout {\n    const newLayout = Array(layout.length);\n    for (let i = 0, len = layout.length; i < len; i++) {\n        newLayout[i] = cloneLayoutItem(layout[i]);\n    }\n    return newLayout;\n}\n\n// Fast path to cloning, since this is monomorphic\n/** NOTE: This code has been modified from the original source */\nexport function cloneLayoutItem(layoutItem: LayoutItem): LayoutItem {\n    const clonedLayoutItem: LayoutItem = {\n        w: layoutItem.w,\n        h: layoutItem.h,\n        x: layoutItem.x,\n        y: layoutItem.y,\n        id: layoutItem.id,\n        moved: !!layoutItem.moved,\n        static: !!layoutItem.static,\n    };\n\n    if (layoutItem.minW !== undefined) { clonedLayoutItem.minW = layoutItem.minW;}\n    if (layoutItem.maxW !== undefined) { clonedLayoutItem.maxW = layoutItem.maxW;}\n    if (layoutItem.minH !== undefined) { clonedLayoutItem.minH = layoutItem.minH;}\n    if (layoutItem.maxH !== undefined) { clonedLayoutItem.maxH = layoutItem.maxH;}\n    // These can be null\n    if (layoutItem.isDraggable !== undefined) { clonedLayoutItem.isDraggable = layoutItem.isDraggable;}\n    if (layoutItem.isResizable !== undefined) { clonedLayoutItem.isResizable = layoutItem.isResizable;}\n\n    return clonedLayoutItem;\n}\n\n/**\n * Given two layoutitems, check if they collide.\n */\nexport function collides(l1: LayoutItem, l2: LayoutItem): boolean {\n    if (l1.id === l2.id) {\n        return false;\n    } // same element\n    if (l1.x + l1.w <= l2.x) {\n        return false;\n    } // l1 is left of l2\n    if (l1.x >= l2.x + l2.w) {\n        return false;\n    } // l1 is right of l2\n    if (l1.y + l1.h <= l2.y) {\n        return false;\n    } // l1 is above l2\n    if (l1.y >= l2.y + l2.h) {\n        return false;\n    } // l1 is below l2\n    return true; // boxes overlap\n}\n\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\nexport function compact(\n    layout: Layout,\n    compactType: CompactType,\n    cols: number,\n): Layout {\n    // Statics go in the compareWith array right away so items flow around them.\n    const compareWith = getStatics(layout);\n    // We go through the items by row and column.\n    const sorted = sortLayoutItems(layout, compactType);\n    // Holding for new items.\n    const out = Array(layout.length);\n\n    for (let i = 0, len = sorted.length; i < len; i++) {\n        let l = cloneLayoutItem(sorted[i]);\n\n        // Don't move static elements\n        if (!l.static) {\n            l = compactItem(compareWith, l, compactType, cols, sorted);\n\n            // Add to comparison array. We only collide with items before this one.\n            // Statics are already in this array.\n            compareWith.push(l);\n        }\n\n        // Add to output array to make sure they still come out in the right order.\n        out[layout.indexOf(sorted[i])] = l;\n\n        // Clear moved flag, if it exists.\n        l.moved = false;\n    }\n\n    return out;\n}\n\nconst heightWidth = {x: 'w', y: 'h'};\n\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\nfunction resolveCompactionCollision(\n    layout: Layout,\n    item: LayoutItem,\n    moveToCoord: number,\n    axis: 'x' | 'y',\n) {\n    const sizeProp = heightWidth[axis];\n    item[axis] += 1;\n    const itemIndex = layout\n        .map(layoutItem => {\n            return layoutItem.id;\n        })\n        .indexOf(item.id);\n\n    // Go through each item we collide with.\n    for (let i = itemIndex + 1; i < layout.length; i++) {\n        const otherItem = layout[i];\n        // Ignore static items\n        if (otherItem.static) {\n            continue;\n        }\n\n        // Optimization: we can break early if we know we're past this el\n        // We can do this b/c it's a sorted layout\n        if (otherItem.y > item.y + item.h) {\n            break;\n        }\n\n        if (collides(item, otherItem)) {\n            resolveCompactionCollision(\n                layout,\n                otherItem,\n                moveToCoord + item[sizeProp],\n                axis,\n            );\n        }\n    }\n\n    item[axis] = moveToCoord;\n}\n\n/**\n * Compact an item in the layout.\n */\nexport function compactItem(\n    compareWith: Layout,\n    l: LayoutItem,\n    compactType: CompactType,\n    cols: number,\n    fullLayout: Layout,\n): LayoutItem {\n    const compactV = compactType === 'vertical';\n    const compactH = compactType === 'horizontal';\n    if (compactV) {\n        // Bottom 'y' possible is the bottom of the layout.\n        // This allows you to do nice stuff like specify {y: Infinity}\n        // This is here because the layout must be sorted in order to get the correct bottom `y`.\n        l.y = Math.min(bottom(compareWith), l.y);\n        // Move the element up as far as it can go without colliding.\n        while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n            l.y--;\n        }\n    } else if (compactH) {\n        l.y = Math.min(bottom(compareWith), l.y);\n        // Move the element left as far as it can go without colliding.\n        while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n            l.x--;\n        }\n    }\n\n    // Move it down, and keep moving it down if it's colliding.\n    let collides;\n    while ((collides = getFirstCollision(compareWith, l))) {\n        if (compactH) {\n            resolveCompactionCollision(\n                fullLayout,\n                l,\n                collides.x + collides.w,\n                'x',\n            );\n        } else {\n            resolveCompactionCollision(\n                fullLayout,\n                l,\n                collides.y + collides.h,\n                'y',\n            );\n        }\n        // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n        if (compactH && l.x + l.w > cols) {\n            l.x = cols - l.w;\n            l.y++;\n        }\n    }\n    return l;\n}\n\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\nexport function correctBounds(layout: Layout, bounds: { cols: number }): Layout {\n    const collidesWith = getStatics(layout);\n    for (let i = 0, len = layout.length; i < len; i++) {\n        const l = layout[i];\n        // Overflows right\n        if (l.x + l.w > bounds.cols) {\n            l.x = bounds.cols - l.w;\n        }\n        // Overflows left\n        if (l.x < 0) {\n            l.x = 0;\n            l.w = bounds.cols;\n        }\n        if (!l.static) {\n            collidesWith.push(l);\n        } else {\n            // If this is static and collides with other statics, we must move it down.\n            // We have to do something nicer than just letting them overlap.\n            while (getFirstCollision(collidesWith, l)) {\n                l.y++;\n            }\n        }\n    }\n    return layout;\n}\n\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\nexport function getLayoutItem(\n    layout: Layout,\n    id: string,\n): LayoutItem | null | undefined {\n    for (let i = 0, len = layout.length; i < len; i++) {\n        if (layout[i].id === id) {\n            return layout[i];\n        }\n    }\n    return null;\n}\n\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\nexport function getFirstCollision(\n    layout: Layout,\n    layoutItem: LayoutItem,\n): LayoutItem | null | undefined {\n    for (let i = 0, len = layout.length; i < len; i++) {\n        if (collides(layout[i], layoutItem)) {\n            return layout[i];\n        }\n    }\n    return null;\n}\n\nexport function getAllCollisions(\n    layout: Layout,\n    layoutItem: LayoutItem,\n): Array<LayoutItem> {\n    return layout.filter(l => collides(l, layoutItem));\n}\n\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\nexport function getStatics(layout: Layout): Array<LayoutItem> {\n    return layout.filter(l => l.static);\n}\n\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\nexport function moveElement(\n    layout: Layout,\n    l: LayoutItem,\n    x: number | null | undefined,\n    y: number | null | undefined,\n    isUserAction: boolean | null | undefined,\n    preventCollision: boolean | null | undefined,\n    compactType: CompactType,\n    cols: number,\n): Layout {\n    // If this is static and not explicitly enabled as draggable,\n    // no move is possible, so we can short-circuit this immediately.\n    if (l.static && l.isDraggable !== true) {\n        return layout;\n    }\n\n    // Short-circuit if nothing to do.\n    if (l.y === y && l.x === x) {\n        return layout;\n    }\n\n    log(\n        `Moving element ${l.id} to [${String(x)},${String(y)}] from [${l.x},${\n            l.y\n        }]`,\n    );\n    const oldX = l.x;\n    const oldY = l.y;\n\n    // This is quite a bit faster than extending the object\n    if (typeof x === 'number') {\n        l.x = x;\n    }\n    if (typeof y === 'number') {\n        l.y = y;\n    }\n    l.moved = true;\n\n    // If this collides with anything, move it.\n    // When doing this comparison, we have to sort the items we compare with\n    // to ensure, in the case of multiple collisions, that we're getting the\n    // nearest collision.\n    let sorted = sortLayoutItems(layout, compactType);\n    const movingUp =\n        compactType === 'vertical' && typeof y === 'number'\n            ? oldY >= y\n            : compactType === 'horizontal' && typeof x === 'number'\n            ? oldX >= x\n            : false;\n    if (movingUp) {\n        sorted = sorted.reverse();\n    }\n    const collisions = getAllCollisions(sorted, l);\n\n    // There was a collision; abort\n    if (preventCollision && collisions.length) {\n        log(`Collision prevented on ${l.id}, reverting.`);\n        l.x = oldX;\n        l.y = oldY;\n        l.moved = false;\n        return layout;\n    }\n\n    // Move each item that collides away from this element.\n    for (let i = 0, len = collisions.length; i < len; i++) {\n        const collision = collisions[i];\n        log(\n            `Resolving collision between ${l.id} at [${l.x},${l.y}] and ${\n                collision.id\n            } at [${collision.x},${collision.y}]`,\n        );\n\n        // Short circuit so we can't infinite loop\n        if (collision.moved) {\n            continue;\n        }\n\n        // Don't move static items - we have to move *this* element away\n        if (collision.static) {\n            layout = moveElementAwayFromCollision(\n                layout,\n                collision,\n                l,\n                isUserAction,\n                compactType,\n                cols,\n            );\n        } else {\n            layout = moveElementAwayFromCollision(\n                layout,\n                l,\n                collision,\n                isUserAction,\n                compactType,\n                cols,\n            );\n        }\n    }\n\n    return layout;\n}\n\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\nexport function moveElementAwayFromCollision(\n    layout: Layout,\n    collidesWith: LayoutItem,\n    itemToMove: LayoutItem,\n    isUserAction: boolean | null | undefined,\n    compactType: CompactType,\n    cols: number,\n): Layout {\n    const compactH = compactType === 'horizontal';\n    // Compact vertically if not set to horizontal\n    const compactV = compactType !== 'horizontal';\n    const preventCollision = collidesWith.static; // we're already colliding (not for static items)\n\n    // If there is enough space above the collision to put this element, move it there.\n    // We only do this on the main collision as this can get funky in cascades and cause\n    // unwanted swapping behavior.\n    if (isUserAction) {\n        // Reset isUserAction flag because we're not in the main collision anymore.\n        isUserAction = false;\n\n        // Make a mock item so we don't modify the item here, only modify in moveElement.\n        const fakeItem: LayoutItem = {\n            x: compactH\n                ? Math.max(collidesWith.x - itemToMove.w, 0)\n                : itemToMove.x,\n            y: compactV\n                ? Math.max(collidesWith.y - itemToMove.h, 0)\n                : itemToMove.y,\n            w: itemToMove.w,\n            h: itemToMove.h,\n            id: '-1',\n        };\n\n        // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n        if (!getFirstCollision(layout, fakeItem)) {\n            log(\n                `Doing reverse collision on ${itemToMove.id} up to [${\n                    fakeItem.x\n                },${fakeItem.y}].`,\n            );\n            return moveElement(\n                layout,\n                itemToMove,\n                compactH ? fakeItem.x : undefined,\n                compactV ? fakeItem.y : undefined,\n                isUserAction,\n                preventCollision,\n                compactType,\n                cols,\n            );\n        }\n    }\n\n    return moveElement(\n        layout,\n        itemToMove,\n        compactH ? itemToMove.x + 1 : undefined,\n        compactV ? itemToMove.y + 1 : undefined,\n        isUserAction,\n        preventCollision,\n        compactType,\n        cols,\n    );\n}\n\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\nexport function perc(num: number): string {\n    return num * 100 + '%';\n}\n\nexport function setTransform({top, left, width, height}: Position): Object {\n    // Replace unitless items with px\n    const translate = `translate(${left}px,${top}px)`;\n    return {\n        transform: translate,\n        WebkitTransform: translate,\n        MozTransform: translate,\n        msTransform: translate,\n        OTransform: translate,\n        width: `${width}px`,\n        height: `${height}px`,\n        position: 'absolute',\n    };\n}\n\nexport function setTopLeft({top, left, width, height}: Position): Object {\n    return {\n        top: `${top}px`,\n        left: `${left}px`,\n        width: `${width}px`,\n        height: `${height}px`,\n        position: 'absolute',\n    };\n}\n\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\nexport function sortLayoutItems(\n    layout: Layout,\n    compactType: CompactType,\n): Layout {\n    if (compactType === 'horizontal') {\n        return sortLayoutItemsByColRow(layout);\n    } else {\n        return sortLayoutItemsByRowCol(layout);\n    }\n}\n\nexport function sortLayoutItemsByRowCol(layout: Layout): Layout {\n    return ([] as any[]).concat(layout).sort(function (a, b) {\n        if (a.y > b.y || (a.y === b.y && a.x > b.x)) {\n            return 1;\n        } else if (a.y === b.y && a.x === b.x) {\n            // Without this, we can get different sort results in IE vs. Chrome/FF\n            return 0;\n        }\n        return -1;\n    });\n}\n\nexport function sortLayoutItemsByColRow(layout: Layout): Layout {\n    return ([] as any[]).concat(layout).sort(function (a, b) {\n        if (a.x > b.x || (a.x === b.x && a.y > b.y)) {\n            return 1;\n        }\n        return -1;\n    });\n}\n\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nexport function validateLayout(\n    layout: Layout,\n    contextName: string = 'Layout',\n): void {\n    const subProps = ['x', 'y', 'w', 'h'];\n    if (!Array.isArray(layout)) {\n        throw new Error(contextName + ' must be an array!');\n    }\n    for (let i = 0, len = layout.length; i < len; i++) {\n        const item = layout[i];\n        for (let j = 0; j < subProps.length; j++) {\n            if (typeof item[subProps[j]] !== 'number') {\n                throw new Error(\n                    'ReactGridLayout: ' +\n                    contextName +\n                    '[' +\n                    i +\n                    '].' +\n                    subProps[j] +\n                    ' must be a number!',\n                );\n            }\n        }\n        if (item.id && typeof item.id !== 'string') {\n            throw new Error(\n                'ReactGridLayout: ' +\n                contextName +\n                '[' +\n                i +\n                '].i must be a string!',\n            );\n        }\n        if (item.static !== undefined && typeof item.static !== 'boolean') {\n            throw new Error(\n                'ReactGridLayout: ' +\n                contextName +\n                '[' +\n                i +\n                '].static must be a boolean!',\n            );\n        }\n    }\n}\n\n// Flow can't really figure this out, so we just use Object\nexport function autoBindHandlers(el: Object, fns: Array<string>): void {\n    fns.forEach(key => (el[key] = el[key].bind(el)));\n}\n\nfunction log(...args) {\n    if (!DEBUG) {\n        return;\n    }\n    // eslint-disable-next-line no-console\n    console.log(...args);\n}\n\nexport const noop = () => {};\n","/** Cached result of whether the user's browser supports passive event listeners. */\nlet supportsPassiveEvents: boolean;\n\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nexport function ktdSupportsPassiveEventListeners(): boolean {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', null!, Object.defineProperty({}, 'passive', {\n                get: () => supportsPassiveEvents = true\n            }));\n        } finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n\n    return supportsPassiveEvents;\n}\n\n/**\n * Normalizes an `AddEventListener` object to something that can be passed\n * to `addEventListener` on any browser, no matter whether it supports the\n * `options` parameter.\n * @param options Object to be normalized.\n */\nexport function ktdNormalizePassiveListenerOptions(options: AddEventListenerOptions):\n    AddEventListenerOptions | boolean {\n    return ktdSupportsPassiveEventListeners() ? options : !!options.capture;\n}\n","import { fromEvent, iif, merge, Observable } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport { ktdNormalizePassiveListenerOptions } from './passive-listeners';\n\n/** Options that can be used to bind a passive event listener. */\nconst passiveEventListenerOptions = ktdNormalizePassiveListenerOptions({passive: true});\n\n/** Options that can be used to bind an active event listener. */\nconst activeEventListenerOptions = ktdNormalizePassiveListenerOptions({passive: false});\n\nlet isMobile: boolean | null = null;\n\nexport function ktdIsMobileOrTablet(): boolean {\n\n    if (isMobile != null) {\n        return isMobile;\n    }\n\n    // Generic match pattern to identify mobile or tablet devices\n    const isMobileDevice = /Android|webOS|BlackBerry|Windows Phone|iPad|iPhone|iPod/i.test(navigator.userAgent);\n\n    // Since IOS 13 is not safe to just check for the generic solution. See: https://stackoverflow.com/questions/58019463/how-to-detect-device-name-in-safari-on-ios-13-while-it-doesnt-show-the-correct\n    const isIOSMobileDevice = /iPad|iPhone|iPod/.test(navigator.platform) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);\n\n    isMobile = isMobileDevice || isIOSMobileDevice;\n\n    return isMobile;\n}\n\nexport function ktdIsMouseEvent(event: any): event is MouseEvent {\n    return (event as MouseEvent).clientX != null;\n}\n\nexport function ktdIsTouchEvent(event: any): event is TouchEvent {\n    return (event as TouchEvent).touches != null && (event as TouchEvent).touches.length != null;\n}\n\nexport function ktdPointerClientX(event: MouseEvent | TouchEvent): number {\n    return ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX;\n}\n\nexport function ktdPointerClientY(event: MouseEvent | TouchEvent): number {\n    return ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY;\n}\n\nexport function ktdPointerClient(event: MouseEvent | TouchEvent): {clientX: number, clientY: number} {\n    return  {\n        clientX: ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX,\n        clientY: ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY\n    };\n}\n\n/**\n * Emits when a mousedown or touchstart emits. Avoids conflicts between both events.\n * @param element, html element where to  listen the events.\n * @param touchNumber number of the touch to track the event, default to the first one.\n */\nexport function ktdMouseOrTouchDown(element, touchNumber = 1): Observable<MouseEvent | TouchEvent> {\n    return iif(\n        () => ktdIsMobileOrTablet(),\n        fromEvent<TouchEvent>(element, 'touchstart', passiveEventListenerOptions as AddEventListenerOptions).pipe(\n            filter((touchEvent) => touchEvent.touches.length === touchNumber)\n        ),\n        fromEvent<MouseEvent>(element, 'mousedown', activeEventListenerOptions as AddEventListenerOptions).pipe(\n            filter((mouseEvent: MouseEvent) => {\n                /**\n                 * 0 : Left mouse button\n                 * 1 : Wheel button or middle button (if present)\n                 * 2 : Right mouse button\n                 */\n                return mouseEvent.button === 0; // Mouse down to be only fired if is left click\n            })\n        )\n    );\n}\n\n/**\n * Emits when a 'mousemove' or a 'touchmove' event gets fired.\n * @param element, html element where to  listen the events.\n * @param touchNumber number of the touch to track the event, default to the first one.\n */\nexport function ktdMouseOrTouchMove(element, touchNumber = 1): Observable<MouseEvent | TouchEvent> {\n    return iif(\n        () => ktdIsMobileOrTablet(),\n        fromEvent<TouchEvent>(element, 'touchmove', activeEventListenerOptions as AddEventListenerOptions).pipe(\n            filter((touchEvent) => touchEvent.touches.length === touchNumber),\n        ),\n        fromEvent<MouseEvent>(element, 'mousemove', activeEventListenerOptions as AddEventListenerOptions)\n    );\n}\n\nexport function ktdTouchEnd(element, touchNumber = 1): Observable<TouchEvent> {\n    return merge(\n        fromEvent<TouchEvent>(element, 'touchend').pipe(\n            filter((touchEvent) => touchEvent.touches.length === touchNumber - 1)\n        ),\n        fromEvent<TouchEvent>(element, 'touchcancel').pipe(\n            filter((touchEvent) => touchEvent.touches.length === touchNumber - 1)\n        )\n    );\n}\n\n/**\n * Emits when a there is a 'mouseup' or the touch ends.\n * @param element, html element where to  listen the events.\n * @param touchNumber number of the touch to track the event, default to the first one.\n */\nexport function ktdMouseOrTouchEnd(element, touchNumber = 1): Observable<MouseEvent | TouchEvent> {\n    return iif(\n        () => ktdIsMobileOrTablet(),\n        ktdTouchEnd(element, touchNumber),\n        fromEvent<MouseEvent>(element, 'mouseup'),\n    );\n}\n","import { compact, CompactType, getFirstCollision, Layout, LayoutItem, moveElement } from './react-grid-layout.utils';\nimport { KtdDraggingData, KtdGridCfg, KtdGridCompactType, KtdGridItemRect, KtdGridLayout, KtdGridLayoutItem } from '../grid.definitions';\nimport { ktdPointerClientX, ktdPointerClientY } from './pointer.utils';\nimport { KtdDictionary } from '../../types';\nimport { KtdGridItemComponent } from '../grid-item/grid-item.component';\n\n/** Tracks items by id. This function is mean to be used in conjunction with the ngFor that renders the 'ktd-grid-items' */\nexport function ktdTrackById(index: number, item: {id: string}) {\n    return item.id;\n}\n\n/**\n * Call react-grid-layout utils 'compact()' function and return the compacted layout.\n * @param layout to be compacted.\n * @param compactType, type of compaction.\n * @param cols, number of columns of the grid.\n */\nexport function ktdGridCompact(layout: KtdGridLayout, compactType: KtdGridCompactType, cols: number): KtdGridLayout {\n    return compact(layout, compactType, cols)\n        // Prune react-grid-layout compact extra properties.\n        .map(item => ({ id: item.id, x: item.x, y: item.y, w: item.w, h: item.h, minW: item.minW, minH: item.minH, maxW: item.maxW, maxH: item.maxH }));\n}\n\nfunction screenXPosToGridValue(screenXPos: number, cols: number, width: number): number {\n    return Math.round((screenXPos * cols) / width);\n}\n\nfunction screenYPosToGridValue(screenYPos: number, rowHeight: number, height: number): number {\n    return Math.round(screenYPos / rowHeight);\n}\n\n/** Returns a Dictionary where the key is the id and the value is the change applied to that item. If no changes Dictionary is empty. */\nexport function ktdGetGridLayoutDiff(gridLayoutA: KtdGridLayoutItem[], gridLayoutB: KtdGridLayoutItem[]): KtdDictionary<{ change: 'move' | 'resize' | 'moveresize' }> {\n    const diff: KtdDictionary<{ change: 'move' | 'resize' | 'moveresize' }> = {};\n\n    gridLayoutA.forEach(itemA => {\n        const itemB = gridLayoutB.find(_itemB => _itemB.id === itemA.id);\n        if (itemB != null) {\n            const posChanged = itemA.x !== itemB.x || itemA.y !== itemB.y;\n            const sizeChanged = itemA.w !== itemB.w || itemA.h !== itemB.h;\n            const change: 'move' | 'resize' | 'moveresize' | null = posChanged && sizeChanged ? 'moveresize' : posChanged ? 'move' : sizeChanged ? 'resize' : null;\n            if (change) {\n                diff[itemB.id] = {change};\n            }\n        }\n    });\n    return diff;\n}\n\n/**\n * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position\n * @param gridItem grid item that is been dragged\n * @param config current grid configuration\n * @param compactionType type of compaction that will be performed\n * @param draggingData contains all the information about the drag\n */\nexport function ktdGridItemDragging(gridItem: KtdGridItemComponent, config: KtdGridCfg, compactionType: CompactType, draggingData: KtdDraggingData): { layout: KtdGridLayoutItem[]; draggedItemPos: KtdGridItemRect } {\n    const {pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference} = draggingData;\n\n    const gridItemId = gridItem.id;\n\n    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId)!;\n\n    const clientStartX = ktdPointerClientX(pointerDownEvent);\n    const clientStartY = ktdPointerClientY(pointerDownEvent);\n    const clientX = ktdPointerClientX(pointerDragEvent);\n    const clientY = ktdPointerClientY(pointerDragEvent);\n\n    const offsetX = clientStartX - dragElemClientRect.left;\n    const offsetY = clientStartY - dragElemClientRect.top;\n\n    // Grid element positions taking into account the possible scroll total difference from the beginning.\n    const gridElementLeftPosition = gridElemClientRect.left + scrollDifference.left;\n    const gridElementTopPosition = gridElemClientRect.top + scrollDifference.top;\n\n    // Calculate position relative to the grid element.\n    const gridRelXPos = clientX - gridElementLeftPosition - offsetX;\n    const gridRelYPos = clientY - gridElementTopPosition - offsetY;\n\n    // Get layout item position\n    const layoutItem: KtdGridLayoutItem = {\n        ...draggingElemPrevItem,\n        x: screenXPosToGridValue(gridRelXPos, config.cols, gridElemClientRect.width),\n        y: screenYPosToGridValue(gridRelYPos, config.rowHeight, gridElemClientRect.height)\n    };\n\n    // Correct the values if they overflow, since 'moveElement' function doesn't do it\n    layoutItem.x = Math.max(0, layoutItem.x);\n    layoutItem.y = Math.max(0, layoutItem.y);\n    if (layoutItem.x + layoutItem.w > config.cols) {\n        layoutItem.x = Math.max(0, config.cols - layoutItem.w);\n    }\n\n    // Parse to LayoutItem array data in order to use 'react.grid-layout' utils\n    const layoutItems: LayoutItem[] = config.layout;\n    const draggedLayoutItem: LayoutItem = layoutItems.find(item => item.id === gridItemId)!;\n\n    let newLayoutItems: LayoutItem[] = moveElement(\n        layoutItems,\n        draggedLayoutItem,\n        layoutItem.x,\n        layoutItem.y,\n        true,\n        config.preventCollision,\n        compactionType,\n        config.cols\n    );\n\n    newLayoutItems = compact(newLayoutItems, compactionType, config.cols);\n\n    return {\n        layout: newLayoutItems,\n        draggedItemPos: {\n            top: gridRelYPos,\n            left: gridRelXPos,\n            width: dragElemClientRect.width,\n            height: dragElemClientRect.height,\n        }\n    };\n}\n\n/**\n * Given the grid config & layout data and the current drag position & information, returns the corresponding layout and drag item position\n * @param gridItem grid item that is been dragged\n * @param config current grid configuration\n * @param compactionType type of compaction that will be performed\n * @param draggingData contains all the information about the drag\n */\nexport function ktdGridItemResizing(gridItem: KtdGridItemComponent, config: KtdGridCfg, compactionType: CompactType, draggingData: KtdDraggingData): { layout: KtdGridLayoutItem[]; draggedItemPos: KtdGridItemRect } {\n    const {pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference} = draggingData;\n    const gridItemId = gridItem.id;\n\n    const clientStartX = ktdPointerClientX(pointerDownEvent);\n    const clientStartY = ktdPointerClientY(pointerDownEvent);\n    const clientX = ktdPointerClientX(pointerDragEvent);\n    const clientY = ktdPointerClientY(pointerDragEvent);\n\n    // Get the difference between the mouseDown and the position 'right' of the resize element.\n    const resizeElemOffsetX = dragElemClientRect.width - (clientStartX - dragElemClientRect.left);\n    const resizeElemOffsetY = dragElemClientRect.height - (clientStartY - dragElemClientRect.top);\n\n    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId)!;\n    const width = clientX + resizeElemOffsetX - (dragElemClientRect.left + scrollDifference.left);\n    const height = clientY + resizeElemOffsetY - (dragElemClientRect.top + scrollDifference.top);\n\n\n    // Get layout item grid position\n    const layoutItem: KtdGridLayoutItem = {\n        ...draggingElemPrevItem,\n        w: screenXPosToGridValue(width, config.cols, gridElemClientRect.width),\n        h: screenYPosToGridValue(height, config.rowHeight, gridElemClientRect.height)\n    };\n\n    layoutItem.w = limitNumberWithinRange(layoutItem.w, gridItem.minW ?? layoutItem.minW, gridItem.maxW ?? layoutItem.maxW);\n    layoutItem.h = limitNumberWithinRange(layoutItem.h, gridItem.minH ?? layoutItem.minH, gridItem.maxH ?? layoutItem.maxH);\n\n    if (layoutItem.x + layoutItem.w > config.cols) {\n        layoutItem.w = Math.max(1, config.cols - layoutItem.x);\n    }\n\n    if (config.preventCollision) {\n        const maxW = layoutItem.w;\n        const maxH = layoutItem.h;\n\n        let colliding = hasCollision(config.layout, layoutItem);\n        let shrunkDimension: 'w' | 'h' | undefined;\n\n        while (colliding) {\n            shrunkDimension = getDimensionToShrink(layoutItem, shrunkDimension);\n            layoutItem[shrunkDimension]--;\n            colliding = hasCollision(config.layout, layoutItem);\n        }\n\n        if (shrunkDimension === 'w') {\n            layoutItem.h = maxH;\n\n            colliding = hasCollision(config.layout, layoutItem);\n            while (colliding) {\n                layoutItem.h--;\n                colliding = hasCollision(config.layout, layoutItem);\n            }\n        }\n        if (shrunkDimension === 'h') {\n            layoutItem.w = maxW;\n\n            colliding = hasCollision(config.layout, layoutItem);\n            while (colliding) {\n                layoutItem.w--;\n                colliding = hasCollision(config.layout, layoutItem);\n            }\n        }\n\n    }\n\n    const newLayoutItems: LayoutItem[] = config.layout.map((item) => {\n        return item.id === gridItemId ? layoutItem : item;\n    });\n\n    return {\n        layout: compact(newLayoutItems, compactionType, config.cols),\n        draggedItemPos: {\n            top: dragElemClientRect.top - gridElemClientRect.top,\n            left: dragElemClientRect.left - gridElemClientRect.left,\n            width,\n            height,\n        }\n    };\n}\n\nfunction hasCollision(layout: Layout, layoutItem: LayoutItem): boolean {\n    return !!getFirstCollision(layout, layoutItem);\n}\n\nfunction getDimensionToShrink(layoutItem, lastShrunk): 'w' | 'h' {\n    if (layoutItem.h <= 1) {\n        return 'w';\n    }\n    if (layoutItem.w <= 1) {\n        return 'h';\n    }\n\n    return lastShrunk === 'w' ? 'h' : 'w';\n}\n\n/**\n * Given the current number and min/max values, returns the number within the range\n * @param number can be any numeric value\n * @param min minimum value of range\n * @param max maximum value of range\n */\nfunction limitNumberWithinRange(num: number, min: number = 1, max: number = Infinity) {\n    return Math.min(Math.max(num, min < 1 ? 1 : min), max);\n}\n","import { Directive, ElementRef, InjectionToken } from '@angular/core';\n\n/**\n * Injection token that can be used to reference instances of `KtdGridDragHandle`. It serves as\n * alternative token to the actual `KtdGridDragHandle` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const KTD_GRID_DRAG_HANDLE = new InjectionToken<KtdGridDragHandle>('KtdGridDragHandle');\n\n/** Handle that can be used to drag a KtdGridItem instance. */\n@Directive({\n    selector: '[ktdGridDragHandle]',\n    // eslint-disable-next-line @angular-eslint/no-host-metadata-property\n    host: {\n        class: 'ktd-grid-drag-handle'\n    },\n    providers: [{provide: KTD_GRID_DRAG_HANDLE, useExisting: KtdGridDragHandle}],\n})\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\nexport class KtdGridDragHandle {\n    constructor(\n        public element: ElementRef<HTMLElement>) {\n    }\n}\n","import { Directive, ElementRef, InjectionToken, } from '@angular/core';\n\n\n/**\n * Injection token that can be used to reference instances of `KtdGridResizeHandle`. It serves as\n * alternative token to the actual `KtdGridResizeHandle` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nexport const KTD_GRID_RESIZE_HANDLE = new InjectionToken<KtdGridResizeHandle>('KtdGridResizeHandle');\n\n/** Handle that can be used to drag a KtdGridItem instance. */\n@Directive({\n    selector: '[ktdGridResizeHandle]',\n    // eslint-disable-next-line @angular-eslint/no-host-metadata-property\n    host: {\n        class: 'ktd-grid-resize-handle'\n    },\n    providers: [{provide: KTD_GRID_RESIZE_HANDLE, useExisting: KtdGridResizeHandle}],\n})\n// eslint-disable-next-line @angular-eslint/directive-class-suffix\nexport class KtdGridResizeHandle {\n\n    constructor(\n        public element: ElementRef<HTMLElement>) {\n    }\n}\n","import { InjectionToken } from '@angular/core';\nimport { CompactType } from './utils/react-grid-layout.utils';\n\nexport interface KtdGridLayoutItem {\n    id: string;\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    minW?: number;\n    minH?: number;\n    maxW?: number;\n    maxH?: number;\n}\n\nexport type KtdGridCompactType = CompactType;\n\nexport interface KtdGridCfg {\n    cols: number;\n    rowHeight: number; // row height in pixels\n    layout: KtdGridLayoutItem[];\n    preventCollision: boolean;\n}\n\nexport type KtdGridLayout = KtdGridLayoutItem[];\n\n// TODO: Remove this interface. If can't remove, move and rename this interface in the core module or similar.\nexport interface KtdGridItemRect {\n    top: number;\n    left: number;\n    width: number;\n    height: number;\n}\n\nexport interface KtdGridItemRenderData<T = number | string> {\n    id: string;\n    top: T;\n    left: T;\n    width: T;\n    height: T;\n}\n\n/**\n * We inject a token because of the 'circular dependency issue warning'. In case we don't had this issue with the circular dependency, we could just\n * import KtdGridComponent on KtdGridItem and execute the needed function to get the rendering data.\n */\nexport type KtdGridItemRenderDataTokenType = (id: string) => KtdGridItemRenderData<string>;\nexport const GRID_ITEM_GET_RENDER_DATA_TOKEN: InjectionToken<KtdGridItemRenderDataTokenType> = new InjectionToken('GRID_ITEM_GET_RENDER_DATA_TOKEN');\n\nexport interface KtdDraggingData {\n    pointerDownEvent: MouseEvent | TouchEvent;\n    pointerDragEvent: MouseEvent | TouchEvent;\n    gridElemClientRect: ClientRect;\n    dragElemClientRect: ClientRect;\n    scrollDifference: { top: number, left: number };\n}\n","import { NgZone } from '@angular/core';\nimport { Observable, Subscription } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\n/** Runs source observable outside the zone */\nexport function ktdOutsideZone<T>(zone: NgZone) {\n    return (source: Observable<T>) => {\n        return new Observable<T>(observer => {\n            return zone.runOutsideAngular<Subscription>(() => source.subscribe(observer));\n        });\n    };\n}\n\n\n/** Rxjs operator that makes source observable to no emit any data */\nexport function ktdNoEmit() {\n    return (source$: Observable<any>): Observable<any> => {\n        return source$.pipe(filter(() => false));\n    };\n}\n","// tslint:disable\n/**\n * Type describing the allowed values for a boolean input.\n * @docs-private\n */\nexport type BooleanInput = string | boolean | null | undefined;\n\n/** Coerces a data-bound value (typically a string) to a boolean. */\nexport function coerceBooleanProperty(value: any): boolean {\n  return value != null && `${value}` !== 'false';\n}\n","// tslint:disable\nexport type NumberInput = string | number | null | undefined;\n\n/** Coerces a data-bound value (typically a string) to a number. */\nexport function coerceNumberProperty(value: any): number;\nexport function coerceNumberProperty<D>(value: any, fallback: D): number | D;\nexport function coerceNumberProperty(value: any, fallbackValue = 0) {\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n\n/**\n * Whether the provided value is considered a number.\n * @docs-private\n */\nexport function _isNumberValue(value: any): boolean {\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return !isNaN(parseFloat(value as any)) && !isNaN(Number(value));\n}\n","import { Injectable, NgZone, OnDestroy } from '@angular/core';\nimport { ktdNormalizePassiveListenerOptions } from './utils/passive-listeners';\nimport { fromEvent, iif, Observable, Subject, Subscription } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport { ktdIsMobileOrTablet } from './utils/pointer.utils';\n\n/** Event options that can be used to bind an active, capturing event. */\nconst activeCapturingEventOptions = ktdNormalizePassiveListenerOptions({\n    passive: false,\n    capture: true\n});\n\n@Injectable({providedIn: 'root'})\nexport class KtdGridService implements OnDestroy {\n\n    touchMove$: Observable<TouchEvent>;\n    private touchMoveSubject: Subject<TouchEvent> = new Subject<TouchEvent>();\n    private touchMoveSubscription: Subscription;\n\n    constructor(private ngZone: NgZone) {\n        this.touchMove$ = this.touchMoveSubject.asObservable();\n        this.registerTouchMoveSubscription();\n    }\n\n    ngOnDestroy() {\n        this.touchMoveSubscription.unsubscribe();\n    }\n\n    mouseOrTouchMove$(element): Observable<MouseEvent | TouchEvent> {\n        return iif(\n            () => ktdIsMobileOrTablet(),\n            this.touchMove$,\n            fromEvent<MouseEvent>(element, 'mousemove', activeCapturingEventOptions as AddEventListenerOptions) // TODO: Fix rxjs typings, boolean should be a good param too.\n        );\n    }\n\n    private registerTouchMoveSubscription() {\n        // The `touchmove` event gets bound once, ahead of time, because WebKit\n        // won't preventDefault on a dynamically-added `touchmove` listener.\n        // See https://bugs.webkit.org/show_bug.cgi?id=184250.\n        this.touchMoveSubscription = this.ngZone.runOutsideAngular(() =>\n            // The event handler has to be explicitly active,\n            // because newer browsers make it passive by default.\n            fromEvent(document, 'touchmove', activeCapturingEventOptions as AddEventListenerOptions) // TODO: Fix rxjs typings, boolean should be a good param too.\n                .pipe(filter((touchEvent: TouchEvent) => touchEvent.touches.length === 1))\n                .subscribe((touchEvent: TouchEvent) => this.touchMoveSubject.next(touchEvent))\n        );\n    }\n}\n","import {\n    AfterContentInit, ChangeDetectionStrategy, Component, ContentChildren, ElementRef, Inject, Input, NgZone, OnDestroy, OnInit, QueryList, Renderer2,\n    ViewChild\n} from '@angular/core';\nimport { BehaviorSubject, iif, merge, NEVER, Observable, Subject, Subscription } from 'rxjs';\nimport { exhaustMap, filter, map, startWith, switchMap, take, takeUntil } from 'rxjs/operators';\nimport { ktdMouseOrTouchDown, ktdMouseOrTouchEnd, ktdPointerClient } from '../utils/pointer.utils';\nimport { GRID_ITEM_GET_RENDER_DATA_TOKEN, KtdGridItemRenderDataTokenType } from '../grid.definitions';\nimport { KTD_GRID_DRAG_HANDLE, KtdGridDragHandle } from '../directives/drag-handle';\nimport { KTD_GRID_RESIZE_HANDLE, KtdGridResizeHandle } from '../directives/resize-handle';\nimport { KtdGridService } from '../grid.service';\nimport { ktdOutsideZone } from '../utils/operators';\nimport { BooleanInput, coerceBooleanProperty } from '../coercion/boolean-property';\nimport { coerceNumberProperty, NumberInput } from '../coercion/number-property';\n\n@Component({\n    selector: 'ktd-grid-item',\n    templateUrl: './grid-item.component.html',\n    styleUrls: ['./grid-item.component.scss'],\n    changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class KtdGridItemComponent implements OnInit, OnDestroy, AfterContentInit {\n    /** Elements that can be used to drag the grid item. */\n    @ContentChildren(KTD_GRID_DRAG_HANDLE, {descendants: true}) _dragHandles: QueryList<KtdGridDragHandle>;\n    @ContentChildren(KTD_GRID_RESIZE_HANDLE, {descendants: true}) _resizeHandles: QueryList<KtdGridResizeHandle>;\n    @ViewChild('resizeElem', {static: true, read: ElementRef}) resizeElem: ElementRef;\n\n    /** Min and max size input properties. Any of these would 'override' the min/max values specified in the layout. */\n    @Input() minW?: number;\n    @Input() minH?: number;\n    @Input() maxW?: number;\n    @Input() maxH?: number;\n\n    /** CSS transition style. Note that for more performance is preferable only make transition on transform property. */\n    @Input() transition: string = 'transform 500ms ease, width 500ms ease, height 500ms ease';\n\n    dragStart$: Observable<MouseEvent | TouchEvent>;\n    resizeStart$: Observable<MouseEvent | TouchEvent>;\n\n    /** Id of the grid item. This property is strictly compulsory. */\n    @Input()\n    get id(): string {\n        return this._id;\n    }\n\n    set id(val: string) {\n        this._id = val;\n    }\n\n    private _id: string;\n\n    /** Minimum amount of pixels that the user should move before it starts the drag sequence. */\n    @Input()\n    get dragStartThreshold(): number { return this._dragStartThreshold; }\n\n    set dragStartThreshold(val: number) {\n        this._dragStartThreshold = coerceNumberProperty(val);\n    }\n\n    private _dragStartThreshold: number = 0;\n\n\n    /** Whether the item is draggable or not. Defaults to true. */\n    @Input()\n    get draggable(): boolean {\n        return this._draggable;\n    }\n\n    set draggable(val: boolean) {\n        this._draggable = coerceBooleanProperty(val);\n        this._draggable$.next(this._draggable);\n    }\n\n    private _draggable: boolean = true;\n    private _draggable$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(this._draggable);\n\n    /** Whether the item is resizable or not. Defaults to true. */\n    @Input()\n    get resizable(): boolean {\n        return this._resizable;\n    }\n\n    set resizable(val: boolean) {\n        this._resizable = coerceBooleanProperty(val);\n        this._resizable$.next(this._resizable);\n    }\n\n    private _resizable: boolean = true;\n    private _resizable$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(this._resizable);\n\n    private dragStartSubject: Subject<MouseEvent | TouchEvent> = new Subject<MouseEvent | TouchEvent>();\n    private resizeStartSubject: Subject<MouseEvent | TouchEvent> = new Subject<MouseEvent | TouchEvent>();\n\n    private subscriptions: Subscription[] = [];\n\n    constructor(public elementRef: ElementRef,\n                private gridService: KtdGridService,\n                private renderer: Renderer2,\n                private ngZone: NgZone,\n                @Inject(GRID_ITEM_GET_RENDER_DATA_TOKEN) private getItemRenderData: KtdGridItemRenderDataTokenType) {\n        this.dragStart$ = this.dragStartSubject.asObservable();\n        this.resizeStart$ = this.resizeStartSubject.asObservable();\n    }\n\n    ngOnInit() {\n        const gridItemRenderData = this.getItemRenderData(this.id)!;\n        this.setStyles(gridItemRenderData);\n    }\n\n    ngAfterContentInit() {\n        this.subscriptions.push(\n            this._dragStart$().subscribe(this.dragStartSubject),\n            this._resizeStart$().subscribe(this.resizeStartSubject),\n        );\n    }\n\n    ngOnDestroy() {\n        this.subscriptions.forEach(sub => sub.unsubscribe());\n    }\n\n    setStyles({top, left, width, height}: { top: string, left: string, width?: string, height?: string }) {\n        // transform is 6x times faster than top/left\n        this.renderer.setStyle(this.elementRef.nativeElement, 'transform', `translateX(${left}) translateY(${top})`);\n        this.renderer.setStyle(this.elementRef.nativeElement, 'display', `block`);\n        this.renderer.setStyle(this.elementRef.nativeElement, 'transition', this.transition);\n        if (width != null) { this.renderer.setStyle(this.elementRef.nativeElement, 'width', width); }\n        if (height != null) {this.renderer.setStyle(this.elementRef.nativeElement, 'height', height); }\n    }\n\n    private _dragStart$(): Observable<MouseEvent | TouchEvent> {\n        return this._draggable$.pipe(\n            switchMap((draggable) => {\n                if (!draggable) {\n                    return NEVER;\n                } else {\n                    return this._dragHandles.changes.pipe(\n                        startWith(this._dragHandles),\n                        switchMap((dragHandles: QueryList<KtdGridDragHandle>) => {\n                            return iif(\n                                () => dragHandles.length > 0,\n                                merge(...dragHandles.toArray().map(dragHandle => ktdMouseOrTouchDown(dragHandle.element.nativeElement, 1))),\n                                ktdMouseOrTouchDown(this.elementRef.nativeElement, 1)\n                            ).pipe(\n                                exhaustMap((startEvent) => {\n                                    // If the event started from an element with the native HTML drag&drop, it'll interfere\n                                    // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\n                                    // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\n                                    // it's flaky and it fails if the user drags it away quickly. Also note that we only want\n                                    // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\n                                    // events from firing on touch devices.\n                                    if (startEvent.target && (startEvent.target as HTMLElement).draggable && startEvent.type === 'mousedown') {\n                                        startEvent.preventDefault();\n                                    }\n\n                                    const startPointer = ktdPointerClient(startEvent);\n                                    return this.gridService.mouseOrTouchMove$(document).pipe(\n                                        takeUntil(ktdMouseOrTouchEnd(document, 1)),\n                                        ktdOutsideZone(this.ngZone),\n                                        filter((moveEvent) => {\n                                            moveEvent.preventDefault();\n                                            const movePointer = ktdPointerClient(moveEvent);\n                                            const distanceX = Math.abs(startPointer.clientX - movePointer.clientX);\n                                            const distanceY = Math.abs(startPointer.clientY - movePointer.clientY);\n                                            // When this conditions returns true mean that we are over threshold.\n                                            return distanceX + distanceY >= this.dragStartThreshold;\n                                        }),\n                                        take(1),\n                                        // Return the original start event\n                                        map(() => startEvent)\n                                    );\n                                })\n                            );\n                        })\n                    );\n                }\n            })\n        );\n    }\n\n    private _resizeStart$(): Observable<MouseEvent | TouchEvent> {\n        return this._resizable$.pipe(\n            switchMap((resizable) => {\n                if (!resizable) {\n                    // Side effect to hide the resizeElem if resize is disabled.\n                    this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\n                    return NEVER;\n                } else {\n                    return this._resizeHandles.changes.pipe(\n                        startWith(this._resizeHandles),\n                        switchMap((resizeHandles: QueryList<KtdGridResizeHandle>) => {\n                            if (resizeHandles.length > 0) {\n                                // Side effect to hide the resizeElem if there are resize handles.\n                                this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\n                                return merge(...resizeHandles.toArray().map(resizeHandle => ktdMouseOrTouchDown(resizeHandle.element.nativeElement, 1)));\n                            } else {\n                                this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'block');\n                                return ktdMouseOrTouchDown(this.resizeElem.nativeElement, 1);\n                            }\n                        })\n                    );\n                }\n            })\n        );\n    }\n\n\n    // tslint:disable-next-line\n    static ngAcceptInputType_minW: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_minH: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_maxW: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_maxH: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_draggable: BooleanInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_resizable: BooleanInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_dragStartThreshold: NumberInput;\n\n}\n","<ng-content></ng-content>\n<div #resizeElem class=\"grid-item-resize-icon\"></div>\n","\n// tslint:disable\n\n/**\n * Client rect utilities.\n * This file is taken from Angular Material repository. This is the reason why the tslint is disabled on this case.\n * Don't enable it until some custom change is done on this file.\n */\n\n\n/** Gets a mutable version of an element's bounding `ClientRect`. */\nexport function getMutableClientRect(element: Element): ClientRect {\n    const { top, right, bottom, left, width, height, x, y, toJSON } = element.getBoundingClientRect();\n\n    // We need to clone the `clientRect` here, because all the values on it are readonly\n    // and we need to be able to update them. Also we can't use a spread here, because\n    // the values on a `ClientRect` aren't own properties. See:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n    return { top, right, bottom, left, width, height, x, y, toJSON };\n}\n\n/**\n * Checks whether some coordinates are within a `ClientRect`.\n * @param clientRect ClientRect that is being checked.\n * @param x Coordinates along the X axis.\n * @param y Coordinates along the Y axis.\n */\n// export function isInsideClientRect(clientRect: ClientRect, x: number, y: number) {\n//   const {top, bottom, left, right} = clientRect;\n//   return y >= top && y <= bottom && x >= left && x <= right;\n// }\n\n/**\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\n * @param clientRect `ClientRect` that should be updated.\n * @param top Amount to add to the `top` position.\n * @param left Amount to add to the `left` position.\n */\n// export function adjustClientRect(clientRect: ClientRect, top: number, left: number) {\n//   clientRect.top += top;\n//   clientRect.bottom = clientRect.top + clientRect.height;\n\n//   clientRect.left += left;\n//   clientRect.right = clientRect.left + clientRect.width;\n// }\n\n/**\n * Checks whether the pointer coordinates are close to a ClientRect.\n * @param rect ClientRect to check against.\n * @param threshold Threshold around the ClientRect.\n * @param pointerX Coordinates along the X axis.\n * @param pointerY Coordinates along the Y axis.\n */\n// export function isPointerNearClientRect(rect: ClientRect,\n//                                         threshold: number,\n//                                         pointerX: number,\n//                                         pointerY: number): boolean {\n//   const {top, right, bottom, left, width, height} = rect;\n//   const xThreshold = width * threshold;\n//   const yThreshold = height * threshold;\n\n//   return pointerY > top - yThreshold && pointerY < bottom + yThreshold &&\n//          pointerX > left - xThreshold && pointerX < right + xThreshold;\n// }\n","import { animationFrameScheduler, fromEvent, interval, NEVER, Observable } from 'rxjs';\nimport { distinctUntilChanged, map, switchMap, tap } from 'rxjs/operators';\nimport { ktdNormalizePassiveListenerOptions } from './passive-listeners';\nimport { getMutableClientRect } from './client-rect';\nimport { ktdNoEmit } from './operators';\n\n/**\n * Proximity, as a ratio to width/height at which to start auto-scrolling.\n * The value comes from trying it out manually until it feels right.\n */\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\n\n/** Vertical direction in which we can auto-scroll. */\nconst enum AutoScrollVerticalDirection {NONE, UP, DOWN}\n\n/** Horizontal direction in which we can auto-scroll. */\nconst enum AutoScrollHorizontalDirection {NONE, LEFT, RIGHT}\n\nexport interface KtdScrollPosition {\n    top: number;\n    left: number;\n}\n\n\n/**\n * Increments the vertical scroll position of a node.\n * @param node Node whose scroll position should change.\n * @param amount Amount of pixels that the `node` should be scrolled.\n */\nfunction incrementVerticalScroll(node: HTMLElement | Window, amount: number) {\n    if (node === window) {\n        (node as Window).scrollBy(0, amount);\n    } else {\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n        (node as HTMLElement).scrollTop += amount;\n    }\n}\n\n/**\n * Increments the horizontal scroll position of a node.\n * @param node Node whose scroll position should change.\n * @param amount Amount of pixels that the `node` should be scrolled.\n */\nfunction incrementHorizontalScroll(node: HTMLElement | Window, amount: number) {\n    if (node === window) {\n        (node as Window).scrollBy(amount, 0);\n    } else {\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n        (node as HTMLElement).scrollLeft += amount;\n    }\n}\n\n\n/**\n * Gets whether the vertical auto-scroll direction of a node.\n * @param clientRect Dimensions of the node.\n * @param pointerY Position of the user's pointer along the y axis.\n */\nfunction getVerticalScrollDirection(clientRect: ClientRect, pointerY: number) {\n    const {top, bottom, height} = clientRect;\n    const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\n\n    if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\n        return AutoScrollVerticalDirection.UP;\n    } else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\n        return AutoScrollVerticalDirection.DOWN;\n    }\n\n    return AutoScrollVerticalDirection.NONE;\n}\n\n/**\n * Gets whether the horizontal auto-scroll direction of a node.\n * @param clientRect Dimensions of the node.\n * @param pointerX Position of the user's pointer along the x axis.\n */\nfunction getHorizontalScrollDirection(clientRect: ClientRect, pointerX: number) {\n    const {left, right, width} = clientRect;\n    const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\n\n    if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\n        return AutoScrollHorizontalDirection.LEFT;\n    } else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\n        return AutoScrollHorizontalDirection.RIGHT;\n    }\n\n    return AutoScrollHorizontalDirection.NONE;\n}\n\n/**\n * Returns an observable that schedules a loop and apply scroll on the scrollNode into the specified direction/s.\n * This observable doesn't emit, it just performs the 'scroll' side effect.\n * @param scrollNode, node where the scroll would be applied.\n * @param verticalScrollDirection, vertical direction of the scroll.\n * @param horizontalScrollDirection, horizontal direction of the scroll.\n * @param scrollStep, scroll step in CSS pixels that would be applied in every loop.\n */\nfunction scrollToDirectionInterval$(scrollNode: HTMLElement | Window, verticalScrollDirection: AutoScrollVerticalDirection, horizontalScrollDirection: AutoScrollHorizontalDirection, scrollStep: number = 2) {\n    return interval(0, animationFrameScheduler)\n        .pipe(\n            tap(() => {\n                if (verticalScrollDirection === AutoScrollVerticalDirection.UP) {\n                    incrementVerticalScroll(scrollNode, -scrollStep);\n                } else if (verticalScrollDirection === AutoScrollVerticalDirection.DOWN) {\n                    incrementVerticalScroll(scrollNode, scrollStep);\n                }\n\n                if (horizontalScrollDirection === AutoScrollHorizontalDirection.LEFT) {\n                    incrementHorizontalScroll(scrollNode, -scrollStep);\n                } else if (horizontalScrollDirection === AutoScrollHorizontalDirection.RIGHT) {\n                    incrementHorizontalScroll(scrollNode, scrollStep);\n                }\n            }),\n            ktdNoEmit()\n        );\n}\n\nexport interface KtdScrollIfNearElementOptions {\n    scrollStep?: number;\n    disableVertical?: boolean;\n    disableHorizontal?: boolean;\n}\n\n/**\n * Given a source$ observable with pointer location, scroll the scrollNode if the pointer is near to it.\n * This observable doesn't emit, it just performs a 'scroll' side effect.\n * @param scrollableParent, parent node in which the scroll would be performed.\n * @param options, configuration options.\n */\nexport function ktdScrollIfNearElementClientRect$(scrollableParent: HTMLElement | Document, options?: KtdScrollIfNearElementOptions): (source$: Observable<{ pointerX: number, pointerY: number }>) => Observable<any> {\n\n    let scrollNode: Window | HTMLElement;\n    let scrollableParentClientRect: ClientRect;\n    let scrollableParentScrollWidth: number;\n\n    if (scrollableParent === document) {\n        scrollNode = document.defaultView as Window;\n        const {width, height} = getViewportSize();\n        scrollableParentClientRect = {width, height, top: 0, right: width, bottom: height, left: 0, x:0, y: 0, toJSON: () => null};\n        scrollableParentScrollWidth = getDocumentScrollWidth();\n    } else {\n        scrollNode = scrollableParent as HTMLElement;\n        scrollableParentClientRect = getMutableClientRect(scrollableParent as HTMLElement);\n        scrollableParentScrollWidth = (scrollableParent as HTMLElement).scrollWidth;\n    }\n\n    /**\n     * IMPORTANT: By design, only let scroll horizontal if the scrollable parent has explicitly an scroll horizontal.\n     * This layout solution is not designed in mind to have any scroll horizontal, but exceptionally we allow it in this\n     * specific use case.\n     */\n    options = options || {};\n    if (options.disableHorizontal == null && scrollableParentScrollWidth <= scrollableParentClientRect.width) {\n        options.disableHorizontal = true;\n    }\n\n    return (source$) => source$.pipe(\n        map(({pointerX, pointerY}) => {\n            let verticalScrollDirection = getVerticalScrollDirection(scrollableParentClientRect, pointerY);\n            let horizontalScrollDirection = getHorizontalScrollDirection(scrollableParentClientRect, pointerX);\n\n            // Check if scroll directions are disabled.\n            if (options?.disableVertical) {\n                verticalScrollDirection = AutoScrollVerticalDirection.NONE;\n            }\n            if (options?.disableHorizontal) {\n                horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;\n            }\n\n            return {verticalScrollDirection, horizontalScrollDirection};\n        }),\n        distinctUntilChanged((prev, actual) => {\n            return prev.verticalScrollDirection === actual.verticalScrollDirection\n                && prev.horizontalScrollDirection === actual.horizontalScrollDirection;\n        }),\n        switchMap(({verticalScrollDirection, horizontalScrollDirection}) => {\n            if (verticalScrollDirection || horizontalScrollDirection) {\n                return scrollToDirectionInterval$(scrollNode, verticalScrollDirection, horizontalScrollDirection, options?.scrollStep);\n            } else {\n                return NEVER;\n            }\n        })\n    );\n}\n\n/**\n * Emits on EVERY scroll event and returns the accumulated scroll offset relative to the initial scroll position.\n * @param scrollableParent, node in which scroll events would be listened.\n */\nexport function ktdGetScrollTotalRelativeDifference$(scrollableParent: HTMLElement | Document): Observable<{ top: number, left: number }> {\n    let scrollInitialPosition;\n\n    // Calculate initial scroll position\n    if (scrollableParent === document) {\n        scrollInitialPosition = getViewportScrollPosition();\n    } else {\n        scrollInitialPosition = {\n            top: (scrollableParent as HTMLElement).scrollTop,\n            left: (scrollableParent as HTMLElement).scrollLeft\n        };\n    }\n\n    return fromEvent(scrollableParent, 'scroll', ktdNormalizePassiveListenerOptions({capture: true}) as AddEventListenerOptions).pipe(\n        map(() => {\n            let newTop: number;\n            let newLeft: number;\n\n            if (scrollableParent === document) {\n                const viewportScrollPosition = getViewportScrollPosition();\n                newTop = viewportScrollPosition.top;\n                newLeft = viewportScrollPosition.left;\n            } else {\n                newTop = (scrollableParent as HTMLElement).scrollTop;\n                newLeft = (scrollableParent as HTMLElement).scrollLeft;\n            }\n\n            const topDifference = scrollInitialPosition.top - newTop;\n            const leftDifference = scrollInitialPosition.left - newLeft;\n\n            return {top: topDifference, left: leftDifference};\n        })\n    );\n\n}\n\n/** Returns the viewport's width and height. */\nfunction getViewportSize(): { width: number, height: number } {\n    const _window = document.defaultView || window;\n    return {\n        width: _window.innerWidth,\n        height: _window.innerHeight\n    };\n\n}\n\n/** Gets a ClientRect for the viewport's bounds. */\n// function getViewportRect(): ClientRect {\n//     // Use the document element's bounding rect rather than the window scroll properties\n//     // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n//     // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n//     // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n//     // can disagree when the page is pinch-zoomed (on devices that support touch).\n//     // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n//     // We use the documentElement instead of the body because, by default (without a css reset)\n//     // browsers typically give the document body an 8px margin, which is not included in\n//     // getBoundingClientRect().\n//     const scrollPosition = getViewportScrollPosition();\n//     const {width, height} = getViewportSize();\n\n//     return {\n//         top: scrollPosition.top,\n//         left: scrollPosition.left,\n//         bottom: scrollPosition.top + height,\n//         right: scrollPosition.left + width,\n//         height,\n//         width,\n//     };\n// }\n\n/** Gets the (top, left) scroll position of the viewport. */\nfunction getViewportScrollPosition(): { top: number, left: number } {\n\n    // The top-left-corner of the viewport is determined by the scroll position of the document\n    // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n    // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n    // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n    // `document.documentElement` works consistently, where the `top` and `left` values will\n    // equal negative the scroll position.\n    const windowRef = document.defaultView || window;\n    const documentElement = document.documentElement!;\n    const documentRect = documentElement.getBoundingClientRect();\n\n    const top = -documentRect.top || document.body.scrollTop || windowRef.scrollY ||\n        documentElement.scrollTop || 0;\n\n    const left = -documentRect.left || document.body.scrollLeft || windowRef.scrollX ||\n        documentElement.scrollLeft || 0;\n\n    return {top, left};\n}\n\n/** Returns the document scroll width */\nfunction getDocumentScrollWidth() {\n    return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\n}\n\n","import {\n    AfterContentChecked, AfterContentInit, ChangeDetectionStrategy, Component, ContentChildren, ElementRef, EventEmitter, Input, NgZone, OnChanges,\n    OnDestroy, Output, QueryList, Renderer2, SimpleChanges, ViewEncapsulation\n} from '@angular/core';\nimport { coerceNumberProperty, NumberInput } from './coercion/number-property';\nimport { KtdGridItemComponent } from './grid-item/grid-item.component';\nimport { combineLatest, merge, NEVER, Observable, Observer, of, Subscription } from 'rxjs';\nimport { exhaustMap, map, startWith, switchMap, takeUntil } from 'rxjs/operators';\nimport { ktdGridItemDragging, ktdGridItemResizing } from './utils/grid.utils';\nimport { compact, CompactType } from './utils/react-grid-layout.utils';\nimport {\n    GRID_ITEM_GET_RENDER_DATA_TOKEN, KtdDraggingData, KtdGridCfg, KtdGridCompactType, KtdGridItemRect, KtdGridItemRenderData, KtdGridLayout,\n    KtdGridLayoutItem\n} from './grid.definitions';\nimport { ktdMouseOrTouchEnd, ktdPointerClientX, ktdPointerClientY } from './utils/pointer.utils';\nimport { KtdDictionary } from '../types';\nimport { KtdGridService } from './grid.service';\nimport { getMutableClientRect } from './utils/client-rect';\nimport { ktdGetScrollTotalRelativeDifference$, ktdScrollIfNearElementClientRect$ } from './utils/scroll';\nimport { BooleanInput, coerceBooleanProperty } from './coercion/boolean-property';\n\ninterface KtdDragResizeEvent {\n    layout: KtdGridLayout;\n    layoutItem: KtdGridLayoutItem;\n    gridItemRef: KtdGridItemComponent;\n}\n\nexport type KtdDragStart = KtdDragResizeEvent;\nexport type KtdResizeStart = KtdDragResizeEvent;\nexport type KtdDragEnd = KtdDragResizeEvent;\nexport type KtdResizeEnd = KtdDragResizeEvent;\n\nfunction getDragResizeEventData(gridItem: KtdGridItemComponent, layout: KtdGridLayout): KtdDragResizeEvent {\n    return {\n        layout,\n        layoutItem: layout.find((item) => item.id === gridItem.id)!,\n        gridItemRef: gridItem\n    };\n}\n\n\nfunction layoutToRenderItems(config: KtdGridCfg, width: number, height: number): KtdDictionary<KtdGridItemRenderData<number>> {\n    const {cols, rowHeight, layout} = config;\n\n    const renderItems: KtdDictionary<KtdGridItemRenderData<number>> = {};\n    for (const item of layout) {\n        renderItems[item.id] = {\n            id: item.id,\n            top: item.y === 0 ? 0 : item.y * rowHeight,\n            left: item.x * (width / cols),\n            width: item.w * (width / cols),\n            height: item.h * rowHeight\n        };\n    }\n    return renderItems;\n}\n\nfunction getGridHeight(layout: KtdGridLayout, rowHeight: number): number {\n    return layout.reduce((acc, cur) => Math.max(acc, (cur.y + cur.h) * rowHeight), 0);\n}\n\n// tslint:disable-next-line\nexport function parseRenderItemToPixels(renderItem: KtdGridItemRenderData<number>): KtdGridItemRenderData<string> {\n    return {\n        id: renderItem.id,\n        top: `${renderItem.top}px`,\n        left: `${renderItem.left}px`,\n        width: `${renderItem.width}px`,\n        height: `${renderItem.height}px`\n    };\n}\n\n// tslint:disable-next-line:ktd-prefix-code\nexport function __gridItemGetRenderDataFactoryFunc(gridCmp: KtdGridComponent) {\n    // tslint:disable-next-line:only-arrow-functions\n    return function(id: string) {\n        return parseRenderItemToPixels(gridCmp.getItemRenderData(id));\n    };\n}\n\nexport function ktdGridItemGetRenderDataFactoryFunc(gridCmp: KtdGridComponent) {\n    // Workaround explained: https://github.com/ng-packagr/ng-packagr/issues/696#issuecomment-387114613\n    const resultFunc = __gridItemGetRenderDataFactoryFunc(gridCmp);\n    return resultFunc;\n}\n\n\n@Component({\n    selector: 'ktd-grid',\n    templateUrl: './grid.component.html',\n    styleUrls: ['./grid.component.scss'],\n    encapsulation: ViewEncapsulation.None,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    providers: [\n        {\n            provide: GRID_ITEM_GET_RENDER_DATA_TOKEN,\n            useFactory: ktdGridItemGetRenderDataFactoryFunc,\n            deps: [KtdGridComponent]\n        }\n    ]\n})\nexport class KtdGridComponent implements OnChanges, AfterContentInit, AfterContentChecked, OnDestroy {\n    /** Query list of grid items that are being rendered. */\n    @ContentChildren(KtdGridItemComponent, {descendants: true}) _gridItems: QueryList<KtdGridItemComponent>;\n\n    /** Emits when layout change */\n    @Output() layoutUpdated: EventEmitter<KtdGridLayout> = new EventEmitter<KtdGridLayout>();\n\n    /** Emits when drag starts */\n    @Output() dragStarted: EventEmitter<KtdDragStart> = new EventEmitter<KtdDragStart>();\n\n    /** Emits when resize starts */\n    @Output() resizeStarted: EventEmitter<KtdResizeStart> = new EventEmitter<KtdResizeStart>();\n\n    /** Emits when drag ends */\n    @Output() dragEnded: EventEmitter<KtdDragEnd> = new EventEmitter<KtdDragEnd>();\n\n    /** Emits when resize ends */\n    @Output() resizeEnded: EventEmitter<KtdResizeEnd> = new EventEmitter<KtdResizeEnd>();\n\n    /**\n     * Parent element that contains the scroll. If an string is provided it would search that element by id on the dom.\n     * If no data provided or null autoscroll is not performed.\n     */\n    @Input() scrollableParent: HTMLElement | Document | string | null = null;\n\n    /** Whether or not to update the internal layout when some dependent property change. */\n    @Input()\n    get compactOnPropsChange(): boolean { return this._compactOnPropsChange; }\n\n    set compactOnPropsChange(value: boolean) {\n        this._compactOnPropsChange = coerceBooleanProperty(value);\n    }\n\n    private _compactOnPropsChange: boolean = true;\n\n    /** If true, grid items won't change position when being dragged over. Handy when using no compaction */\n    @Input()\n    get preventCollision(): boolean { return this._preventCollision; }\n\n    set preventCollision(value: boolean) {\n        this._preventCollision = coerceBooleanProperty(value);\n    }\n\n    private _preventCollision: boolean = false;\n\n    /** Number of CSS pixels that would be scrolled on each 'tick' when auto scroll is performed. */\n    @Input()\n    get scrollSpeed(): number { return this._scrollSpeed; }\n\n    set scrollSpeed(value: number) {\n        this._scrollSpeed = coerceNumberProperty(value, 2);\n    }\n\n    private _scrollSpeed: number = 2;\n\n    /** Type of compaction that will be applied to the layout (vertical, horizontal or free). Defaults to 'vertical' */\n    @Input()\n    get compactType(): KtdGridCompactType {\n        return this._compactType;\n    }\n\n    set compactType(val: KtdGridCompactType) {\n        this._compactType = val;\n    }\n\n    private _compactType: KtdGridCompactType = 'vertical';\n\n    /** Row height in css pixels */\n    @Input()\n    get rowHeight(): number { return this._rowHeight; }\n\n    set rowHeight(val: number) {\n        this._rowHeight = Math.max(1, Math.round(coerceNumberProperty(val)));\n    }\n\n    private _rowHeight: number = 100;\n\n    /** Number of columns  */\n    @Input()\n    get cols(): number { return this._cols; }\n\n    set cols(val: number) {\n        this._cols = Math.max(1, Math.round(coerceNumberProperty(val)));\n    }\n\n    private _cols: number = 6;\n\n    /** Layout of the grid. Array of all the grid items with its 'id' and position on the grid. */\n    @Input()\n    get layout(): KtdGridLayout { return this._layout; }\n\n    set layout(layout: KtdGridLayout) {\n        /**\n         * Enhancement:\n         * Only set layout if it's reference has changed and use a boolean to track whenever recalculate the layout on ngOnChanges.\n         *\n         * Why:\n         * The normal use of this lib is having the variable layout in the outer component or in a store, assigning it whenever it changes and\n         * binded in the component with it's input [layout]. In this scenario, we would always calculate one unnecessary change on the layout when\n         * it is re-binded on the input.\n         */\n        this._layout = layout;\n    }\n\n    private _layout: KtdGridLayout;\n\n    get config(): KtdGridCfg {\n        return {\n            cols: this.cols,\n            rowHeight: this.rowHeight,\n            layout: this.layout,\n            preventCollision: this.preventCollision,\n        };\n    }\n\n    /** Total height of the grid */\n    private _height: number;\n    private _gridItemsRenderData: KtdDictionary<KtdGridItemRenderData<number>>;\n    private subscriptions: Subscription[];\n\n    constructor(private gridService: KtdGridService,\n                private elementRef: ElementRef,\n                private renderer: Renderer2,\n                private ngZone: NgZone) {\n\n    }\n\n    ngOnChanges(changes: SimpleChanges) {\n        let needsCompactLayout = false;\n        let needsRecalculateRenderData = false;\n\n        // TODO: Does fist change need to be compacted by default?\n        // Compact layout whenever some dependent prop changes.\n        if (changes.compactType || changes.cols || changes.layout) {\n            needsCompactLayout = true;\n        }\n\n        // Check if wee need to recalculate rendering data.\n        if (needsCompactLayout || changes.rowHeight) {\n            needsRecalculateRenderData = true;\n        }\n\n        // Only compact layout if lib user has provided it. Lib users that want to save/store always the same layout  as it is represented (compacted)\n        // can use KtdCompactGrid utility and pre-compact the layout. This is the recommended behaviour for always having a the same layout on this component\n        // and the ones that uses it.\n        if (needsCompactLayout && this.compactOnPropsChange) {\n            this.compactLayout();\n        }\n\n        if (needsRecalculateRenderData) {\n            this.calculateRenderData();\n        }\n    }\n\n    ngAfterContentInit() {\n        this.initSubscriptions();\n    }\n\n    ngAfterContentChecked() {\n        this.render();\n    }\n\n    resize() {\n        this.calculateRenderData();\n        this.render();\n    }\n\n    ngOnDestroy() {\n        this.subscriptions.forEach(sub => sub.unsubscribe());\n    }\n\n    compactLayout() {\n        this.layout = compact(this.layout, this.compactType, this.cols);\n    }\n\n    getItemsRenderData(): KtdDictionary<KtdGridItemRenderData<number>> {\n        return {...this._gridItemsRenderData};\n    }\n\n    getItemRenderData(itemId: string): KtdGridItemRenderData<number> {\n        return this._gridItemsRenderData[itemId];\n    }\n\n    calculateRenderData() {\n        const clientRect = (this.elementRef.nativeElement as HTMLElement).getBoundingClientRect();\n        this._gridItemsRenderData = layoutToRenderItems(this.config, clientRect.width, clientRect.height);\n        this._height = getGridHeight(this.layout, this.rowHeight);\n    }\n\n    render() {\n        this.renderer.setStyle(this.elementRef.nativeElement, 'height', `${this._height}px`);\n        this.updateGridItemsStyles();\n    }\n\n    private updateGridItemsStyles() {\n        this._gridItems.forEach(item => {\n            const gridItemRenderData: KtdGridItemRenderData<number> | undefined = this._gridItemsRenderData[item.id];\n            if (gridItemRenderData == null) {\n                console.error(`Couldn\\'t find the specified grid item for the id: ${item.id}`);\n            } else {\n                item.setStyles(parseRenderItemToPixels(gridItemRenderData));\n            }\n        });\n    }\n\n    private initSubscriptions() {\n        this.subscriptions = [\n            this._gridItems.changes.pipe(\n                startWith(this._gridItems),\n                switchMap((gridItems: QueryList<KtdGridItemComponent>) => {\n                    return merge(\n                        ...gridItems.map((gridItem) => gridItem.dragStart$.pipe(map((event) => ({event, gridItem, type: 'drag'})))),\n                        ...gridItems.map((gridItem) => gridItem.resizeStart$.pipe(map((event) => ({event, gridItem, type: 'resize'})))),\n                    ).pipe(exhaustMap(({event, gridItem, type}) => {\n                        // Emit drag or resize start events. Ensure that is start event is inside the zone.\n                        this.ngZone.run(() => (type === 'drag' ? this.dragStarted : this.resizeStarted).emit(getDragResizeEventData(gridItem, this.layout)));\n                        // Get the correct newStateFunc depending on if we are dragging or resizing\n                        const calcNewStateFunc = type === 'drag' ? ktdGridItemDragging : ktdGridItemResizing;\n\n                        // Perform drag sequence\n                        return this.performDragSequence$(gridItem, event, (gridItemId, config, compactionType, draggingData) =>\n                            calcNewStateFunc(gridItem, config, compactionType, draggingData)\n                        ).pipe(map((layout) => ({layout, gridItem, type})));\n\n                    }));\n                })\n            ).subscribe(({layout, gridItem, type}) => {\n                this.layout = layout;\n                // Calculate new rendering data given the new layout.\n                this.calculateRenderData();\n                // Emit drag or resize end events.\n                (type === 'drag' ? this.dragEnded : this.resizeEnded).emit(getDragResizeEventData(gridItem, layout));\n                // Notify that the layout has been updated.\n                this.layoutUpdated.emit(layout);\n            })\n\n        ];\n    }\n\n    /**\n     * Perform a general grid drag action, from start to end. A general grid drag action basically includes creating the placeholder element and adding\n     * some class animations. calcNewStateFunc needs to be provided in order to calculate the new state of the layout.\n     * @param gridItem that is been dragged\n     * @param pointerDownEvent event (mousedown or touchdown) where the user initiated the drag\n     * @param calcNewStateFunc function that return the new layout state and the drag element position\n     */\n    private performDragSequence$(gridItem: KtdGridItemComponent, pointerDownEvent: MouseEvent | TouchEvent,\n                                 calcNewStateFunc: (gridItem: KtdGridItemComponent, config: KtdGridCfg, compactionType: CompactType, draggingData: KtdDraggingData) => { layout: KtdGridLayoutItem[]; draggedItemPos: KtdGridItemRect }): Observable<KtdGridLayout> {\n\n        return new Observable<KtdGridLayout>((observer: Observer<KtdGridLayout>) => {\n            // Retrieve grid (parent) and gridItem (draggedElem) client rects.\n            const gridElemClientRect: ClientRect = getMutableClientRect(this.elementRef.nativeElement as HTMLElement);\n            const dragElemClientRect: ClientRect = getMutableClientRect(gridItem.elementRef.nativeElement as HTMLElement);\n\n            const scrollableParent = typeof this.scrollableParent === 'string' ? document.getElementById(this.scrollableParent) : this.scrollableParent;\n\n            this.renderer.addClass(gridItem.elementRef.nativeElement, 'no-transitions');\n            this.renderer.addClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging');\n\n            // Create placeholder element. This element would represent the position where the dragged/resized element would be if the action ends\n            const placeholderElement: HTMLDivElement = this.renderer.createElement('div');\n            placeholderElement.style.width = `${dragElemClientRect.width}px`;\n            placeholderElement.style.height = `${dragElemClientRect.height}px`;\n            placeholderElement.style.transform = `translateX(${dragElemClientRect.left - gridElemClientRect.left}px) translateY(${dragElemClientRect.top - gridElemClientRect.top}px)`;\n\n            this.renderer.addClass(placeholderElement, 'ktd-grid-item-placeholder');\n            this.renderer.appendChild(this.elementRef.nativeElement, placeholderElement);\n\n            let newLayout: KtdGridLayoutItem[];\n\n            // TODO (enhancement): consider move this 'side effect' observable inside the main drag loop.\n            //  - Pros are that we would not repeat subscriptions and takeUntil would shut down observables at the same time.\n            //  - Cons are that moving this functionality as a side effect inside the main drag loop would be confusing.\n            const scrollSubscription = this.ngZone.runOutsideAngular(() =>\n                (!scrollableParent ? NEVER : this.gridService.mouseOrTouchMove$(document).pipe(\n                    map((event) => ({\n                        pointerX: ktdPointerClientX(event),\n                        pointerY: ktdPointerClientY(event)\n                    })),\n                    ktdScrollIfNearElementClientRect$(scrollableParent, {scrollStep: this.scrollSpeed})\n                )).pipe(\n                    takeUntil(ktdMouseOrTouchEnd(document))\n                ).subscribe());\n\n            /**\n             * Main subscription, it listens for 'pointer move' and 'scroll' events and recalculates the layout on each emission\n             */\n            const subscription = this.ngZone.runOutsideAngular(() =>\n                merge(\n                    combineLatest([\n                        this.gridService.mouseOrTouchMove$(document),\n                        ...(!scrollableParent ? [of({top: 0, left: 0})] : [\n                            ktdGetScrollTotalRelativeDifference$(scrollableParent).pipe(\n                                startWith({top: 0, left: 0}) // Force first emission to allow CombineLatest to emit even no scroll event has occurred\n                            )\n                        ])\n                    ])\n                ).pipe(\n                    takeUntil(ktdMouseOrTouchEnd(document)),\n                ).subscribe(([pointerDragEvent, scrollDifference]: [MouseEvent | TouchEvent, { top: number, left: number }]) => {\n                        pointerDragEvent.preventDefault();\n\n                        /**\n                         * Set the new layout to be the layout in which the calcNewStateFunc would be executed.\n                         * NOTE: using the mutated layout is the way to go by 'react-grid-layout' utils. If we don't use the previous layout,\n                         * some utilities from 'react-grid-layout' would not work as expected.\n                         */\n                        const currentLayout: KtdGridLayout = newLayout || this.layout;\n\n                        const {layout, draggedItemPos} = calcNewStateFunc(gridItem, {\n                            layout: currentLayout,\n                            rowHeight: this.rowHeight,\n                            cols: this.cols,\n                            preventCollision: this.preventCollision\n                        }, this.compactType, {\n                            pointerDownEvent,\n                            pointerDragEvent,\n                            gridElemClientRect,\n                            dragElemClientRect,\n                            scrollDifference\n                        });\n                        newLayout = layout;\n\n                        this._height = getGridHeight(newLayout, this.rowHeight);\n\n                        this._gridItemsRenderData = layoutToRenderItems({\n                            cols: this.cols,\n                            rowHeight: this.rowHeight,\n                            layout: newLayout,\n                            preventCollision: this.preventCollision,\n                        }, gridElemClientRect.width, gridElemClientRect.height);\n\n                        const placeholderStyles = parseRenderItemToPixels(this._gridItemsRenderData[gridItem.id]);\n\n                        // Put the real final position to the placeholder element\n                        placeholderElement.style.width = placeholderStyles.width;\n                        placeholderElement.style.height = placeholderStyles.height;\n                        placeholderElement.style.transform = `translateX(${placeholderStyles.left}) translateY(${placeholderStyles.top})`;\n\n                        // modify the position of the dragged item to be the once we want (for example the mouse position or whatever)\n                        this._gridItemsRenderData[gridItem.id] = {\n                            ...draggedItemPos,\n                            id: this._gridItemsRenderData[gridItem.id].id\n                        };\n\n                        this.render();\n                    },\n                    (error) => observer.error(error),\n                    () => {\n                        this.ngZone.run(() => {\n                            // Remove drag classes\n                            this.renderer.removeClass(gridItem.elementRef.nativeElement, 'no-transitions');\n                            this.renderer.removeClass(gridItem.elementRef.nativeElement, 'ktd-grid-item-dragging');\n\n                            // Remove placeholder element from the dom\n                            // NOTE: If we don't put the removeChild inside the zone it would not work... This may be a bug from angular or maybe is the intended behaviour, although strange.\n                            // It should work since AFAIK this action should not be done in a CD cycle.\n                            this.renderer.removeChild(this.elementRef.nativeElement, placeholderElement);\n\n                            if (newLayout) {\n                                // TODO: newLayout should already be pruned. If not, it should have type Layout, not KtdGridLayout as it is now.\n                                // Prune react-grid-layout compact extra properties.\n                                observer.next(newLayout.map(item => ({\n                                    id: item.id,\n                                    x: item.x,\n                                    y: item.y,\n                                    w: item.w,\n                                    h: item.h,\n                                    minW: item.minW,\n                                    minH: item.minH,\n                                    maxW: item.maxW,\n                                    maxH: item.maxH,\n                                })) as KtdGridLayout);\n                            } else {\n                                // TODO: Need we really to emit if there is no layout change but drag started and ended?\n                                observer.next(this.layout);\n                            }\n\n                            observer.complete();\n                        });\n\n                    }));\n\n\n            return () => {\n                scrollSubscription.unsubscribe();\n                subscription.unsubscribe();\n            };\n        });\n    }\n\n\n    // tslint:disable-next-line\n    static ngAcceptInputType_cols: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_rowHeight: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_scrollSpeed: NumberInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_compactOnPropsChange: BooleanInput;\n    // tslint:disable-next-line\n    static ngAcceptInputType_preventCollision: BooleanInput;\n}\n\n","<ng-content></ng-content>\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { KtdGridComponent } from './grid.component';\nimport { KtdGridItemComponent } from './grid-item/grid-item.component';\nimport { KtdGridDragHandle } from './directives/drag-handle';\nimport { KtdGridResizeHandle } from './directives/resize-handle';\nimport { KtdGridService } from './grid.service';\n\n@NgModule({\n    declarations: [\n        KtdGridComponent,\n        KtdGridItemComponent,\n        KtdGridDragHandle,\n        KtdGridResizeHandle\n    ],\n    exports: [\n        KtdGridComponent,\n        KtdGridItemComponent,\n        KtdGridDragHandle,\n        KtdGridResizeHandle\n    ],\n    providers: [\n        KtdGridService\n    ],\n    imports: [\n        CommonModule\n    ]\n})\nexport class KtdGridModule {}\n","/*\n * Public API Surface of grid\n */\nexport { ktdGridCompact, ktdTrackById } from './lib/utils/grid.utils';\nexport * from './lib/directives/drag-handle';\nexport * from './lib/directives/resize-handle';\nexport * from './lib/grid-item/grid-item.component';\nexport * from './lib/grid.definitions';\nexport * from './lib/grid.component';\nexport * from './lib/grid.module';\n\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["i1.KtdGridService"],"mappings":"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"}}}